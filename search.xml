<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SERVER12服务器问题小记]]></title>
    <url>%2F2019%2F01%2F18%2FSERVER12%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[123456789server2012服务器的安装出现的问题:.NET Framework 功能安装失败百度了一下好像是缺少相对应的镜像文件①:下载相对应的源文件 进行解压安装②:联网安装 推荐进行联网安装 (本人联网安装成功)当然也不排除其他一些解决方法(百度了一下方法很多)貌似server08没有这个问题 不联网的话好像也可以安装成功第一次安装server12的就只有这一个问题 一直失败 插入网线之后一次成功]]></content>
      <categories>
        <category>server服务器问题</category>
      </categories>
      <tags>
        <tag>server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令快速手册]]></title>
    <url>%2F2019%2F01%2F14%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BF%AB%E9%80%9F%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Git常用命令快速手册本文来自:https://mp.weixin.qq.com/s/tNUuYt75R2HsWF1ytLUc7g git的四个组成部分 1、初始化仓库1git init 2、将文件添加到仓库12345git add 文件名 # 将工作区的某个文件添加到暂存区 git add -u # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件git add -A # 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件git add . # 将当前工作区的所有文件都加入暂存区git add -i # 进入交互界面模式，按需添加文件到缓存区 3、将暂存区文件提交到本地仓库12git commit -m &quot;提交说明&quot; # 将暂存区内容提交到本地仓库git commit -a -m &quot;提交说明&quot; # 跳过缓存区操作，直接把工作区内容提交到本地仓库 4、查看仓库当前状态1git status 5、比较文件异同12345678910git diff # 工作区与暂存区的差异git diff 分支名 #工作区与某分支的差异，远程分支这样写：remotes/origin/分支名git diff HEAD # 工作区与HEAD指针指向的内容差异git diff 提交id 文件路径 # 工作区某文件当前版本与历史版本的差异git diff --stage # 工作区文件与上次提交的差异(1.6 版本前用 --cached)git diff 版本TAG # 查看从某个版本后都改动内容git diff 分支A 分支B # 比较从分支A和分支B的差异(也支持比较两个TAG)git diff 分支A...分支B # 比较两分支在分开后各自的改动# 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数 6、查看历史记录1234567891011git log # 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)git log -p -次数 # 查看最近多少次的提交记录git log --stat # 简略显示每次提交的内容更改git log --name-only # 仅显示已修改的文件清单git log --name-status # 显示新增，修改，删除的文件清单git log --oneline # 让提交记录以精简的一行输出git log –graph –all --online # 图形展示分支的合并历史git log --author=作者 # 查询作者的提交记录(和grep同时使用要加一个--all--match参数)git log --grep=过滤信息 # 列出提交信息中包含过滤信息的提交记录git log -S查询内容 # 和--grep类似，S和查询内容间没有空格git log fileName # 查看某文件的修改记录，找背锅专用 7、代码回滚12345678910git reset HEAD^ # 恢复成上次提交的版本git reset HEAD^^ # 恢复成上上次提交的版本，就是多个^，以此类推或用~次数git refloggit reset --hard 版本号--soft：只是改变HEAD指针指向，缓存区和工作区不变；--mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；--hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态； 8、同步远程仓库1git push -u origin master 9、删除版本库文件1git rm 文件名 10、版本库里的版本替换工作区的版本1git checkout -- test.txt 11、本地仓库内容推送到远程仓库1git remote add origin git@github.com:帐号名/仓库名.git 12、从远程仓库克隆项目到本地1git clone git@github.com:git帐号名/仓库名.git 13、创建分支12345git checkout -b dev-b表示创建并切换分支上面一条命令相当于一面的二条：git branch dev //创建分支git checkout dev //切换分支 14、查看分支1git branch 15、合并分支12345git merge dev//用于合并指定分支到当前分支git merge --no-ff -m &quot;merge with no-ff&quot; dev//加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并 16、删除分支1git branch -d dev 17、查看分支合并图1git log --graph --pretty=oneline --abbrev-commit 18、查看远程库信息12git remote// -v 显示更详细的信息 19、git相关配置123456789101112# 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：git config --global user.name &quot;用户名&quot; # 设置用户名git config --global user.email &quot;用户邮箱&quot; #设置邮箱git config --global user.name # 查看用户名是否配置成功git config --global user.email # 查看邮箱是否配置# 其他查看配置相关git config --global --list # 查看全局设置相关参数列表git config --local --list # 查看本地设置相关参数列表git config --system --list # 查看系统配置参数列表git config --list # 查看所有Git的配置(全局+本地+系统)git config --global color.ui true //显示git相关颜色 20、撤消某次提交12git revert HEAD # 撤销最近的一个提交git revert 版本号 # 撤销某次commit 21、拉取远程分支到本地仓库123git checkout -b 本地分支 远程分支 # 会在本地新建分支，并自动切换到该分支git fetch origin 远程分支:本地分支 # 会在本地新建分支，但不会自动切换，还需checkoutgit branch --set-upstream 本地分支 远程分支 # 建立本地分支与远程分支的链接 22、标签命令1234git tag 标签 //打标签命令，默认为HEADgit tag //显示所有标签git tag 标签 �版本号 //给某个commit版本添加标签git show 标签 //显示某个标签的详细信息 23、同步远程仓库更新1234git fetch origin master //从远程获取最新的到本地，首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别，最后进行合并。git fetch比git pull更加安全]]></content>
      <categories>
        <category>Git命令</category>
      </categories>
      <tags>
        <tag>Git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题7]]></title>
    <url>%2F2018%2F12%2F07%2FJava%E9%9D%A2%E8%AF%95%E9%A2%987%2F</url>
    <content type="text"><![CDATA[Java面试题761.什么是并发修改异常?1234567891011121314151617什么是并发修改异常：当我们在遍历实现了collection接口与iterator接口的集合时（List、Set、Map）, 我们可以通过遍历索引也可以通过迭代器进行遍历。在我们使用迭代器进行遍历集合的时候，会获取到当前集合的迭代对象。在里面有封装了迭代器的remove方法与集合自带的remove方法，如果我们调用迭代器对象的remove方法是没问题的，但是当我们调用集合自带的remove方法时，就会产生ConcurrentModificationException 并发修改异常。也就是说，当我们通过迭代器进行遍历集合的时候，是不允许集合本身在结构上发生变化的。 62.什么是CopyOnWriteArrayList，它与ArrayList有何不同？1234567891011121314151617181920212223242526272829303132333435363738CopyOnWriteArrayList:CopyOnWriteArrayList这是一个ArrayList的线程安全的变体，其原理大概可以通俗的理解为:初始化的时候只有一个容器，很常一段时间，这个容器数据、数量等没有发生变化的时候，大家(多个线程)，都是读取假设这段时间里只发生读取的操作同一个容器中的数据，所以这样大家读到的数据都是唯一、一致、安全的，但是后来有人往里面增加了一个数据，这个时候CopyOnWriteArrayList 底层实现添加的原理是先copy出一个容器可以简称副本，再往新的容器里添加这个新的数据，最后把新的容器的引用地址赋值给了之前那个旧的的容器地址，但是在添加这个数据的期间，其他线程如果要去读取数据，仍然是读取到旧的容器里的数据。Vector ArrayList CopyOnWriteArrayList 这三个集合类都继承List接口1、ArrayList是线程不安全的；2、Vector是比较古老的线程安全的，但性能不行；3、CopyOnWriteArrayList在兼顾了线程安全的同时，又提高了并发性，性能比Vector有不少提高 63.迭代器和枚举之间的区别?1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950在Java集合中，我们通常都通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合。Enumeration是一个接口，它的源码如下：package java.util;public interface Enumeration&lt;E&gt; &#123; boolean hasMoreElements() E nextElement();&#125;Iterator也是一个接口，它的源码如下:package java.util;public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125;区别：1 函数接口不同Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。2.Iterator支持fail-fast机制，而Enumeration不支持。Enumeration 是JDK 1.0添加的接口。 使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。Java API规范建议，对于较新的程序，Iterator应优先于Enumeration，因为“ Iterator在Java集合框架中代替Enumeration。” 64.Hashmap如何同步?1234567891011121314151617181920212223242526272829303132333435361、使用 synchronized 关键字，这也是最原始的方法。synchronized(anObject) &#123; value = map.get(key); &#125; 2、使用 JDK1.5 提供的锁Java.util.concurrent.locks.Locklock.lock(); value = map.get(key); lock.unlock(); 3.可以使用 JDK1.5 提供的读写锁java.util.concurrent.locks.ReadWriteLockrwlock.readLock().lock(); value = map.get(key); rwlock.readLock().unlock(); 4.使用 JDK1.5 提供的 java.util.concurrent.ConcurrentHashMap 类该类将 Map 的存储空间分为若干块，每块拥有自己的锁，大大减少了多个线程争夺同一个锁的情况value = map.get(key); 1、不同步确实最快，与预期一致。 2、四种同步方式中，ConcurrentHashMap 是最快的，接近不同步的情况。 3、synchronized 关键字非常慢4、使用读写锁的读锁，比普通所稍慢。1、如果 ConcurrentHashMap 够用，则使用 ConcurrentHashMap。 2、如果需自己实现同步，则使用 JDK1.5 提供的锁机制，避免使用 synchronized 关键字。 65.IdentityHashMap和HashMap的区别?12345678910111213141516171819202122232425262728前者比较key时是“引用相等”而后者是“对象相等”，即对于k1和k2，当k1==k2时， IdentityHashMap认为两个key相等，而HashMap只有在k1.equals(k2) == true 时才会认为两个key相等。 2.IdentityHashMap 允许使用null作为key和value. 不保证任何Key-value对的之间的顺序, 更不能保证他们的顺序随时间的推移不会发生变化。 3.IdentityHashMap有其特殊用途，比如序列化或者深度复制。或者记录对象代理。 举个例子，jvm中的所有对象都是独一无二的，哪怕两个对象是同一个class的对象 而且两个对象的数据完全相同，对于jvm来说，他们也是完全不同的， 如果要用一个map来记录这样jvm中的对象，你就需要用IdentityHashMap，而不能使用其他Map实现 66.如何获取某个日期是当月的最后一天?1234567891011121314import java.util.Calendar;public class Test &#123;public static void main(String[] args) &#123; System.out.println(daysCount(2010, 2));&#125;public static int daysCount(int year, int month) &#123; Calendar cal = Calendar.getInstance(); cal.set(Calendar.YEAR, year); cal.set(Calendar.MONTH, month); cal.set(Calendar.DATE, 0); return cal.get(Calendar.DATE);&#125;&#125; 67.java中会存在内存泄漏吗，请简单描述12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667所谓内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java中有垃圾回收机制，它可以保证一对象不再被引用的时候，即对象编程了孤儿的时候，对象将自动被垃圾回收器从内存中清除掉。由于Java 使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。java中的内存泄露的情况：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况，例如，缓存系统，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用，但却不再被使用。 检查java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。内存泄露的另外一种情况：当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露 68.java中实现多态的机制是什么?123456789101112131415161718192021222324252627282930313233343536373839404142434445靠的是父类或接口的引用指向子类或实现类的对象，调用的方法是内存中正在运行的那个对象的方法。Java实现多态有三个必要条件：继承、重写、向上转型。继承：在多态中必须存在有继承关系的子类和父类。重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。多态机制遵循的原则概括为当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法，但是它仍然要根据继承链中方法调用的优先级来确认方法，该优先级为：this.method(O)、super.method(O)、this.method((super)O)、super.method((super)O)。 69.局部变量和成员变量的区别?1234567891011121314151617181920212223242526272829303132成员变量与局部变量的区别1、在类中的位置不同成员变量：在类中方法外面局部变量：在方法或者代码块中，或者方法的声明上2、在内存中的位置不同，成员变量：在堆中（方法区中的静态区）局部变量：在栈中3、生命周期不同成员变量：随着对象的创建而存在，随着对象的消失而消失局部变量：随着方法的调用或者代码块的执行而存在，随着方法的调用完毕或者代码块的执行完毕而消失4、初始值成员变量：有默认初始值局部变量：没有默认初始值，使用之前需要赋值，否则编译器会报错 70.什么是匿名类,有什么好处?12345678910111213141516171819202122232425简单地说：匿名内部类就是没有名字的内部类。什么情况下需要使用匿名内部类？如果满足下面的一些条件，使用匿名内部类是比较合适的： 只用到类的一个实例。 类在定义后马上用到。 类非常小（SUN推荐是在4行代码以下） 给类命名并不会导致你的代码更容易被理解。 在使用匿名内部类时，要记住以下几个原则： 匿名内部类不能有构造方法。 匿名内部类不能定义任何静态成员、方法和类。 匿名内部类不能是public,protected,private,static。 只能创建匿名内部类的一个实例。 一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。 因匿名内部类为局部内部类，所以局部内部类的所有限制都对其生效。]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题6]]></title>
    <url>%2F2018%2F12%2F06%2FJava%E9%9D%A2%E8%AF%95%E9%A2%986%2F</url>
    <content type="text"><![CDATA[Java面试题651.HashMap的实现原理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表当前entry的next指向null,那么对于查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 52.List、Set、Map之间的区别123456789101112131415161718192021222324252627282930313233343536373839List、Set是实现了Collection接口的子接口；而Map是另一个集合接口。1元素重复性： List允许有重复的元素。任何数量的重复元素都可以在不影响现有重复元素的值及其索引的情况下插入到List集合中；Set集合不允许元素重复。Set以及所有实现了Set接口的类都不允许重复值的插入，若多次插入同一个元素时，在该集合中只显示一个；Map以键值对的形式对元素进行存储。Map不允许有重复键，但允许有不同键对应的重复的值；2.元素的有序性：List及其所有实现类保持了每个元素的插入顺序；Set中的元素都是无序的；但是某些Set的实现类以某种殊形式对其中的元素进行排序，如：LinkedHashSet按照元素的插入顺序进行排序；Map跟Set一样对元素进行无序存储，但其某些实现类对元素进行了排序。如：TreeMap根据键对其中的元素进行升序排序；3.元素是否为空值：1.List允许任意数量的空值；2.Set最多允许一个空值的出现；当向Set集合中添加多个null值时，在该Set集合中只会显示一个null元素3.Map只允许出现一个空键，但允许出现任意数量的空值；---------------------------------总结： List中的元素:有序、可重复、可为空；Set中的元素:无序、不重复、只有一个空元素；Map中的元素:无序、键不重，值可重、可一个空键、多可空值； 53.HashMap 的长度为什么是2的幂次方12345678910111213141516171819202122232425262728293031323334353637383940414243441.减小哈希冲突概率 假如当前Entry数组长度为len，插入节点时，需要对key的hashcode进行二次哈希，然后跟len-1相与得到的值一定小于len，避免数组越界如果len是2的N次方，那么len-1的后N位二进制一定是全1假设有两个key，他们的hashcode不同，分别为code1和code2 code1和code2分别与一个后N位全1的二进制相与，结果一定也不同 但是，如果code1和code2分别与一个后N位非全1的二进制相与，结果有可能相同也就是说，如果len是2^N，不同hashcode的key计算出来的数组下标一定不同； 否则，不同hashcode的key计算出来的数组下标一定相同。所以HashMap长度为全1，可以减小哈希冲突概率。----------------------2.提高计算下标的效率 如果len的二进制后n位非全1，与len-1相与时，0与1相与需要取反。 如果len的二进制后n位全1，完全不需要取反。如果len为2^N，那么与len-1相与，跟取余len等价，而与运算效率高于取余。 如果len不是2^N，与len-1相与，跟取余len不等价。 54.集合框架中的泛型有什么优点？1234567891011121314151617181920212223242526272829首先，了解一下Java关于泛型的概念。泛型，在C++中被称为模板，就是一种抽象的编程方式。当我们定义类和方法的时候，可以用一种通用的方式进行定义，而不必写出具体的类，这些未知的东西会在真正使用的时候在确定。对于集合类来说，它们可以存放各种类型的元素。如果在存放之前，就能确定元素的类型，那么就可以更加直观，也让代码更加简洁。说明：java的泛型是停留在编译层的，也就是说JVM在对待泛型数据的时候，依然会把它们看成是Object类型，只不过在使用这些元素的时候，JVM会自动帮助我们进行相应的类型转换。总结：集合使用泛型之后，可以达到元素类型明确的目的，避免了手动类型转换的过程，同时，也让我们更加明确容器保存的是什么类型的数据。 55.我们能否使用任何类作为Map的key？12345678910111213141516171819201、可以 但是做为key的数据有如下要求：2、首先，要求明确一点Map集合存储数据的主要目的是为了查找 而List集合是为了输出3、既然是查找那么就要涉及到对象比较 我们说了如果要进行对象比较就必须覆写Object类中的equals()、hasCode() 至少覆写equals()方法 简单理解：自己定义的类如果要想实现对象比较就必须至少覆写equals()方法4、或则这么说只要是自己定义的类要想将其作为key 就必须覆写equals()方法5、实际工作中 key的类型一定是String型 (95%通用) 其余的5%是没事找事的6、按标准开发、你会感到事半功倍，不要没事给自己找事，当然求知精神是值得肯定的。 56.Map接口提供了哪些不同的集合视图？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Map接口提供了三个集合视图：1.Set keyset()：返回map中包含的所有key的一个Set视图。集合是受map支持的，map的变化会在集合中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了(除迭代器自身的移除操作以外)，迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。2.Collection values()：返回一个map中包含的所有value的一个Collection视图。这个collection受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个collection时，若map被修改了(除迭代器自身的移除操作以外)，迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。3.Set&gt; entrySet()：返回一个map钟包含的所有映射的一个集合视图。这个集合受map支持的，map的变化会在collection中反映出来，反之亦然。当一个迭代器正在遍历一个集合时，若map被修改了除迭代器自身的移除操作，以及对迭代器返回的entry进行setValue外，迭代器的结果会变为未定义。集合支持通过Iterator的Remove、Set.remove、removeAll、retainAll和clear操作进行元素移除，从map中移除对应的映射。它不支持add和addAll操作。 57.哪些集合类是线程安全的？12345678910111213141516171819202122在集合框架中，有些类是线程安全的，这些都是jdk1.1中的出现的。在jdk1.2之后，就出现许许多多非线程安全的类。下面是这些线程安全的同步的类：vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。statck：堆栈类，先进后出hashtable：就比hashmap多了个线程安全enumeration：枚举，相当于迭代器除了这些之外，其他的都是非线程安全的类和接口。线程安全的类其方法是同步的，每次只能一个访问。是重量级对象，效率较低。 58.队列和栈是什么，列出它们的区别？1234567891011121314151617181920212223242526272829303132队列（Queue）：是限定只能在表的一端进行插入和在另一端进行删除操作的线性表；栈（Stack）：是限定只能在表的一端进行插入和删除操作的线性表。区别如下：一、规则不同1. 队列：先进先出（First In First Out）FIFO2. 栈：先进后出（First In Last Out ）FILO二、对插入和删除操作的限定不同1. 队列：只能在表的一端进行插入，并在表的另一端进行删除；2. 栈：只能在表的一端插入和删除。三、遍历数据速度不同 1. 队列：基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快； 2. 栈：只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。 59.哪一个List实现了最快插入？123456789101112131415161718192021222324252627LinkedList和ArrayList是另个不同变量列表的实现。ArrayList的优势在于动态的增长数组，非常适合初始时总长度未知的情况下使用。LinkedList的优势在于在中间位置插入和删除操作，速度是最快的。LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。ArrayList实现了可变大小的数组。它允许所有元素，包括null。 每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。 60.什么时候使用ConcurrentHashMap？12345678910111213141516171819202122快速失败的Java迭代器可能会引发ConcurrentModifcationException在底层集合迭代过程中被修改。故障安全作为发生在实例中的一个副本迭代是不会抛出任何异常的。快速失败的故障安全范例定义了当遭遇故障时系统是如何反应的。例如，用于失败的快速迭代器ArrayList和用于故障安全的迭代器ConcurrentHashMap。ConcurrentHashMap被作为故障安全迭代器的一个实例，它允许完整的并发检索和更新。当有大量的并发更新时，ConcurrentHashMap此时可以被使用。这非常类似于Hashtable，但ConcurrentHashMap不锁定整个表来提供并发，所以从这点上ConcurrentHashMap的性能似乎更好一些。所以当有大量更新时ConcurrentHashMap应该被使用。]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题5]]></title>
    <url>%2F2018%2F12%2F05%2FJava%E9%9D%A2%E8%AF%95%E9%A2%985%2F</url>
    <content type="text"><![CDATA[Java面试题541.Iterator、ListIterator 和 Enumeration的区别？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。Java中的Iterator功能比较简单，并且只能单向移动：(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口被Collection继承。(2) 使用next()获得序列中的下一个元素。(3) 使用hasNext()检查序列中是否还有元素。(4) 使用remove()将迭代器新返回的元素删除。Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。-------------ListIterator的特点:它的父类接口是Iterator，名称是系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。ListIterator没有当前元素，它的光标位置始终位于调用previous()所返回的元素和调用next()所返回的元素之间。长度为n的列表的迭代器有n+1个可能的指针位置。------------------Enumeration的特点:API中是这样描述的,它主要是和Vector结合配套使用。另外此接口的功能与Iterator接口的功能是重复的，此外,Iterator接口添加了一个可选的移除操作，并且使用较短的方法名。新的实现应该优先考虑使用Iterator接口而不是Enumeration接口。-----------------------java中的集合类都提供了返回Iterator的方法，就是迭代器，它和Enumeration的主要区别其实就是Iterator可以删除元素，但是Enumration却不能。 42.Java 中 Set 与 List 有什么不同?123456789101112131415161718192021222324252627282930313233343536373839404142434445461、Set 不允许重复,List允许重复 2、Set 没有顺序，List有顺序 List接口对Collection进行了简单的扩充，它的具体实现类常用的有ArrayList和LinkedList。你可以将任何东西放到一个List容器中，并在需要时从中取出。ArrayList从其命名中可以看出它是一种类似数组的形式进行存储，因此它的随机访问速度极快，而LinkedList的内部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作。在具体应用时可以根据需要自由选择。前面说的Iterator只能对容器进行向前遍历，而ListIterator则继承了Iterator的思想，并提供了对List进行双向遍历的方法。 Set接口也是Collection的一种扩展，而与List不同的时，在Set中的对象元素不能重复，也就是说你不能把同样的东西两次放入同一个Set容器中。它的常用具体实现有HashSet和TreeSet类。HashSet能快速定位一个元素，但是你放到HashSet中的对象需要实现hashCode()方法，它使用了前面说过的哈希码的算法。而TreeSet则将放入其中的元素按序存放，这就要求你放入其中的对象是可排序的，这就用到了集合框架提供的另外两个实用类Comparable和Comparator。一个类是可排序的，它就应该实现Comparable接口。有时多个类具有相同的排序算法，那就不需要在每分别重复定义相同的排序算法，只要实现Comparator接口即可。集合框架中还有两个很实用的公用类：Collections和Arrays。Collections提供了对一个Collection容器进行诸如排序、复制、查找和填充等一些非常有用的方法，Arrays则是对一个数组进行类似的操作。 43.arraylist 与 vector 的区别?1234567891011121314151617181920212223242526272829303132333435363738394041ArrayList与Vector的区别，这主要包括两个方面：. 1.同步性：Vector是线程安全的，也就是说是它的方法之间是线程同步的，而ArrayList是线程序不安全的，它的方法之间是线程不同步的。如果只有一个线程会访问到集合，那最好是使用ArrayList，因为它不考虑线程安全，效率会高些；如果有多个线程会访问到集合，那最好是使用Vector，因为不需要我们自己再去考虑和编写线程安全的代码。备注：对于Vector&amp;ArrayList、Hashtable&amp;HashMap，要记住线程安全的问题，记住Vector与Hashtable是旧的，是java一诞生就提供了的，它们是线程安全的，ArrayList与HashMap是java2时才提供的，它们是线程不安全的。2.数据增长：ArrayList与Vector都有一个初始的容量大小，当存储进它们里面的元素的个数超过了容量时，就需要增加ArrayList与Vector的存储空间，每次要增加存储空间时，不是只增加一个存储单元，而是增加多个存储单元，每次增加的存储单元的个数在内存空间利用与程序效率之间要取得一定的平衡。Vector默认增长为原来两倍，而ArrayList的增长策略在文档中没有明确规定从源代码看到的是增长为原来的1.5倍。ArrayList与Vector都可以设置初始的空间大小，Vector还可以设置增长的空间大小，而ArrayList没有提供设置增长空间的方法。总结：即Vector增长原来的一倍，ArrayList增加原来的0.5倍。 44.什么类实现了List接口？1234567891011121314151617List接口的实现类中最经常使用最重要的就是这三个：ArrayList、Vector、LinkedList。1.三个都直接实现了AbstractList这个抽象类2,ArrayList和Vector都实现了RandomAccess接口。而LinkedList没有。这是什么意思呢？ 在JDK 中，RandomAccess接口是一个空接口，所以它没有实际意义。就是一个标记，标记这个类支持高速随机訪问，所以，arrayList和 vector是支持随机訪问的，可是LinkedList不支持持 3.serializbale接口表明他们都支持序列化。 45.什么类实现了Set接口？123456789101112131415161718192021222324252627282930HashSetLinkedHashSetTreeSetHashSet是使用哈希表（hash table）实现的，其中的元素是无序的。HashSet的add、remove、contains方法 的时间复杂度为常量O(1)。--------------------TreeSet使用树形结构算法书中的红黑树red-black tree实现的。TreeSet中的元素是可排序的，但add、remove和contains方法的时间复杂度为O(log(n))。TreeSet还提供了first()、last()、headSet()、tailSet()等方法来操作排序后的集合。-----------------------LinkedHashSet介于HashSet和TreeSet之间。它基于一个由链表实现的哈希表，保留了元素插入顺序。LinkedHashSet中基本方法的时间复杂度为O(1)。 46.如何保证一个集合线程安全？123456789101112131415161718192021222324252627282930313233343536373839Java提供了不同层面的线程安全支持。在传统集合框架内部，除了Hashtable等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），可以调用Collections工具类提供的包装方法，来获取一个同步的包装容器，例如Collections.synchronizedMap()。但是它们都是利用非常粗粒度的同步方式，在高并发情况下的性能比较低下。另外，更加普遍的选择是利用并发包（java.util.concurrent）提供的线程安全容器类：各种并发容器，比如ConcurrentHashMap、CopyOnWriteArrayList。各种线程安全队列（Queue/Deque），比如ArrayBlockingQueue、SynchronousQueue。各种有序容器的线程安全版本等。具体保证线程安全的方式，包括有从简单的synchronized方式，到基于更加精细化的，比如基于分离锁实现的ConcurrentHashMap等并发实现等。具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远远优于早期的简单同步实现。为什么需要ConcurrentHashMap首先，Hashtable本身比较低效，因为它的实现基本就是将put、get、size等方法简单粗暴地加上“synchronized”。这就导致了所有并发操作都要竞争同一把锁，一个线程在进行同步操作时，其它线程只能等待，大大降低了并发操作的性能。 47.是否可以往 TreeSet 或者 HashSet 中添加 null 元素？1234567891011121314151617181.TreeSet 是二差树实现的,Treeset中的数据是自动排好序的，不允许放入null值 2.HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束 3.HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例 48.hashCode() 和 equals() 方法的重要性？如何在Java中使用它们？1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Java中的HashMap使用hashCode()和equals()方法来确定键值对的索引，当根据键获取值的时候也会用到这两个方法。 如果没有正确的实现这两个方法，两个不同的键可能会有相同的hash值，因此可能会被集合认为是相等的。 而且，这两个方法也用来发现重复元素，所以这两个方法的实现对HashMap的精确性和正确性是至关重要的。同一个对象（没有发生过修改）无论何时调用hashCode()，得到的返回值必须一样。hashCode()返回值相等，对象不一定相等，通过hashCode()和equals()必须能唯一确定一个对象。一旦重写了equals()，就必须重写hashCode()。而且hashCode()生成哈希值的依据应该是equals()中用来比较是否相等的字段。如果两个由equals()规定相等的对象生成的hashCode不等，对于HashMap来说，他们可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入到不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题。----------------怎么判断两个对象是相同的？使用等号== 判断两个对象是否相同，这种是严格的相同，即内存中的同一个对象 Object的equal方法就是使用==判断两个对象是否相同------------集合set要求元素是唯一的，怎么实现？要实现元素的唯一，需要在往集合set中添加元素时，判断集合set是否存在相同的元素，如果存在，则不添加，反之。那么怎么确定两个元素是否相同，1.如果是使用等号==判断两个元素是否相同，即默认使用Object的equals的方法。2.如果没有使用等号==判断两个元素是否相同，而是按照某种业务规则判断两个元素是否相同，即重写了Object的equals的方法。----------------------当重写equals方法，必须重写hashCode方法吗？不是必须的，得看具体的情况当equals方法返回的结果和使用等号比较的结果是一致的时候，是没有必要重写hashCode方法。当用等号比较对象，只有是内存中同一个对象实例，才会返回true，当然调用其hashCode（）方法肯定返回相同的值，这满足了满足了hashCode的约束条件，所以不用重写hashCode（）方法。当equals方法返回的结果和使用等号比较的结果是不一致的时候，就需要重写hashCode方法。当重写后的equals方法不认为只有是在内存中同一个对象实例，才返回true，如果不重新hashCode方法（）Object的hashCode（）方法 是对内存地址的映射，hashCode方法返回的值肯定是不同的，这违背了hashCode的约束条件，所以必须要重新hashCode方法，并满足对hashCode的约束条件。 49.array 和 arraylist 的区别？123456789101112131415161718192021两者间的区别：Array 的容量是固定的，ArrayList 的容量是根据需求自动扩展ArrayList 提供了 添加、插入或移除 某一范围元素的方法而 Array 中，只能一次获取或设置一个元素值用Synchronized方法可以很容易地创建ArrayList的同步版本而 Array 将一直保持它知道用户实现同步为止 array 数组的用法type [] name = new type [size]；注意：size不能省略，type前后要一致缺点：在数据间插入数据是ArrayList 动态数组的用法是 Array 的复杂版本 动态的增加和减少元素，实现 ICollection 和 IList 接口灵活的设置数组大小 50.如何将一个字符串转换为arraylist?123456789101112131415161718192021222324string 转 ArrayList先将字符串按照某个字符切割，转为string数组然后用Arrays的asList方法，将数组转为Listpublic class test1 &#123; public static void main(String[] args) &#123; //string 转 ArrayList String str1 = &quot;a,b,c&quot;; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(str1.split(&quot;,&quot;))); System.out.println(list); &#125;&#125;ArrayList 转 stringpublic class test1 &#123;public static void main(String[] args) &#123; //ArrayList 转 stringArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); System.out.println(list);//[a, b, c] String list_str = StringUtils.join(list,&quot;,&quot;); System.out.println(list_str);//a,b,c &#125;&#125;]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate简介]]></title>
    <url>%2F2018%2F12%2F04%2Fhibernate%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[hibernate 简介hibernate是一个开源框架，它是对象关联关系映射的框架，它对JDBC做了轻量级的封装，使java程序员可以使用面向对象的思想来操纵数据库。 hibernate核心接口 session：负责被持久化对象CRUD操作 sessionFactory:负责初始化hibernate，创建session对象 configuration:负责配置并启动hibernate，创建SessionFactory Transaction:负责事物相关的操作 Query和Criteria接口：负责执行各种数据库查询hibernate工作原理： 通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件 由hibernate.cfg.xml中的读取并解析映射信息 通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory Session session = sf.openSession();//打开Sesssion Transaction tx = session.beginTransaction();//创建并启动事务Transation persistent operate操作数据，持久化操作 tx.commit();//提交事务 关闭Session 关闭SessionFactory为什么要用hibernate： 对JDBC访问数据库的代码做了封装，大大简化了数据访问层（DAO层）繁琐的重复性代码。 Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。Hibernate的查询方式HQL、Criteria,本地sql 查询HQL: 属性查询 参数查询、命名参数查询 关联查询 分页查询 统计函数如何优化Hibernate？1.使用双向一对多关联，不使用单向一对多2.灵活使用单向一对多关联3.不用一对一，用多对一取代4.配置对象缓存，不使用集合缓存5.一对多集合使用Bag,多对多集合使用Set6.继承类使用显式多态 hibernate的开发步骤：开发步骤 搭建好环境 引入hibernate最小的jar包 备Hibernate.cfg.xml启动配置文件 写实体类(pojo== entity) 为实体类写映射文件”User.hbm.xml”或者jpa 注解 在hibernate.cfg.xml添加映射的实体 创建库表 写测试类 获得Configuration 创建SessionFactory 打开Session 开启事务 使用session操作数据 提交事务 关闭资源hibernate get load 方法总结1.返回值：get()返回的是查询出来的实体对象，而load()查询出来的是一个目标实体的代理对象。 load方式检索不到的话会抛出org.hibernate.ObjectNotFoundException异常； get方法检索不到的话会返回null； 2.从检索执行机制上对比： load方法的执行则比较复杂首先查找session的persistent Context（一级缓存）中是否有缓存，如果有则直接返回，如果没有则去查找二级缓存，如果有则返回，如果没有则判断是否是lazy，若不是lazy，直接访问数据库检索，查到记录返回（并且同时在二级缓存中存放查到的数据方便下次使用，若再下次使用时在二级缓存命中，就是查到数据，则有可能将数据放到一级缓存中。），查不到抛出异常。 若是lazy，则返回代理对象，而不到数据库中查找，除非使用此对象时，才到数据库中查找。 get方法先到一级缓存，然后二级，最后db查找。 hibernate – list和iterator方法的区别1.获取方式不一样: List的获取方式为：List list = query.list(); Iterator的获取方式：Iterator it = query.iterate();2.执行sql不一样: list()会直接查询数据库。 iterator()会先到数据库中把id都取出来，然后真正要遍历某个对象的时候先到缓存中找，如果找不到，以id为条件再发一条sql到数据库，这样如果缓存中没有数据，则查询数据库的次数为n+1次。 3.list只查询一级缓存，而iterator会从二级缓存中查 4.list方法返回的对象都是实体对象，而iterator返回的是代理对象 5.session中list第二次发出，仍会到数据库査询 6.iterate 第二次，首先找session 级缓存 Hibernate的优/缺点：优点：1.更加对象化 以对象化的思维操作数据库，我们只需要操作对象就可以了，开发更加对象化。 2.移植性 因为Hibernate做了持久层的封装，你就不知道数据库，你写的所有的代码都具有可复用性。 3.Hibernate是一个没有侵入性的框架，没有侵入性的框架我们称为轻量级框架。 对比Struts的Action和ActionForm，都需要继承，离不开Struts。Hibernate不需要继承任何类，不需要实现任何接口。这样的对象叫POJO对象。 4.Hibernate代码测试方便。 5.提高效率，提高生产力。 缺点： 1.使用数据库特性的语句，将很难调优 2.对大批量数据更新存在问题 3.系统中存在大量的攻击查询功能 Hibernate openSession() 和 getCurrentSession的区别方式说明 1.采用getCurrentSession()创建的Session会绑定到当前的线程中去、而采用OpenSession()则不会。 2.采用getCurrentSession()创建的Session在commit或rollback后会自动关闭，采用OpenSession()必须手动关闭。 3.采用getCurrentSession()需要在Hibernate.cfg.xml配置文件中加入如下配置： 如果是本地事物，及JDBC一个数据库： 1&lt;propety name=”Hibernate.current_session_context_class”&gt;thread&lt;/propety&gt; 如果是全局事物，及jta事物、多个数据库资源或事物资源：1&lt;propety name=”Hibernate.current_session_context_class”&gt;jta&lt;/propety&gt; 总之: getCurrentSession () 使用当前的session openSession() 重新建立一个新的session hibernate交给spring 管理的时，则首选getCurrentSession () Hibernate的缓存机制一. 为什么要用Hibernate缓存： ​ Hibernate是一个ORM框架，会经常访问物理数据库。因此为了降低应用程序对数据库的访问频次，从而提高了应用程序的运行性能。 二. Hibernate缓存原理： ​ 1. Hibernate的一级缓存是Session的缓存，Session内置的缓存是不能被卸载的，Session的缓存是事务范围的缓存，即对应一个数据库事务或者一个应用事务的生命周期（例如买火车票这个动作，库存减一，买家加一，这就是一个事务），一级缓存中，持久化类的每个实例都具有唯一的OID，一级缓存存放的是数据库数据的拷贝。 ​ 2. Hibernate的二级缓存是SessionFactory的缓存，由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采取并发访问策略达到事务隔离。 ​ 二级缓存是可选了，默认情况下二级缓存是不会启用的。二级缓存存放元数据和预定义的SQL，且是只读的。 ​ 什么数据适合存放在二级缓存中呢？ ​ 1）很少被修改的数据 ​ 2）不太重要的数据，允许偶尔出现并发的数据 ​ 3）不会被并发访问的数据 ​ 4）常量数据 三. Hibernate缓存何时被清除： ​ 1. commit()方法被调用的时候。 ​ 2. 执行查询时会清除缓存，从而保证查询结果能反映对象的最新状态。 ​ 3. 显式调用session的flush()方法。 Hibernate中的一级缓存、二级缓存和懒加载为什么使用缓存 hibernate使用缓存减少对数据库的访问次数，从而提升hibernate的执行效率。hibernate中有两种类型的缓存：一级缓存和二级缓存。一级缓存 Hibenate中一级缓存，也叫做session的缓存，当调用session的save/saveOrUpdate/get/load/list/iterator方法的时候，都会把对象放入session的缓存中。 一级缓存可以在session范围内减少数据库的访问次数，只在session范围有效，session关闭，一级缓存失效。 session的缓存由hibernate维护， 用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作。 特点 只在当前session范围有效，作用时间短，效果不是特别明显！ 在短时间内多次操作数据库，效果比较明显！二级缓存Hibernate提供了基于应用程序级别的缓存， 可以跨多个session，即不同的session都可以访问缓存数据。 这个缓存也叫二级缓存。 Hibernate提供的二级缓存有默认的实现，且是一种可插配的缓存框架！如果用户想用二级缓存，只需要在hibernate.cfg.xml中配置即可； 不想用，直接移除，不影响代码。如果用户觉得hibernate提供的框架框架不好用，自己可以换其他的缓存框架或自己实现缓存框架。 懒加载当用到数据的时候才向数据库查询，这就是hibernate的懒加载特性。lazy 值 true 使用懒加载 false 关闭懒加载 extra 在集合数据懒加载时候提升效率，在真正使用数据的时候才向数据库发送查询的sql，如果调用集合的size()/isEmpty()方法，只是统计，不真正查询数据！ hibernate 常见的主键策略有哪些1.assigned 主键由外部程序负责生成，在 save() 之前必须指定一个。Hibernate不负责维护主键生成。与Hibernate和底层数据库都无关，可以跨数据库。在存储对象前，必须要使用主键的setter方法给主键赋值，至于这个值怎么生成，完全由自己决定，这种方法应该尽量避免 2.increment 由Hibernate从数据库中取出主键的最大值（每个session只取1次），以该值为基础，每次增量为1，在内存中生成主键，不依赖于底层的数据库，因此可以跨数据库。 3.sequence 采用数据库提供的sequence机制生成主键，需要数据库支持sequence。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence。MySQL这种不支持sequence的数据库 4.identity identity由底层数据库生成标识符。identity是由数据库自己生成的，但这个主键必须设置为自增长，使用identity的前提条件是底层数据库支持自动增长字段类型，如DB2、SQL Server、MySQL、Sybase和HypersonicSQL等，Oracle这类没有自增字段的则不支持。 5.native native由hibernate根据使用的数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式，灵活性很强。如果能支持identity则使用identity，如果支持sequence则使用sequence。6.uuid: 适用于char,varchar类型的作为主键. 谈谈Hibernate中inverse的作用inverse属性默认是false,就是说关系的两端都来维护关系。比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp)i如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。 简述cascade属性的作用1.all :对象所有操作进行级联操作2.save-update : 执行保存和更改操作时进行级联操作3.save 执行保存操作时进行级联操作。4.delete : 执行删除操作时进行级联操作5.none : 对所有操作不进行级联操作 默认。 什么是SessionFactory,她是线程安全么？sessionFactory就是一个用于创建Hibernate的Session对象的工厂。SessionFactory通常是在应用启动时创建好的，应用程序中的代码用它来获得Session对象。作为一个单个的数据存储，它也是 线程安全的，所以多个线程可同时使用同一个SessionFactory。Java JEE应用一般只有一个SessionFactory，服务于客户请求的各线程都通过这个工厂来获得Hibernate的Session实例，这也是为什么SessionFactory接口的实现必须是线程安全的原因。还有，SessionFactory的内部状态包含着同对象关系影射有关的所有元数据，它是 不可变的，一旦创建好后就不能对其进行修改了。 update（）和saveOrUpdate（）的区别 update()和saveOrUpdate()是用来对跨Session的PO(实体类)进行状态管理的。 update()方法操作的对象必须是持久化了的对象。也就是说，如果此对象在数据库中不存在的话，就不能使用update()方法。 saveOrUpdate()方法操作的对象既可以使持久化了的，也可以使没有持久化的对象。如果是持久化了的对象调用saveOrUpdate()则会 更新数据库中的对象；如果是未持久化的对象使用此方法,则save到数据库中。 hibernate拒绝连接、服务器崩溃的原因？最少写5个 db没有打开 网络连接可能出了问题 连接配置错了 驱动的driver，url是否都写对了 LIB下加入相应驱动，数据连接代码是否有误 数据库配置可能有问题 当前联接太多了，服务器都有访问人数限制的 服务器的相应端口没有开，即它不提供相应的服务 hibernate的三种状态之间如何转换当对象由瞬时状态(Transient)一save()时，就变成了持久化状态。当我们在Session里存储对象的时候，实际是在Session的Map里存了一份， 也就是它的缓存里放了一份，然后，又到数据库里存了一份，在缓存里这一份叫持久对象(Persistent)。Session 一 Close()了，它的缓存也都关闭了，整个Session也就失效了， 这个时候，这个对象变成了游离状态(Detached)，但数据库中还是存在的。当游离状态(Detached)update()时，又变为了持久状态(Persistent)。 当持久状态(Persistent)delete()时，又变为了瞬时状态(Transient), 此时，数据库中没有与之对应的记录。 Hibernate 的OpenSessionView 问题 用于解决懒加载异常, 主要功能就是把 Hibernate Session 和一个请求的线程绑定在一起, 直到页面完整输出, 这样就可以保证页面读取数据的时候 Session 一直是开启的状态, 如果去获取延迟加载对象也不会报错。 问题: 如果在业务处理阶段大批量处理数据, 有可能导致一级缓存里的对象占用内存过多导致内存溢出, 另外一个是连接问题: Session 和数据库 Connection 是绑定在一起的, 如果业务处理缓慢也会导致数据库连接得不到及时的释放, 造成连接池连接不够. 所以在并发量较大的项目中不建议使用此种方式, 可以考虑使用迫切左外连接 (LEFT OUTER JOIN FETCH) 或手工对关联的对象进行初始化. 配置 Filter 的时候要放在 Struts2 过滤器的前面, 因为它要页面完全显示完后再退出hibernate jpa 注解1.@Entity(name=”EntityName”)必须,name为可选,对应数据库中一的个表 2.@Table(name=””,catalog=””,schema=””)可选,通常和@Entity配合使用，只能标注在实体的class定义处,表示实体对应的数据库表的信息name:可选,表示表的名称。默认地，表名和实体名称一致,只有在不一致的情况下才需要指定表名catalog:可选,表示Catalog名称，默认为Catalog(“”)。schema:可选,表示Schema名称，默认为Schema(“”)。 3.@id必须@id定义了映射到数据库表的主键的属性,一个实体只能有一个属性被映射为主键.置于getXxxx()前. 4.@GeneratedValue(strategy=GenerationType,generator=””)可选strategy:表示主键生成策略,有AUTO,INDENTITY,SEQUENCE 和 TABLE 4种,分别表示让ORM框架自动选择,根据数据库的Identity字段生成,根据数据库表的Sequence字段生成,以有根据一个额外的表生成主键,默认为AUTOgenerator:表示主键生成器的名称,这个属性通常和ORM框架相关,例如,Hibernate可以指定uuid等主键生成方式.示例：12345@Id@GeneratedValues(strategy=StrategyType.SEQUENCE) public int getPk() &#123; return pk;&#125; 5.@Basic(fetch=FetchType,optional=true)可选@Basic表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的getXxxx()方法,默认即为@Basicfetch: 表示该属性的读取策略,有EAGER和LAZY两种,分别表示主支抓取和延迟加载,默认为EAGER.optional:表示该属性是否允许为null,默认为true示例:1234@Basic(optional=false)public String getAddress() &#123; return address;&#125; 6.@Column可选@Column描述了数据库表中该字段的详细定义,这对于根据JPA注解生成数据库表结构的工具非常有作用.name:表示数据库表中该字段的名称,默认情形属性名称一致nullable:表示该字段是否允许为null,默认为trueunique:表示该字段是否是唯一标识,默认为falselength:表示该字段的大小,仅对String类型的字段有效insertable:表示在ORM框架执行插入操作时,该字段是否应出现INSETRT语句中,默认为trueupdateable:表示在ORM框架执行更新操作时,该字段是否应该出现在UPDATE语句中,默认为true.对于一经创建就不可以更改的字段,该属性非常有用,如对于birthday字段.columnDefinition: 表示该字段在数据库中的实际类型.通常ORM框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是 DATE,TIME还是TIMESTAMP.此外,String的默认映射类型为VARCHAR,如果要将String类型映射到特定数据库的BLOB或 TEXT字段类型,该属性非常有用.示例:1234@Column(name=&quot;BIRTH&quot;, nullable=&quot;false&quot;, columnDefinition=&quot;DATE&quot;)public String getBithday() &#123; return birthday;&#125; 7.@Transient可选@Transient表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic示例:12345//根据birth计算出age属性@Transientpublic int getAge() &#123; return getYear(new Date()) – getYear(birth);&#125; 8.@ManyToOne(fetch=FetchType,cascade=CascadeType)可选@ManyToOne表示一个多对一的映射,该注解标注的属性通常是数据库表的外键optional:是否允许该字段为null,该属性应该根据数据库表的外键约束来确定,默认为truefetch:表示抓取策略,默认为FetchType.EAGERcascade:表示默认的级联操作策略,可以指定为ALL,PERSIST,MERGE,REFRESH和REMOVE中的若干组合,默认为无级联操作targetEntity:表示该属性关联的实体类型.该属性通常不必指定,ORM框架根据属性类型自动判断targetEntity.示例:1234567//订单Order和用户User是一个ManyToOne的关系//在Order类中定义@ManyToOne()@JoinColumn(name=”USER”)public User getUser() &#123; return user;&#125; 9.@JoinColumn可选@JoinColumn和@Column类似,介量描述的不是一个简单字段,而一一个关联字段,例如.描述一个@ManyToOne的字段.name:该字段的名称.由于@JoinColumn描述的是一个关联字段,如ManyToOne,则默认的名称由其关联的实体决定.例如,实体Order有一个user属性来关联实体User,则Order的user属性为一个外键,其默认的名称为实体User的名称+下划线+实体User的主键名称示例:见@ManyToOne@OneToMany(fetch=FetchType,cascade=CascadeType)可选10.@OneToMany描述一个一对多的关联,该属性应该为集体类型,在数据库中并没有实际字段.fetch:表示抓取策略,默认为FetchType.LAZY,因为关联的多个对象通常不必从数据库预先读取到内存cascade:表示级联操作策略,对于OneToMany类型的关联非常重要,通常该实体更新或删除时,其关联的实体也应当被更新或删除例如:实体User和Order是OneToMany的关系,则实体User被删除时,其关联的实体Order也应该被全部删除示例:1234@OneTyMany(cascade=ALL)public List getOrders() &#123; return orders;&#125; Hibernate验证注解 注解 适用类型 说明 示例 @Pattern String 通过正则表达式来验证字符串 @Pattern(regex=”[a-z]{6}”) @Length String 验证字符串的长度 @length(min=3,max=20) @Email String 验证一个Email地址是否有效 @email @Range Long 验证一个整型是否在有效的范围内 @Range(min=0,max=100) @Min Long 验证一个整型必须不小于指定值 @Min(value=10) @Max Long 验证一个整型必须不大于指定值 @Max(value=20) @Size 集合或数组 集合或数组的大小是否在指定范围内 @Size(min=1,max=255)]]></content>
      <categories>
        <category>hibernate简介</category>
      </categories>
      <tags>
        <tag>Hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HQL的连接查询]]></title>
    <url>%2F2018%2F12%2F04%2FHQL%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[HQL的连接查询HQL支持各种各样的连接查询 连接类型 HQL语法 内联结 inner join 或 join 迫切内联结 inner join fetch 或 join fetch 左外连接 left outer join 或 leftjoin 迫切左外连接 left outer join fetch 或 left join fetch 右外连接 right outer join 或 right join 聚合函数 聚合函数 说明 count() 统计记录条数 sum() 求和 max() 求最大值 min() 求最小值 avg() 求平均值 子查询语句应用在HQl查询语句的where子句中 关键字 说明 all 返回的所有记录 any 返回的任意一条数据 some 和”any”意思相同 in 与”=any”意思相同 exists 至少返回一条记录 HQL提供了操作集合的函数或属性 函数或属性 说明 size()或size 获取集合中元素的数目 minIndex()或minIndex 对于建立了索引的集合,获得最小的索引 maxIndex()或maxIndex 对于建立了索引的几个 获得最大的索引 minElement()或minElement 对于包含基本类型元素的集合 获取最小值的元素 maxElement()或maxElement 对于包含基本类型元素的集合,获取最大值的元素 elements() 获取集合中的所有元素 Hibernate查询优化的策略1.使用延迟加载等方式避免加载多余数据2.通过使用连接查询,配置二级缓存,查询缓存等方式减少select语句数目3.结合缓存机制 使用iterate()方法减少查询字段数及数据库访问次数 HQl优化1.注意避免or,not,like使用不当导致的索引失效2.注意避免having子句,distinct导致的开销3.注意避免对索引字段使用函数或进行计算导致的索引失效 ibernate提供了注解来替代hbm.xml文件完成对象-关系映射使用Hibernate注解的步骤如下:1.使用注解配置持久化类以及对象关联关系2.在Hibernate配置文件(hibernate.cfg.xml)中声明持久化类 注解含义以及作用 注解 含义和作用 @Entity 将一个类声明为一个持久化类 @Table 为持久化类映射指定表 @Id 明了持久化类的标识属性 @GeneratedValue 定义标识属性值的生成策略 @SequenceGenerator 定义序列生产器 @Column 将属性映射到列(字段) @Transient 将忽略这些属性 @OneToOne 建立持久化类之间的一对一关联关系 @OneToMany 建立持久化类之间的一对多关联关系 @ManyToOne 建立持久化类之间的多对一关联关系 @JoinColumn 和@ManyToOne配合,指定外键列 @ManyToMany 建立持久化类之间的多对多关联关系 注:下划线是几乎不用的注解 没意义]]></content>
      <categories>
        <category>HQL连接查询</category>
      </categories>
      <tags>
        <tag>HQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题4]]></title>
    <url>%2F2018%2F12%2F04%2FJava%E9%9D%A2%E8%AF%95%E9%A2%984%2F</url>
    <content type="text"><![CDATA[Java面试题431.静态变量和实例变量的区别？12345678910111213141516171819202122232425262728静态变量也叫类变量，这种变量前加了static修饰符。可以直接用类名调用，也可以用对象调用，而且所有对象的同一个类变量 都是共享同一块内存空间。实例变量也叫对象变量，这种变量没有加static修饰符。只能通过对象调用， 而且所有对象的同一个实例变量是共享不同的内存空间的。区别在于：静态变量是所有对象共有的，某一个对象将它的值改变了，其他对象再去获取它的值，得到的是改变后的值；实例变量则是每一个对象私有的，某一个对象将它的值改变了，不影响其他对象取值的结果，其他对象仍会得到实例变量一开始就被赋予的值。实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 32.垃圾回收器的基本原理是什么？123456789101112131415垃圾回收器是Java平台中用的最频繁的一种对象销毁方法。垃圾回收器会全程侦测Java应用程序的运行情况。当发现有些对象成为垃圾时，垃圾回收器就会销毁这些对象，并释放这些对象所占用的内存空间。在这里，程序开发人员需要知道，在哪些情况下垃圾回收器会认为这些对象是垃圾对象。通常情况下，如果发生以下两种情况时，系统会认为这些对象是垃圾对象，需要销毁。一是将一个NULL值赋值给对象。二是对象其超出了作用范围， 33.垃圾回收器可以马上回收内存吗？123456不会马上回收，只有在必须回收时才会回收，或者你可以调用垃圾回收方法，虚拟机会在空闲时回收，至于什么时候回收，虚拟机说了算 34.有什么办法主动通知虚拟机进行垃圾回收？12345678910111213141516171819202122232425262728293031对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。 通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是”可达的”，哪些对象是”不可达的”。当GC确定一些对象为”不可达”时，GC就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。System.gc()的工作原理Java中的内存分配是随着new一个新的对象来实现的，这个很简单，而且也还是有一些可以“改进”内存回收的机制的，其中最显眼的就是这个System.gc()函数。乍一看这个函数似乎是可以进行垃圾回收的，可事实并不是那么简单。其实这个gc()函数的作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。 35.内部类可以引用他包含类的成员吗？123456789101112131415161718192021222324252627完全可以。如果不是静态内部类，那没有什么限制！ 一个内部类对象可以访问创建它的外部类对象的成员包括私有成员。如果你把静态嵌套类当作内部类的一种特例，那在这种情况下不可以访问外部类的普通成员变量，而只能访问外部类中的静态成员。内部类的访问规则：1、内部类可以直接访问外部类中的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式 外部类名.this2、外部类要访问内部类，必须建立内部类对象。内部类定义在局部时，1、不可以被成员修饰符修饰2、可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问它所在的局部中的变量。只能访问被final修饰的局部变量。 36.Java 中的异常处理机制的简单原理和应用？123456789101112131415161718192021222324252627282930313233343536373839 一、Execption可以分为java标准定义的异常程序员自定义异常2种1.一种是当程序违反了java语规则的时候,JAVA虚拟机就会将发生的错误表示为一个异常.这里语法规则指的是JAVA类库内置的语义检查。例如 int i = 2 / 0 或者 String str = null; str.length();2.另一种情况就是JAVA允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw关键字引发异常。例如 Exception ex = new Exception(&quot;这是我自定义的异常;throw ex;所有的异常都是Thowable的子类。异常处理是与程序执行是并行的。二、异常的处理方式1.捕获异常 try &#123; int i = 2 / 0; &#125; catch (Exception ex) &#123; ex.printStackTrace(); System.out.println(&quot;异常信息：&quot; + ex.getMessage());&#125;2.上抛异常 throwspublic void test() throws Exception &#123; String str = null; str.length();&#125; 37.运行时异常与一般异常有何异同？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364(1)运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。当出现RuntimeException的时候，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。出现运行时异常后，系统会把异常一直往上层抛，一直遇到处理代码。如果没有处理块，到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被Catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。 如果不想终止，则必须扑捉所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。(2)非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如 IOException、SQLException 等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。 38.为什么Map接口不继承Collection 接口？12345678910111213141516Collection是最基本的集合接口，声明了适用于JAVA集合（只包括Set和List）的通用方法。 Set 和List 都继承了Conllection；Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection,只 是行为不同。(这是继承与多态思想的典型应用：表现不同的行为。)Set不保存重复的元素(至于如何判断元素相同则较为负责) Map没有继承于Collection接口 从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。 39.Collection 和 Map 的区别123456789101112131415容器内每个为之所存储的元素个数不同。Collection类型者，每个位置只有一个元素。Map类型者，持有 key-value pair，像个小型数据库尽管Map接口和它的实现也是集合框架的一部分，但Map不是集合，集合也不是Map。因此，Map继承Collection毫无意义，反之亦然。如果Map继承Collection接口，那么元素去哪儿？Map包含key-value对，它提供抽取key或value列表集合的方法，但是它不适合“一组对象”规范。 40.comparable 和 comparator的不同之处？1234567891011121314151617181920212223242526272829303132333435363738Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数2、比较者等于被比较者，那么返回03、比较者小于被比较者，那么返回负整数Comparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：1、o1大于o2，返回正整数2、o1等于o2，返回03、o1小于o2，返回负整数 总结12345678910111213141516171819202122232425262728两种比较器Comparable和Comparator，后者相比前者有如下优点：1、如果实现类没有实现Comparable接口，又想对两个类进行比较或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意，那么可以实现Comparator接口，自定义一个比较器，写比较算法2、实现Comparable接口的方式比实现Comparator接口的耦合性要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修 改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。实际上实现Comparator 接口的方式后面会写到就是一种典型的策略模式。当然，这不是鼓励用Comparator，意思是开发者还是要在具体场景下选择最合适的那种比较器而已。]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题3]]></title>
    <url>%2F2018%2F12%2F03%2FJava%E9%9D%A2%E8%AF%95%E9%A2%983%2F</url>
    <content type="text"><![CDATA[Java面试题321.final, finally, finalize的区别1234567891011121、final修饰符（关键字）。被final修饰的类，就意味着不能再派生出新的子类，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将变量或方法声明为final，可以保证他们在使用的过程中不被修改。被声明为final的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取。被final声明的方法也同样只能使用，即不能方法重写。 22.finally是在异常处理时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中。3、finalize是方法名。java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。 ###2.Overload和Override的区别。首先重载和重写是应用于两个不同场景下面的两种不同的手段：两者各自的特征：重载（Overload）:首先是位于一个类之中或者其子类中，具有相同的方法名，但是方法的参数不同，返回值类型可以相同也可以不同。（1）：方法名必须相同（2）：方法的参数列表一定不一样。（3）：访问修饰符和返回值类型可以相同也可以不同。其实简单而言：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。重写（override）：一般都是表示子类和父类之间的关系，其主要的特征是：方法名相同，参数相同，但是具体的实现不同。重写的特征：（1）：方法名必须相同，返回值类型必须相同（2）：参数列表必须相同（3）：访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。（4）：子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。（5）：构造方法不能被重写，简单而言：就是具体的实现类对于父类的该方法实现不满意，需要自己在写一个满足于自己要求的方法。 23. Java中的String,StringBuilder,StringBuffer三者的区别?123456789101112131415161718192021222324252627首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; StringString最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。String ----&gt; 字符串常量StringBuffer ----&gt; 字符串变量（线程安全的）StringBuilder ----&gt; 字符串变量（非线程安全的）String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 24.GC是什么? 为什么要有GC?123456789101112131415161718192021222324252627282930313233GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc()或Runtime.getRuntime().gc()，但JVM可以屏蔽掉显示的垃圾回收调用。 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。Java有了GC，就不需要程序员去人工释放内存空间。当Java虚拟机发觉内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间。当然，如果需要，程序员可以在Java程序中显式地使用System.gc()来强制进行一次立即的内存清理。 25.构造器如何工作？1234567Java在构造实例时的顺序是这样的：1、分配对象空间，并将对象中成员初始化为0或者空java不允许用户操纵一个不定值的对象。 2、执行属性值的显式初始化 3、执行构造器 4 、将变量关联到堆中的对象上 26.构造器Constructor是否可被override?1234567891011121314构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading 1). 构造器不能是native,final,static,synchronized 的,可以是public,private,或什么都没有。 2). 构造器函数里可以写return呢,但后面什么都不许有(包括null) 3). 构造器不能返回值. 但如果有个&quot;构造器&quot;返值了,它就不是构造器喽,只是个普通方法 4). super();this();这两个方法只能在构造方法里调用. 5). 成员变量声明时候赋值,比构造函数还早. 27.写一个Singleton出来。1234567891011121314151617181920212223242526272829303132333435363738Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 一般Singleton模式通常有几种种形式: 第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 public class Singleton &#123; private Singleton()&#123;&#125; //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问 public static Singleton getInstance() &#123; return instance; &#125; &#125; 第二种形式: public class Singleton &#123; private static Singleton instance = null; public static synchronized Singleton getInstance() &#123; //这个方法比上面有所改进，不用每次都进行生成对象，只是第一次 //使用时生成实例，提高了效率！ if (instance==null) instance＝new Singleton(); return instance; &#125; &#125; 其他形式: 定义一个类，它的构造函数为private的，所有方法为static的。 一般认为第一种形式要更加安全些 28.error和exception有什么区别?12345678910111213141516171819202122Error类和Exception类都继承自Throwable类。二者的不同之处：Exception：1．可以是可被控制(checked) 或不可控制的(unchecked)。2．表示一个由程序员导致的错误。3．应该在应用程序级被处理。Error：1．总是不可控制的(unchecked)。2．经常用来用于表示系统错误或低层资源的错误。3．如何可能的话，应该在系统级被捕捉。error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 29.HashMap和Hashtable的区别?12345678910111213141516hashmap:1.线程不安全2.允许有null的键和值3.效率高一点、4.方法不是Synchronize的要提供外同步5.有containsvalue和containsKey方法6.HashMap 是Java1.2 引进的Map interface 的一个实现7.HashMap是Hashtable的轻量级实现hashtable:1.线程安全2.不允许有null的键和值3.效率稍低、4.方法是是Synchronize的5.有contains方法方法6.Hashtable 继承于Dictionary 类7.Hashtable 比HashMap 要旧 30.==和equals()区别?123456789101112131415对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址对于equals方法，注意：equals方法不能作用于基本数据类型的变量如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题2]]></title>
    <url>%2F2018%2F12%2F02%2FJava%E9%9D%A2%E8%AF%95%E9%A2%982%2F</url>
    <content type="text"><![CDATA[Java面试题211.面向对象的特征有哪些方面1234567891011121314151617181920212223242526272829303132331.抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。2.继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。3.封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。4. 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 12.java 创建对象的几种方式123456采用new通过反射采用clone通过序列化机制前2者都需要显式地调用构造方法。造成耦合性最高的恰好是第一种，因此你发现无论什么框架，只要涉及到解耦必先减少new的使用。 13.修饰符public,private,protected,以及不写时的区别 修饰符 当前类 同一package 子孙类 其他package public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 123456不写时默认为friendly/defaultfriendly权限是java的默认权限，也称作包（package）访问权限只要不加private、public、protect的就是friendly访问权限，所有的成员仅限同一个包内的成员访问 14.String s = new String(“xyz”);创建了几个String Object1两个，一个字符对象，一个字符对象引用对象 15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?123Math.round(11.5)==12;Math.round(-11.5)==-11;round方法返回与参数最接近的长整数，参数加1/2后求其floor 16.Java有没有goto?1java中的保留字，现在没有在java中使用 17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型12345678910111213方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&quot;屏蔽&quot;了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型 18.abstract class和interface有什么区别123456789101112131415161718192021222324252627282930313233343536373839声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口 19.接口是否可继承接口?1234接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数 20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上1234567891011swtich（）里面必须是int和enum--即枚举类型。short、 char 或者 byte他会自动转换为int的。。long不能自动转换为int..因为long比int范围大..可能会丢失精度..在java的1.7之后的jdk版本，java中的switch里面表达式的类型可以是string类型,之前是不可以使用的]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题1]]></title>
    <url>%2F2018%2F12%2F01%2FJava%E9%9D%A2%E8%AF%95%E9%A2%981%2F</url>
    <content type="text"><![CDATA[Java面试题(1)1.简述JDK、JRE、JVM？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849一、JDK JDK(Java Development Kit) 是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 JDK是java开发工具包，基本上每个学java的人都会先在机器 上装一个JDK，那他都包含哪几部分呢？在目录下面有 六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的 是以下四个文件夹：bin、include、lib、 jre。有这样一个关系，JDK包含JRE，而JRE包 含JVM。 bin:最主要的是编译器(javac.exe) include:java和JVM交互用的头文件 lib：类库 jre:java运行环境 二、JRE JRE（Java Runtime Environment，Java运行环境）包含JVM标准实现及Java核心类库。JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器） JRE是指java运行环境。光有JVM还不能成class的 执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 （jre里有运行.class的java.exe） JRE （ Java Runtime Environment ），是运行 Java 程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的 地位就象一台PC机一样，我们写好的Win64应用程序需要操作系统帮 我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。三、JVM JVM（Java Virtual Machine），即java虚拟机, java运行时的环境，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。针对java用户，也就是拥有可运行的.class文件包（jar或者war）的用户。里面主要包含了jvm和java运行时基本类库（rt.jar）。rt.jar可以简单粗暴地理解为：它就是java源码编译成的jar包。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 2.JDK、JRE、JVM三者的有什么联系和区别？1234567891011121314151617181920212223242526272829301.三者联系：JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE。总体来说就是，我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。2.三者区别： JDK和JRE区别：在bin文件夹下会发现，JDK有javac.exe而JRE里面没有，javac指令是用来将java文件编译成class文件的，这是开发者需要的，而用户（只需要运行的人）是不需要的。JDK还有jar.exe, javadoc.exe等等用于开发的可执行指令文件。这也证实了一个是开发环境，一个是运行环境。 b.JRE和JVM区别：JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，尤其是rt.jar。 3.简述Java程序编译和运行的过程？123456Java程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode）； 2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言 1234567891011121314151617181920212223242526272829303132第一步（编译）：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报&quot;Cant found sysbol&quot;的异常错误。编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。第二步（运行）：java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！ 4.请说出八种基础数据类型及字节大小？123456781. byte 8位2. short 16位3. int 32位4. long 64位5. float 32位6. double 64位7. boolean 1位8. char 16位 5.说说&amp;和&amp;&amp;的区别？123456&amp;和&amp;&amp;都是逻辑运算符，都是判断两边同时真则为真，否则为假；但是&amp;&amp;当第一个条件不成之后，后面的条件都不执行了，而&amp;则还是继续执行，直到整个条件语句执行完为止。 6.float型float f=3.4是否正确?12345答:不正确；精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4 7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?123456short s1 = 1; s1 = s1 + 1; s1+1运算结果是int型，需要强制转换类型； short s1 = 1; s1 += 1;可以正确编译,自动类型提升。 8.int 和 Integer 有什么区别?123456789101112131415161718Java 提供两种不同的类型：引用类型和原始类型（或内置类型）；int是java的原始数据类型，Integer是java为int提供的封装类。 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。 9.在JAVA中，如何跳出当前的多重嵌套循环？12345在最外层循环前加label标识,然后用break:label方法即可跳出多重循环。ok:while(true)&#123; while(true)&#123; break ok; &#125;&#125; 10.使用嵌套的for循环打印九九乘法表。1234567891011public class test &#123;public static void main(String[] args) &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
