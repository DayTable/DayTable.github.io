<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java面试题(3)]]></title>
    <url>%2F2018%2F12%2F03%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98(3)%2F</url>
    <content type="text"><![CDATA[Java面试题(3)21.final, finally, finalize的区别1234567891011121、final修饰符（关键字）。被final修饰的类，就意味着不能再派生出新的子类，不能作为父类而被子类继承。因此一个类不能既被abstract声明，又被final声明。将变量或方法声明为final，可以保证他们在使用的过程中不被修改。被声明为final的变量必须在声明时给出变量的初始值，而在以后的引用中只能读取。被final声明的方法也同样只能使用，即不能方法重写。 22.finally是在异常处理时123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获，finally块都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生，都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，就可以放在finally块中。3、finalize是方法名。java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者被执行其他清理工作。finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。 ###2.Overload和Override的区别。首先重载和重写是应用于两个不同场景下面的两种不同的手段：两者各自的特征：重载（Overload）:首先是位于一个类之中或者其子类中，具有相同的方法名，但是方法的参数不同，返回值类型可以相同也可以不同。（1）：方法名必须相同（2）：方法的参数列表一定不一样。（3）：访问修饰符和返回值类型可以相同也可以不同。其实简单而言：重载就是对于不同的情况写不同的方法。 比如，同一个类中，写不同的构造函数用于初始化不同的参数。重写（override）：一般都是表示子类和父类之间的关系，其主要的特征是：方法名相同，参数相同，但是具体的实现不同。重写的特征：（1）：方法名必须相同，返回值类型必须相同（2）：参数列表必须相同（3）：访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。（4）：子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。（5）：构造方法不能被重写，简单而言：就是具体的实现类对于父类的该方法实现不满意，需要自己在写一个满足于自己要求的方法。 23. Java中的String,StringBuilder,StringBuffer三者的区别?123456789101112131415161718192021222324252627首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; StringString最慢的原因：String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。String ----&gt; 字符串常量StringBuffer ----&gt; 字符串变量（线程安全的）StringBuilder ----&gt; 字符串变量（非线程安全的）String：适用于少量的字符串操作的情况StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况 24.GC是什么? 为什么要有GC?123456789101112131415161718192021222324252627282930313233GC是垃圾收集的意思，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc()或Runtime.getRuntime().gc()，但JVM可以屏蔽掉显示的垃圾回收调用。 垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。Java有了GC，就不需要程序员去人工释放内存空间。当Java虚拟机发觉内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间。当然，如果需要，程序员可以在Java程序中显式地使用System.gc()来强制进行一次立即的内存清理。 25.构造器如何工作？1234567Java在构造实例时的顺序是这样的：1、分配对象空间，并将对象中成员初始化为0或者空java不允许用户操纵一个不定值的对象。 2、执行属性值的显式初始化 3、执行构造器 4 、将变量关联到堆中的对象上 26.构造器Constructor是否可被override?1234567891011121314构造器Constructor不能被继承，因此不能重写Overriding，但可以被重载Overloading 1). 构造器不能是native,final,static,synchronized 的,可以是public,private,或什么都没有。 2). 构造器函数里可以写return呢,但后面什么都不许有(包括null) 3). 构造器不能返回值. 但如果有个&quot;构造器&quot;返值了,它就不是构造器喽,只是个普通方法 4). super();this();这两个方法只能在构造方法里调用. 5). 成员变量声明时候赋值,比构造函数还早. 27.写一个Singleton出来。1234567891011121314151617181920212223242526272829303132333435363738Singleton模式主要作用是保证在Java应用程序中，一个类Class只有一个实例存在。 一般Singleton模式通常有几种种形式: 第一种形式: 定义一个类，它的构造函数为private的，它有一个static的private的该类变量，在类初始化时实例话，通过一个public的getInstance方法获取对它的引用,继而调用其中的方法。 public class Singleton &#123; private Singleton()&#123;&#125; //在自己内部定义自己一个实例，是不是很奇怪？ //注意这是private 只供内部调用 private static Singleton instance = new Singleton(); //这里提供了一个供外部访问本class的静态方法，可以直接访问 public static Singleton getInstance() &#123; return instance; &#125; &#125; 第二种形式: public class Singleton &#123; private static Singleton instance = null; public static synchronized Singleton getInstance() &#123; //这个方法比上面有所改进，不用每次都进行生成对象，只是第一次 //使用时生成实例，提高了效率！ if (instance==null) instance＝new Singleton(); return instance; &#125; &#125; 其他形式: 定义一个类，它的构造函数为private的，所有方法为static的。 一般认为第一种形式要更加安全些 28.error和exception有什么区别?12345678910111213141516171819202122Error类和Exception类都继承自Throwable类。二者的不同之处：Exception：1．可以是可被控制(checked) 或不可控制的(unchecked)。2．表示一个由程序员导致的错误。3．应该在应用程序级被处理。Error：1．总是不可控制的(unchecked)。2．经常用来用于表示系统错误或低层资源的错误。3．如何可能的话，应该在系统级被捕捉。error 表示恢复不是不可能但很困难的情况下的一种严重问题。比如说内存溢出。不可能指望程序能处理这样的情况。 exception 表示一种设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况。 29.HashMap和Hashtable的区别?12345678910111213141516hashmap:1.线程不安全2.允许有null的键和值3.效率高一点、4.方法不是Synchronize的要提供外同步5.有containsvalue和containsKey方法6.HashMap 是Java1.2 引进的Map interface 的一个实现7.HashMap是Hashtable的轻量级实现hashtable:1.线程安全2.不允许有null的键和值3.效率稍低、4.方法是是Synchronize的5.有contains方法方法6.Hashtable 继承于Dictionary 类7.Hashtable 比HashMap 要旧 30.==和equals()区别?123456789101112131415对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；如果作用于引用类型的变量，则比较的是所指向的对象的地址对于equals方法，注意：equals方法不能作用于基本数据类型的变量如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题(2)]]></title>
    <url>%2F2018%2F12%2F02%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98(2)%2F</url>
    <content type="text"><![CDATA[Java面试题(2)11.面向对象的特征有哪些方面1234567891011121314151617181920212223242526272829303132331.抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。2.继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。3.封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。4. 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 12.java 创建对象的几种方式123456采用new通过反射采用clone通过序列化机制前2者都需要显式地调用构造方法。造成耦合性最高的恰好是第一种，因此你发现无论什么框架，只要涉及到解耦必先减少new的使用。 13.修饰符public,private,protected,以及不写时的区别 修饰符 当前类 同一package 子孙类 其他package public √ √ √ √ protected √ √ √ × default √ √ × × private √ × × × 123456不写时默认为friendly/defaultfriendly权限是java的默认权限，也称作包（package）访问权限只要不加private、public、protect的就是friendly访问权限，所有的成员仅限同一个包内的成员访问 14.String s = new String(“xyz”);创建了几个String Object1两个，一个字符对象，一个字符对象引用对象 15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?123Math.round(11.5)==12;Math.round(-11.5)==-11;round方法返回与参数最接近的长整数，参数加1/2后求其floor 16.Java有没有goto?1java中的保留字，现在没有在java中使用 17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型12345678910111213方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被&quot;屏蔽&quot;了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型 18.abstract class和interface有什么区别123456789101112131415161718192021222324252627282930313233343536373839声明方法的存在而不去实现它的类被叫做抽象类（abstract class），它用于要创建一个体现某些基本行为的类，并为该类声明方法，但不能在该类中实现该类的情况。不能创建abstract 类的实例。然而可以创建一个变量，其类型是一个抽象类，并让它指向具体子类的一个实例。不能有抽象构造函数或抽象静态方法。Abstract 类的子类为它们父类中的所有抽象方法提供实现，否则它们也是抽象类为。取而代之，在子类中实现该方法。知道其行为的其它类可以在类中实现这些方法接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。多继承性可通过实现这样的接口而获得。接口中的所有方法都是抽象的，没有一个有程序体。接口只可以定义static final成员变量。接口的实现与子类相似，除了该实现类不能从接口定义中继承行为。当类实现特殊接口时，它定义（即将程序体给予）所有这种接口的方法。然后，它可以在实现了该接口的类的任何对象上调用接口的方法。由于有抽象类，它允许使用接口名作为引用变量的类型。通常的动态联编将生效。引用可以转换到接口类型或从接口类型转换，instanceof 运算符可以用来决定某对象的类是否实现了接口 19.接口是否可继承接口?1234接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实体类，但前提是实体类必须有明确的构造函数 20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上1234567891011swtich（）里面必须是int和enum--即枚举类型。short、 char 或者 byte他会自动转换为int的。。long不能自动转换为int..因为long比int范围大..可能会丢失精度..在java的1.7之后的jdk版本，java中的switch里面表达式的类型可以是string类型,之前是不可以使用的]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试题(1)]]></title>
    <url>%2F2018%2F12%2F01%2FJava%E9%9D%A2%E8%AF%95%E9%A2%98(1)%2F</url>
    <content type="text"><![CDATA[Java面试题(1)1.简述JDK、JRE、JVM？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849一、JDK JDK(Java Development Kit) 是整个JAVA的核心，包括了Java运行环境（Java Runtime Envirnment），一堆Java工具（javac/java/jdb等）和Java基础的类库（即Java API 包括rt.jar）。 JDK是java开发工具包，基本上每个学java的人都会先在机器 上装一个JDK，那他都包含哪几部分呢？在目录下面有 六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的 是以下四个文件夹：bin、include、lib、 jre。有这样一个关系，JDK包含JRE，而JRE包 含JVM。 bin:最主要的是编译器(javac.exe) include:java和JVM交互用的头文件 lib：类库 jre:java运行环境 二、JRE JRE（Java Runtime Environment，Java运行环境）包含JVM标准实现及Java核心类库。JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器） JRE是指java运行环境。光有JVM还不能成class的 执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。 （jre里有运行.class的java.exe） JRE （ Java Runtime Environment ），是运行 Java 程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的 地位就象一台PC机一样，我们写好的Win64应用程序需要操作系统帮 我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。三、JVM JVM（Java Virtual Machine），即java虚拟机, java运行时的环境，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。针对java用户，也就是拥有可运行的.class文件包（jar或者war）的用户。里面主要包含了jvm和java运行时基本类库（rt.jar）。rt.jar可以简单粗暴地理解为：它就是java源码编译成的jar包。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因。 2.JDK、JRE、JVM三者的有什么联系和区别？1234567891011121314151617181920212223242526272829301.三者联系：JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。JVM+Lib=JRE。总体来说就是，我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，JVM解析这些字节码，映射到CPU指令集或OS的系统调用。2.三者区别： JDK和JRE区别：在bin文件夹下会发现，JDK有javac.exe而JRE里面没有，javac指令是用来将java文件编译成class文件的，这是开发者需要的，而用户（只需要运行的人）是不需要的。JDK还有jar.exe, javadoc.exe等等用于开发的可执行指令文件。这也证实了一个是开发环境，一个是运行环境。 b.JRE和JVM区别：JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，尤其是rt.jar。 3.简述Java程序编译和运行的过程？12345678910111213141516171819202122232425262728293031323334353637383940Java程序从源文件创建到程序运行要经过两大步骤：1、源文件由编译器编译成字节码（ByteCode）； 2、字节码由java虚拟机解释运行。因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言![](/Java每天10道面试题第1天/1129152332.jpg)第一步（编译）：创建完源文件之后，程序先要被JVM中的java编译器进行编译为.class文件。java编译一个类时，如果这个类所依赖的类还没有被编译，编译器会自动的先编译这个所依赖的类，然后引用。如果java编译器在指定的目录下找不到该类所依赖的类的 .class文件或者 .java源文件，就会报&quot;Cant found sysbol&quot;的异常错误。编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的（常量、类名、成员变量等）以及符号引用（类引用、方法引用，成员变量引用等）；方法字节码中放的是各个方法的字节码。第二步（运行）：java类运行的过程大概分为两个步骤：（1）类的加载 （2）类的执行。需要说明的一点的是：JVM主要在程序第一次运行时主动使用类的时候，才会立即去加载。换言之，JVM并不是在运行时就会把所有使用到的类都加载到内存中，而是用到，不得不加载的时候，才加载进来，而且只加载一次！ 4.请说出八种基础数据类型及字节大小？123456781. byte 8位2. short 16位3. int 32位4. long 64位5. float 32位6. double 64位7. boolean 1位8. char 16位 5.说说&amp;和&amp;&amp;的区别？123456&amp;和&amp;&amp;都是逻辑运算符，都是判断两边同时真则为真，否则为假；但是&amp;&amp;当第一个条件不成之后，后面的条件都不执行了，而&amp;则还是继续执行，直到整个条件语句执行完为止。 6.float型float f=3.4是否正确?12345答:不正确；精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4 7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?123456short s1 = 1; s1 = s1 + 1; s1+1运算结果是int型，需要强制转换类型； short s1 = 1; s1 += 1;可以正确编译,自动类型提升。 8.int 和 Integer 有什么区别?123456789101112131415161718Java 提供两种不同的类型：引用类型和原始类型（或内置类型）；int是java的原始数据类型，Integer是java为int提供的封装类。 引用类型和原始类型的行为完全不同，并且它们具有不同的语义。引用类型和原始类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和原始类型用作某个类的实例数据时所指定的缺省值。对象引用实例变量的缺省值为 null，而原始类型实例变量的缺省值与它们的类型有关。 9.在JAVA中，如何跳出当前的多重嵌套循环？12345在最外层循环前加label标识,然后用break:label方法即可跳出多重循环。ok:while(true)&#123; while(true)&#123; break ok; &#125;&#125; 10.使用嵌套的for循环打印九九乘法表。1234567891011public class test &#123;public static void main(String[] args) &#123; for (int i = 1; i &lt;= 9; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;); &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java面试题</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
