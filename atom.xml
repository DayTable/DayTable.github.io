<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>惬意</title>
  
  <subtitle>Don&#39;t let your dreams just be dreams</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://daytable.github.io/"/>
  <updated>2018-12-07T00:44:49.897Z</updated>
  <id>https://daytable.github.io/</id>
  
  <author>
    <name>惬意</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java面试题7</title>
    <link href="https://daytable.github.io/2018/12/07/Java%E9%9D%A2%E8%AF%95%E9%A2%987/"/>
    <id>https://daytable.github.io/2018/12/07/Java面试题7/</id>
    <published>2018-12-07T00:42:37.000Z</published>
    <updated>2018-12-07T00:44:49.897Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题7"><a href="#Java面试题7" class="headerlink" title="Java面试题7"></a>Java面试题7</h3><h5 id="61-什么是并发修改异常"><a href="#61-什么是并发修改异常" class="headerlink" title="61.什么是并发修改异常?"></a>61.什么是并发修改异常?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">什么是并发修改异常：</span><br><span class="line">当我们在遍历实现了collection接口</span><br><span class="line">与iterator接口的集合时（List、Set、Map）, </span><br><span class="line">我们可以通过遍历索引</span><br><span class="line">也可以通过迭代器进行遍历。</span><br><span class="line">在我们使用迭代器进行遍历集合的时候，</span><br><span class="line">会获取到当前集合的迭代对象。</span><br><span class="line">在里面有封装了迭代器的remove方法</span><br><span class="line">与集合自带的remove方法，</span><br><span class="line">如果我们调用迭代器对象的remove方法</span><br><span class="line">是没问题的，</span><br><span class="line">但是当我们调用集合自带的remove方法时，</span><br><span class="line">就会产生ConcurrentModificationException </span><br><span class="line">并发修改异常。</span><br><span class="line">也就是说，</span><br><span class="line">当我们通过迭代器进行遍历集合的时候，</span><br><span class="line">是不允许集合本身在结构上发生变化的。</span><br></pre></td></tr></table></figure><h5 id="62-什么是CopyOnWriteArrayList，它与ArrayList有何不同？"><a href="#62-什么是CopyOnWriteArrayList，它与ArrayList有何不同？" class="headerlink" title="62.什么是CopyOnWriteArrayList，它与ArrayList有何不同？"></a>62.什么是CopyOnWriteArrayList，它与ArrayList有何不同？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList:</span><br><span class="line">CopyOnWriteArrayList这是一个</span><br><span class="line">ArrayList的线程安全的变体，</span><br><span class="line"></span><br><span class="line">其原理大概可以通俗的理解为:</span><br><span class="line">初始化的时候只有一个容器，</span><br><span class="line">很常一段时间，</span><br><span class="line">这个容器数据、</span><br><span class="line">数量等没有发生变化的时候，</span><br><span class="line">大家(多个线程)，都是读取</span><br><span class="line">假设这段时间里只发生读取的操作</span><br><span class="line">同一个容器中的数据，</span><br><span class="line"></span><br><span class="line">所以这样大家读到的数据都是</span><br><span class="line">唯一、一致、安全的，</span><br><span class="line">但是后来有人往里面增加了一个数据，</span><br><span class="line">这个时候CopyOnWriteArrayList 底层实现</span><br><span class="line">添加的原理是先copy出一个容器</span><br><span class="line">可以简称副本，</span><br><span class="line"></span><br><span class="line">再往新的容器里添加这个新的数据，</span><br><span class="line">最后把新的容器的引用地址</span><br><span class="line">赋值给了之前那个旧的的容器地址，</span><br><span class="line">但是在添加这个数据的期间，</span><br><span class="line">其他线程如果要去读取数据，</span><br><span class="line">仍然是读取到旧的容器里的数据。</span><br><span class="line"></span><br><span class="line">Vector </span><br><span class="line">ArrayList </span><br><span class="line">CopyOnWriteArrayList </span><br><span class="line">这三个集合类都继承List接口</span><br><span class="line">1、ArrayList是线程不安全的；</span><br><span class="line">2、Vector是比较古老的线程安全的，</span><br><span class="line">但性能不行；</span><br><span class="line">3、CopyOnWriteArrayList在兼顾了</span><br><span class="line">线程安全的同时，</span><br><span class="line">又提高了并发性，</span><br><span class="line">性能比Vector有不少提高</span><br></pre></td></tr></table></figure><h5 id="63-迭代器和枚举之间的区别"><a href="#63-迭代器和枚举之间的区别" class="headerlink" title="63.迭代器和枚举之间的区别?"></a>63.迭代器和枚举之间的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">在Java集合中，</span><br><span class="line">我们通常都通过 “Iterator(迭代器)” </span><br><span class="line">或 “Enumeration(枚举类)” 去遍历集合。</span><br><span class="line">Enumeration是一个接口，</span><br><span class="line">它的源码如下：</span><br><span class="line">package java.util;</span><br><span class="line">public interface Enumeration&lt;E&gt; &#123;  </span><br><span class="line">boolean hasMoreElements()</span><br><span class="line">  E nextElement();</span><br><span class="line">&#125;</span><br><span class="line">Iterator也是一个接口，</span><br><span class="line">它的源码如下:</span><br><span class="line">package java.util;</span><br><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line">  boolean hasNext(); </span><br><span class="line">  E next();  </span><br><span class="line">  void remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">区别：</span><br><span class="line">1 函数接口不同</span><br><span class="line">Enumeration只有2个函数接口。</span><br><span class="line">通过Enumeration，</span><br><span class="line">我们只能读取集合的数据，</span><br><span class="line">而不能对数据进行修改。</span><br><span class="line">Iterator只有3个函数接口。</span><br><span class="line">Iterator除了能读取集合的数据之外，</span><br><span class="line">也能数据进行删除操作。</span><br><span class="line"></span><br><span class="line">2.Iterator支持fail-fast机制，</span><br><span class="line">而Enumeration不支持。</span><br><span class="line">Enumeration 是JDK 1.0添加的接口。 </span><br><span class="line">使用到它的函数包括Vector、Hashtable等类，</span><br><span class="line">这些类都是JDK 1.0中加入的，</span><br><span class="line">Enumeration存在的目的</span><br><span class="line">就是为它们提供遍历接口。</span><br><span class="line">Enumeration本身并没有支持同步，</span><br><span class="line">而在Vector、Hashtable实现Enumeration时，</span><br><span class="line">添加了同步。</span><br><span class="line">而Iterator 是JDK 1.2才添加的接口，</span><br><span class="line">它也是为了HashMap、ArrayList等集合</span><br><span class="line">提供遍历接口。</span><br><span class="line">Iterator是支持fail-fast机制的：</span><br><span class="line">当多个线程对同一个集合的内容进行操作时，</span><br><span class="line">就可能会产生fail-fast事件。</span><br><span class="line">Java API规范建议，</span><br><span class="line">对于较新的程序，</span><br><span class="line">Iterator应优先于Enumeration，</span><br><span class="line">因为“ Iterator在Java集合框架中</span><br><span class="line">代替Enumeration。”</span><br></pre></td></tr></table></figure><h5 id="64-Hashmap如何同步"><a href="#64-Hashmap如何同步" class="headerlink" title="64.Hashmap如何同步?"></a>64.Hashmap如何同步?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1、使用 synchronized 关键字，</span><br><span class="line">这也是最原始的方法。</span><br><span class="line">synchronized(anObject)  </span><br><span class="line">&#123;  </span><br><span class="line">    value = map.get(key);  </span><br><span class="line">&#125;  </span><br><span class="line">2、使用 JDK1.5 提供的锁</span><br><span class="line">Java.util.concurrent.locks.Lock</span><br><span class="line">lock.lock();  </span><br><span class="line">value = map.get(key);  </span><br><span class="line">lock.unlock();  </span><br><span class="line">3.可以使用 JDK1.5 提供的读写锁</span><br><span class="line">java.util.concurrent.locks.ReadWriteLock</span><br><span class="line">rwlock.readLock().lock();  </span><br><span class="line">value = map.get(key);  </span><br><span class="line">rwlock.readLock().unlock();  </span><br><span class="line">4.使用 JDK1.5 提供的 </span><br><span class="line">java.util.concurrent.ConcurrentHashMap 类</span><br><span class="line">该类将 Map 的存储空间分为若干块，</span><br><span class="line">每块拥有自己的锁，</span><br><span class="line">大大减少了多个线程</span><br><span class="line">争夺同一个锁的情况</span><br><span class="line">value = map.get(key); </span><br><span class="line"></span><br><span class="line">1、不同步确实最快，与预期一致。 </span><br><span class="line">2、四种同步方式中，</span><br><span class="line">ConcurrentHashMap 是最快的，</span><br><span class="line">接近不同步的情况。 </span><br><span class="line">3、synchronized 关键字非常慢</span><br><span class="line">4、使用读写锁的读锁，比普通所稍慢。</span><br><span class="line"></span><br><span class="line">1、如果 ConcurrentHashMap 够用，</span><br><span class="line">则使用 ConcurrentHashMap。 </span><br><span class="line">2、如果需自己实现同步，</span><br><span class="line">则使用 JDK1.5 提供的锁机制，</span><br><span class="line">避免使用 synchronized 关键字。</span><br></pre></td></tr></table></figure><h5 id="65-IdentityHashMap和HashMap的区别"><a href="#65-IdentityHashMap和HashMap的区别" class="headerlink" title="65.IdentityHashMap和HashMap的区别?"></a>65.IdentityHashMap和HashMap的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">前者比较key时是</span><br><span class="line">“引用相等”</span><br><span class="line">而后者是</span><br><span class="line">“对象相等”，</span><br><span class="line">即对于</span><br><span class="line">k1和k2，当k1==k2时， </span><br><span class="line">IdentityHashMap认为两个key相等，</span><br><span class="line">而HashMap只有在k1.equals(k2) == true 时</span><br><span class="line">才会认为两个key相等。 </span><br><span class="line"></span><br><span class="line">2.IdentityHashMap </span><br><span class="line">允许使用null作为key和value. </span><br><span class="line">不保证任何Key-value对的之间的顺序, </span><br><span class="line">更不能保证他们的顺序</span><br><span class="line">随时间的推移不会发生变化。 </span><br><span class="line"></span><br><span class="line">3.IdentityHashMap有其特殊用途，</span><br><span class="line">比如序列化或者深度复制。或</span><br><span class="line">者记录对象代理。 </span><br><span class="line">举个例子，</span><br><span class="line">jvm中的所有对象都是独一无二的，</span><br><span class="line">哪怕两个对象是同一个class的对象 </span><br><span class="line">而且两个对象的数据完全相同，</span><br><span class="line">对于jvm来说，</span><br><span class="line">他们也是完全不同的， </span><br><span class="line">如果要用一个map来记录这样jvm中的对象，</span><br><span class="line">你就需要用IdentityHashMap，</span><br><span class="line">而不能使用其他Map实现</span><br></pre></td></tr></table></figure><h5 id="66-如何获取某个日期是当月的最后一天"><a href="#66-如何获取某个日期是当月的最后一天" class="headerlink" title="66.如何获取某个日期是当月的最后一天?"></a>66.如何获取某个日期是当月的最后一天?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Calendar;</span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  System.out.println(daysCount(2010, 2));</span><br><span class="line">&#125;</span><br><span class="line">public static int daysCount(int year, int month) &#123;</span><br><span class="line">  Calendar cal = Calendar.getInstance();</span><br><span class="line">  cal.set(Calendar.YEAR, year);</span><br><span class="line">  cal.set(Calendar.MONTH, month);</span><br><span class="line">  cal.set(Calendar.DATE, 0);  </span><br><span class="line">  return cal.get(Calendar.DATE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="67-java中会存在内存泄漏吗，请简单描述"><a href="#67-java中会存在内存泄漏吗，请简单描述" class="headerlink" title="67.java中会存在内存泄漏吗，请简单描述"></a>67.java中会存在内存泄漏吗，请简单描述</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">所谓内存泄露就是指</span><br><span class="line">一个不再被程序使用的对象或变量</span><br><span class="line">一直被占据在内存中。</span><br><span class="line">Java中有垃圾回收机制，</span><br><span class="line">它可以保证一对象不再被引用的时候，</span><br><span class="line">即对象编程了孤儿的时候，</span><br><span class="line">对象将自动被垃圾回收器</span><br><span class="line">从内存中清除掉。</span><br><span class="line">由于Java 使用有向图的方式</span><br><span class="line">进行垃圾回收管理，</span><br><span class="line">可以消除引用循环的问题，</span><br><span class="line">例如有两个对象，相互引用，</span><br><span class="line">只要它们和根进程不可达的，</span><br><span class="line">那么GC也是可以回收它们的。</span><br><span class="line"></span><br><span class="line">java中的内存泄露的情况：</span><br><span class="line">长生命周期的对象持有</span><br><span class="line">短生命周期对象的引用</span><br><span class="line">就很可能发生内存泄露，</span><br><span class="line">尽管短生命周期对象已经不再需要，</span><br><span class="line">但是因为长生命周期对象</span><br><span class="line">持有它的引用而导致不能被回收，</span><br><span class="line">这就是java中内存泄露的发生场景，</span><br><span class="line">通俗地说，</span><br><span class="line">就是程序员可能创建了一个对象，</span><br><span class="line">以后一直不再使用这个对象，</span><br><span class="line">这个对象却一直被引用，</span><br><span class="line">即这个对象无用</span><br><span class="line">但是却无法被垃圾回收器回收的，</span><br><span class="line">这就是java中可能出现</span><br><span class="line">内存泄露的情况，</span><br><span class="line">例如，缓存系统，</span><br><span class="line">我们加载了一个对象放在缓存中</span><br><span class="line">(例如放在一个全局map对象中)，</span><br><span class="line">然后一直不再使用它，</span><br><span class="line">这个对象一直被缓存引用，</span><br><span class="line">但却不再被使用。 </span><br><span class="line">检查java中的内存泄露，</span><br><span class="line">一定要让程序将各种分支情况</span><br><span class="line">都完整执行到程序结束，</span><br><span class="line">然后看某个对象是否被使用过，</span><br><span class="line">如果没有，</span><br><span class="line">则才能判定这个对象属于内存泄露。</span><br><span class="line"></span><br><span class="line">如果一个外部类的实例对象的方法</span><br><span class="line">返回了一个内部类的实例对象，</span><br><span class="line">这个内部类对象被长期引用了，</span><br><span class="line">即使那个外部类实例对象不再被使用，</span><br><span class="line">但由于内部类持久外部类的实例对象，</span><br><span class="line">这个外部类对象将不会被垃圾回收，</span><br><span class="line">这也会造成内存泄露。</span><br><span class="line"></span><br><span class="line">内存泄露的另外一种情况：</span><br><span class="line">当一个对象被存储进HashSet集合中以后，</span><br><span class="line">就不能修改这个对象中的</span><br><span class="line">那些参与计算哈希值的字段了，</span><br><span class="line">否则，对象修改后的哈希值</span><br><span class="line">与最初存储进HashSet集合中时的哈希值</span><br><span class="line">就不同了，</span><br><span class="line">在这种情况下，</span><br><span class="line">即使在contains方法使用该对象的</span><br><span class="line">当前引用作为的参数去HashSet集合中</span><br><span class="line">检索对象，</span><br><span class="line">也将返回找不到对象的结果，</span><br><span class="line">这也会导致无法从HashSet集合中</span><br><span class="line">单独删除当前对象，</span><br><span class="line">造成内存泄露</span><br></pre></td></tr></table></figure><h5 id="68-java中实现多态的机制是什么"><a href="#68-java中实现多态的机制是什么" class="headerlink" title="68.java中实现多态的机制是什么?"></a>68.java中实现多态的机制是什么?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">靠的是父类或接口的</span><br><span class="line">引用指向子类或实现类的对象，</span><br><span class="line">调用的方法是内存中</span><br><span class="line">正在运行的那个对象的方法。</span><br><span class="line"></span><br><span class="line">Java实现多态有三个必要条件：</span><br><span class="line">继承、</span><br><span class="line">重写、</span><br><span class="line">向上转型。</span><br><span class="line"></span><br><span class="line">继承：</span><br><span class="line">在多态中必须存在</span><br><span class="line">有继承关系的子类和父类。</span><br><span class="line"></span><br><span class="line">重写：</span><br><span class="line">子类对父类中某些方法进行重新定义，</span><br><span class="line">在调用这些方法时</span><br><span class="line">就会调用子类的方法。</span><br><span class="line"></span><br><span class="line">向上转型：</span><br><span class="line">在多态中需要将子类的引用</span><br><span class="line">赋给父类对象，</span><br><span class="line">只有这样该引用才能够具备</span><br><span class="line">技能调用父类的方法和子类的方法。</span><br><span class="line"></span><br><span class="line">只有满足了上述三个条件，</span><br><span class="line">我们才能够在同一个继承结构中</span><br><span class="line">使用统一的逻辑实现代码处理不同的对象，</span><br><span class="line">从而达到执行不同的行为。</span><br><span class="line"></span><br><span class="line">多态机制遵循的原则概括为</span><br><span class="line">当超类对象引用变量引用子类对象时，</span><br><span class="line">被引用对象的类型</span><br><span class="line">而不是引用变量的类型</span><br><span class="line">决定了调用谁的成员方法，</span><br><span class="line">但是这个被调用的方法</span><br><span class="line">必须是在超类中定义过的，</span><br><span class="line">也就是说被子类覆盖的方法，</span><br><span class="line">但是它仍然要根据继承链中</span><br><span class="line">方法调用的优先级来确认方法，</span><br><span class="line">该优先级为：</span><br><span class="line">this.method(O)、</span><br><span class="line">super.method(O)、</span><br><span class="line">this.method((super)O)、</span><br><span class="line">super.method((super)O)。</span><br></pre></td></tr></table></figure><h5 id="69-局部变量和成员变量的区别"><a href="#69-局部变量和成员变量的区别" class="headerlink" title="69.局部变量和成员变量的区别?"></a>69.局部变量和成员变量的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">成员变量与局部变量的区别</span><br><span class="line">1、在类中的位置不同</span><br><span class="line">成员变量：</span><br><span class="line">在类中方法外面</span><br><span class="line">局部变量：</span><br><span class="line">在方法或者代码块中，</span><br><span class="line">或者方法的声明上</span><br><span class="line"></span><br><span class="line">2、在内存中的位置不同，</span><br><span class="line">成员变量：在堆中（方法区中的静态区）</span><br><span class="line">局部变量：在栈中</span><br><span class="line"></span><br><span class="line">3、生命周期不同</span><br><span class="line">成员变量：</span><br><span class="line">随着对象的创建而存在，</span><br><span class="line">随着对象的消失而消失</span><br><span class="line"></span><br><span class="line">局部变量：</span><br><span class="line">随着方法的调用或者代码块的执行</span><br><span class="line">而存在，</span><br><span class="line">随着方法的调用完毕或者</span><br><span class="line">代码块的执行完毕而消失</span><br><span class="line"></span><br><span class="line">4、初始值</span><br><span class="line"></span><br><span class="line">成员变量：</span><br><span class="line">有默认初始值</span><br><span class="line"></span><br><span class="line">局部变量：</span><br><span class="line">没有默认初始值，</span><br><span class="line">使用之前需要赋值，</span><br><span class="line">否则编译器会报错</span><br></pre></td></tr></table></figure><h5 id="70-什么是匿名类-有什么好处"><a href="#70-什么是匿名类-有什么好处" class="headerlink" title="70.什么是匿名类,有什么好处?"></a>70.什么是匿名类,有什么好处?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">简单地说：</span><br><span class="line">匿名内部类就是没有名字的内部类。</span><br><span class="line"></span><br><span class="line">什么情况下需要使用匿名内部类？</span><br><span class="line">如果满足下面的一些条件，</span><br><span class="line">使用匿名内部类是比较合适的：</span><br><span class="line"> </span><br><span class="line">只用到类的一个实例。 </span><br><span class="line">类在定义后马上用到。 </span><br><span class="line">类非常小（SUN推荐是在4行代码以下） </span><br><span class="line">给类命名并不会导致你的代码更容易被理解。 </span><br><span class="line"></span><br><span class="line">在使用匿名内部类时，要记住以下几个原则： </span><br><span class="line">匿名内部类不能有构造方法。 </span><br><span class="line">匿名内部类不能定义任何静态成员、方法和类。 </span><br><span class="line">匿名内部类不能是</span><br><span class="line">public,</span><br><span class="line">protected,</span><br><span class="line">private,</span><br><span class="line">static。 </span><br><span class="line">只能创建匿名内部类的一个实例。 </span><br><span class="line">一个匿名内部类一定是在new的后面，</span><br><span class="line">用其隐含实现一个接口或实现一个类。 </span><br><span class="line">因匿名内部类为局部内部类，</span><br><span class="line">所以局部内部类的所有限制都对其生效。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题7&quot;&gt;&lt;a href=&quot;#Java面试题7&quot; class=&quot;headerlink&quot; title=&quot;Java面试题7&quot;&gt;&lt;/a&gt;Java面试题7&lt;/h3&gt;&lt;h5 id=&quot;61-什么是并发修改异常&quot;&gt;&lt;a href=&quot;#61-什么是并发修改异常&quot; cla
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题6</title>
    <link href="https://daytable.github.io/2018/12/06/Java%E9%9D%A2%E8%AF%95%E9%A2%986/"/>
    <id>https://daytable.github.io/2018/12/06/Java面试题6/</id>
    <published>2018-12-06T05:47:30.000Z</published>
    <updated>2018-12-06T05:51:36.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题6"><a href="#Java面试题6" class="headerlink" title="Java面试题6"></a>Java面试题6</h3><h5 id="51-HashMap的实现原理"><a href="#51-HashMap的实现原理" class="headerlink" title="51.HashMap的实现原理"></a>51.HashMap的实现原理</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">HashMap的主干是一个Entry数组。</span><br><span class="line">Entry是HashMap的基本组成单元，</span><br><span class="line">每一个Entry包含一个key-value键值对。</span><br><span class="line"></span><br><span class="line">HashMap基于hashing原理，</span><br><span class="line">我们通过put()和get()方法储存和获取对象。</span><br><span class="line">当我们将键值对传递给put()方法时，</span><br><span class="line">它调用键对象的hashCode()方法</span><br><span class="line">来计算hashcode，</span><br><span class="line">让后找到bucket位置来储存值对象。</span><br><span class="line">当获取对象时，</span><br><span class="line">通过键对象的equals()方法</span><br><span class="line">找到正确的键值对，</span><br><span class="line">然后返回值对象。</span><br><span class="line">HashMap使用链表来解决碰撞问题，</span><br><span class="line">当发生碰撞了，</span><br><span class="line">对象将会储存在链表的下一个节点中。</span><br><span class="line"> HashMap在每个链表节点中储存键值对对象。</span><br><span class="line"></span><br><span class="line">当两个不同的键对象的hashcode</span><br><span class="line">相同时会发生什么？ </span><br><span class="line">它们会储存在同一个bucket位置的链表中。</span><br><span class="line">键对象的equals()方法用来找到键值对。</span><br><span class="line"></span><br><span class="line">因为HashMap的好处非常多，</span><br><span class="line">我曾经在电子商务的应用中使用HashMap作为缓存。</span><br><span class="line">因为金融领域非常多的运用Java，</span><br><span class="line">也出于性能的考虑，</span><br><span class="line">我们会经常用到HashMap和ConcurrentHashMap。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap由数组+链表组成的，</span><br><span class="line">数组是HashMap的主体，</span><br><span class="line">链表则是主要为了解决哈希冲突而存在的，</span><br><span class="line">如果定位到的数组位置不含链表</span><br><span class="line">当前entry的next指向null,</span><br><span class="line">那么对于查找，</span><br><span class="line">添加等操作很快，</span><br><span class="line">仅需一次寻址即可；</span><br><span class="line">如果定位到的数组包含链表，</span><br><span class="line">对于添加操作，</span><br><span class="line">其时间复杂度为O(n)，</span><br><span class="line">首先遍历链表，</span><br><span class="line">存在即覆盖，</span><br><span class="line">否则新增；</span><br><span class="line">对于查找操作来讲，</span><br><span class="line">仍需遍历链表，</span><br><span class="line">然后通过key对象的equals方法逐一比对查找。</span><br><span class="line">所以，性能考虑，HashMap中的链表出现越少，</span><br><span class="line">性能才会越好。</span><br></pre></td></tr></table></figure><h5 id="52-List、Set、Map之间的区别"><a href="#52-List、Set、Map之间的区别" class="headerlink" title="52.List、Set、Map之间的区别"></a>52.List、Set、Map之间的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">List、Set是实现了Collection接口的子接口；</span><br><span class="line">而Map是另一个集合接口。1元素重复性：</span><br><span class="line"> List允许有重复的元素。</span><br><span class="line">任何数量的重复元素</span><br><span class="line">都可以在不影响现有重复元素的值</span><br><span class="line">及其索引的情况下插入到List集合中；</span><br><span class="line">Set集合不允许元素重复。</span><br><span class="line">Set以及所有实现了Set接口的类</span><br><span class="line">都不允许重复值的插入，</span><br><span class="line">若多次插入同一个元素时，</span><br><span class="line">在该集合中只显示一个；</span><br><span class="line">Map以键值对的形式对元素进行存储。</span><br><span class="line">Map不允许有重复键，</span><br><span class="line">但允许有不同键对应的重复的值；</span><br><span class="line">2.元素的有序性：</span><br><span class="line"></span><br><span class="line">List及其所有实现类保持了</span><br><span class="line">每个元素的插入顺序；</span><br><span class="line">Set中的元素都是无序的；</span><br><span class="line">但是某些Set的实现类</span><br><span class="line">以某种殊形式对其中的元素进行排序，</span><br><span class="line">如：LinkedHashSet按照元素的</span><br><span class="line">插入顺序进行排序；</span><br><span class="line">Map跟Set一样对元素进行无序存储，</span><br><span class="line">但其某些实现类对元素进行了排序。</span><br><span class="line">如：TreeMap根据键对其中的元素进行升序排序；</span><br><span class="line">3.元素是否为空值：</span><br><span class="line">1.List允许任意数量的空值；</span><br><span class="line">2.Set最多允许一个空值的出现；</span><br><span class="line">当向Set集合中添加多个null值时，</span><br><span class="line">在该Set集合中只会显示一个null元素</span><br><span class="line">3.Map只允许出现一个空键，</span><br><span class="line">但允许出现任意数量的空值；</span><br><span class="line">---------------------------------</span><br><span class="line">总结： </span><br><span class="line">List中的元素:</span><br><span class="line">有序、可重复、可为空；Set中的元素:</span><br><span class="line">无序、不重复、只有一个空元素；Map中的元素:</span><br><span class="line">无序、键不重，值可重、可一个空键、多可空值；</span><br></pre></td></tr></table></figure><h5 id="53-HashMap-的长度为什么是2的幂次方"><a href="#53-HashMap-的长度为什么是2的幂次方" class="headerlink" title="53.HashMap 的长度为什么是2的幂次方"></a>53.HashMap 的长度为什么是2的幂次方</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">1.减小哈希冲突概率 </span><br><span class="line">假如当前Entry数组长度为len，</span><br><span class="line">插入节点时，</span><br><span class="line">需要对key的hashcode进行二次哈希，</span><br><span class="line">然后跟len-1相与</span><br><span class="line">得到的值一定小于len，避免数组越界</span><br><span class="line"></span><br><span class="line">如果len是2的N次方，</span><br><span class="line">那么len-1的后N位二进制一定是全1</span><br><span class="line"></span><br><span class="line">假设有两个key，</span><br><span class="line">他们的hashcode不同，</span><br><span class="line">分别为code1和code2 </span><br><span class="line">code1和code2分别与一个后N位全1的二进制相与，</span><br><span class="line">结果一定也不同 </span><br><span class="line">但是，如果code1和code2分别</span><br><span class="line">与一个后N位非全1的二进制相与，</span><br><span class="line">结果有可能相同</span><br><span class="line"></span><br><span class="line">也就是说，</span><br><span class="line">如果len是2^N，</span><br><span class="line">不同hashcode的key</span><br><span class="line">计算出来的数组下标一定不同； </span><br><span class="line">否则，</span><br><span class="line">不同hashcode的key</span><br><span class="line">计算出来的数组下标一定相同。</span><br><span class="line"></span><br><span class="line">所以HashMap长度为全1，</span><br><span class="line">可以减小哈希冲突概率。</span><br><span class="line">----------------------</span><br><span class="line">2.提高计算下标的效率 </span><br><span class="line">如果len的二进制后n位非全1，</span><br><span class="line">与len-1相与时，</span><br><span class="line">0与1相与需要取反。 </span><br><span class="line">如果len的二进制后n位全1，</span><br><span class="line">完全不需要取反。</span><br><span class="line"></span><br><span class="line">如果len为2^N，</span><br><span class="line">那么与len-1相与，</span><br><span class="line">跟取余len等价，</span><br><span class="line">而与运算效率高于取余。 </span><br><span class="line">如果len不是2^N，</span><br><span class="line">与len-1相与，</span><br><span class="line">跟取余len不等价。</span><br></pre></td></tr></table></figure><h5 id="54-集合框架中的泛型有什么优点？"><a href="#54-集合框架中的泛型有什么优点？" class="headerlink" title="54.集合框架中的泛型有什么优点？"></a>54.集合框架中的泛型有什么优点？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">首先，</span><br><span class="line">了解一下Java关于泛型的概念。</span><br><span class="line">泛型，在C++中被称为模板，</span><br><span class="line">就是一种抽象的编程方式。</span><br><span class="line">当我们定义类和方法的时候，</span><br><span class="line">可以用一种通用的方式进行定义，</span><br><span class="line">而不必写出具体的类，</span><br><span class="line">这些未知的东西会在真正使用的时候在确定。</span><br><span class="line"></span><br><span class="line">对于集合类来说，</span><br><span class="line">它们可以存放各种类型的元素。</span><br><span class="line">如果在存放之前，</span><br><span class="line">就能确定元素的类型，</span><br><span class="line">那么就可以更加直观，</span><br><span class="line">也让代码更加简洁。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">java的泛型是停留在编译层的，</span><br><span class="line">也就是说JVM在对待泛型数据的时候，</span><br><span class="line">依然会把它们看成是Object类型，</span><br><span class="line">只不过在使用这些元素的时候，</span><br><span class="line">JVM会自动帮助我们进行相应的类型转换。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">集合使用泛型之后，</span><br><span class="line">可以达到元素类型明确的目的，</span><br><span class="line">避免了手动类型转换的过程，</span><br><span class="line">同时，也让我们更加明确</span><br><span class="line">容器保存的是什么类型的数据。</span><br></pre></td></tr></table></figure><h5 id="55-我们能否使用任何类作为Map的key？"><a href="#55-我们能否使用任何类作为Map的key？" class="headerlink" title="55.我们能否使用任何类作为Map的key？"></a>55.我们能否使用任何类作为Map的key？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1、可以 </span><br><span class="line">但是做为key的数据有如下要求：</span><br><span class="line">2、首先，</span><br><span class="line">要求明确一点Map集合存储数据的</span><br><span class="line">主要目的是为了查找 </span><br><span class="line">而List集合是为了输出</span><br><span class="line">3、既然是查找那么就要涉及到对象比较 </span><br><span class="line">我们说了如果要进行对象比较</span><br><span class="line">就必须覆写Object类中的equals()、hasCode() </span><br><span class="line">至少覆写equals()方法 简单理解：</span><br><span class="line">自己定义的类如果要想实现对象比较</span><br><span class="line">就必须至少覆写equals()方法</span><br><span class="line">4、或则这么说只要是自己定义的类</span><br><span class="line">要想将其作为key </span><br><span class="line">就必须覆写equals()方法</span><br><span class="line">5、实际工作中 key的类型一定是String型 </span><br><span class="line">(95%通用) 其余的5%是没事找事的</span><br><span class="line">6、按标准开发、你会感到事半功倍，</span><br><span class="line">不要没事给自己找事，</span><br><span class="line">当然求知精神是值得肯定的。</span><br></pre></td></tr></table></figure><h5 id="56-Map接口提供了哪些不同的集合视图？"><a href="#56-Map接口提供了哪些不同的集合视图？" class="headerlink" title="56.Map接口提供了哪些不同的集合视图？"></a>56.Map接口提供了哪些不同的集合视图？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Map接口提供了三个集合视图：</span><br><span class="line">1.Set keyset()：</span><br><span class="line">返回map中包含的所有key的一个Set视图。</span><br><span class="line">集合是受map支持的，</span><br><span class="line">map的变化会在集合中反映出来，</span><br><span class="line">反之亦然。</span><br><span class="line">当一个迭代器正在遍历一个集合时，</span><br><span class="line">若map被修改了(除迭代器自身的移除操作以外)，</span><br><span class="line">迭代器的结果会变为未定义。</span><br><span class="line">集合支持通过</span><br><span class="line">Iterator的Remove、Set.remove、</span><br><span class="line">removeAll、</span><br><span class="line">retainAll和clear操作进行元素移除，</span><br><span class="line">从map中移除对应的映射。</span><br><span class="line">它不支持add和addAll操作。</span><br><span class="line">2.Collection values()：</span><br><span class="line">返回一个map中包含的</span><br><span class="line">所有value的一个Collection视图。</span><br><span class="line">这个collection受map支持的，</span><br><span class="line">map的变化会在collection中反映出来，</span><br><span class="line">反之亦然。</span><br><span class="line">当一个迭代器正在遍历一个collection时，</span><br><span class="line">若map被修改了(除迭代器自身的移除操作以外)，</span><br><span class="line">迭代器的结果会变为未定义。</span><br><span class="line">集合支持通过</span><br><span class="line">Iterator的Remove、Set.remove、</span><br><span class="line">removeAll、</span><br><span class="line">retainAll和clear操作进行元素移除，</span><br><span class="line">从map中移除对应的映射。</span><br><span class="line"></span><br><span class="line">它不支持add和addAll操作。</span><br><span class="line">3.Set&gt; entrySet()：</span><br><span class="line">返回一个map钟包含的</span><br><span class="line">所有映射的一个集合视图。</span><br><span class="line">这个集合受map支持的，</span><br><span class="line">map的变化会在collection中反映出来，</span><br><span class="line">反之亦然。</span><br><span class="line">当一个迭代器正在遍历一个集合时，</span><br><span class="line">若map被修改了</span><br><span class="line">除迭代器自身的移除操作，</span><br><span class="line">以及对迭代器返回的entry进行setValue外，</span><br><span class="line">迭代器的结果会变为未定义。</span><br><span class="line">集合支持通过</span><br><span class="line">Iterator的Remove、Set.remove、</span><br><span class="line">removeAll、</span><br><span class="line">retainAll和clear操作进行元素移除，</span><br><span class="line">从map中移除对应的映射。</span><br><span class="line">它不支持add和addAll操作。</span><br></pre></td></tr></table></figure><h5 id="57-哪些集合类是线程安全的？"><a href="#57-哪些集合类是线程安全的？" class="headerlink" title="57.哪些集合类是线程安全的？"></a>57.哪些集合类是线程安全的？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">在集合框架中，有些类是线程安全的，</span><br><span class="line">这些都是jdk1.1中的出现的。</span><br><span class="line">在jdk1.2之后，</span><br><span class="line">就出现许许多多非线程安全的类。</span><br><span class="line">下面是这些线程安全的同步的类：vector：</span><br><span class="line">就比arraylist多了个同步化机制（线程安全），</span><br><span class="line">因为效率较低，</span><br><span class="line">现在已经不太建议使用。</span><br><span class="line">在web应用中，</span><br><span class="line">特别是前台页面，</span><br><span class="line">往往效率（页面响应速度）是优先考虑的。</span><br><span class="line">statck：堆栈类，先进后出</span><br><span class="line">hashtable：就比hashmap多了个线程安全</span><br><span class="line">enumeration：枚举，相当于迭代器</span><br><span class="line"></span><br><span class="line">除了这些之外，</span><br><span class="line">其他的都是非线程安全的类和接口。</span><br><span class="line"></span><br><span class="line">线程安全的类其方法是同步的，</span><br><span class="line">每次只能一个访问。</span><br><span class="line">是重量级对象，</span><br><span class="line">效率较低。</span><br></pre></td></tr></table></figure><h5 id="58-队列和栈是什么，列出它们的区别？"><a href="#58-队列和栈是什么，列出它们的区别？" class="headerlink" title="58.队列和栈是什么，列出它们的区别？"></a>58.队列和栈是什么，列出它们的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">队列（Queue）：</span><br><span class="line">是限定只能在表的一端进行</span><br><span class="line">插入和在另一端进行删除操作的线性表；</span><br><span class="line"></span><br><span class="line">栈（Stack）：</span><br><span class="line">是限定只能在表的一端</span><br><span class="line">进行插入和删除操作的线性表。</span><br><span class="line"></span><br><span class="line">区别如下：</span><br><span class="line">一、规则不同</span><br><span class="line">1. 队列：先进先出（First In First Out）FIFO</span><br><span class="line">2. 栈：先进后出（First In Last Out ）FILO</span><br><span class="line"></span><br><span class="line">二、对插入和删除操作的限定不同</span><br><span class="line">1. 队列：只能在表的一端进行插入，</span><br><span class="line">并在表的另一端进行删除；</span><br><span class="line">2. 栈：只能在表的一端插入和删除。</span><br><span class="line"></span><br><span class="line">三、遍历数据速度不同</span><br><span class="line"> 1. 队列：基于地址指针进行遍历，</span><br><span class="line">而且可以从头部或者尾部进行遍历，</span><br><span class="line">但不能同时遍历，</span><br><span class="line">无需开辟空间，</span><br><span class="line">因为在遍历的过程中不影响数据结构，</span><br><span class="line">所以遍历速度要快；</span><br><span class="line"></span><br><span class="line"> 2. 栈：只能从顶部取数据，</span><br><span class="line">也就是说最先进入栈底的，</span><br><span class="line">需要遍历整个栈才能取出来，</span><br><span class="line">而且在遍历数据的同时需要</span><br><span class="line">为数据开辟临时空间，</span><br><span class="line">保持数据在遍历前的一致性。</span><br></pre></td></tr></table></figure><h5 id="59-哪一个List实现了最快插入？"><a href="#59-哪一个List实现了最快插入？" class="headerlink" title="59.哪一个List实现了最快插入？"></a>59.哪一个List实现了最快插入？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">LinkedList和ArrayList</span><br><span class="line">是另个不同变量列表的实现。</span><br><span class="line">ArrayList的优势在于动态的增长数组，</span><br><span class="line">非常适合初始时总长度未知的情况下使用。</span><br><span class="line">LinkedList的优势在于在中间位置插入和删除操作，</span><br><span class="line">速度是最快的。</span><br><span class="line"></span><br><span class="line">LinkedList实现了List接口，</span><br><span class="line">允许null元素。</span><br><span class="line">此外LinkedList提供额外的</span><br><span class="line">get，remove，insert方法</span><br><span class="line">在LinkedList的首部或尾部。</span><br><span class="line">这些操作使LinkedList可被</span><br><span class="line">用作堆栈（stack），</span><br><span class="line">队列（queue）</span><br><span class="line">或双向队列（deque）。</span><br><span class="line"></span><br><span class="line">ArrayList实现了可变大小的数组。</span><br><span class="line">它允许所有元素，</span><br><span class="line">包括null。 </span><br><span class="line">每个ArrayList实例都有一个容量（Capacity），</span><br><span class="line">即用于存储元素的数组的大小。</span><br><span class="line">这个容量可随着不断添加新元素而自动增加，</span><br><span class="line">但是增长算法并没有定义。</span><br><span class="line">当需要插入大量元素时，</span><br><span class="line">在插入前可以调用ensureCapacity方法来</span><br><span class="line">增加ArrayList的容量以提高插入效率。</span><br></pre></td></tr></table></figure><h5 id="60-什么时候使用ConcurrentHashMap？"><a href="#60-什么时候使用ConcurrentHashMap？" class="headerlink" title="60.什么时候使用ConcurrentHashMap？"></a>60.什么时候使用ConcurrentHashMap？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">快速失败的Java迭代器</span><br><span class="line">可能会引发ConcurrentModifcationException</span><br><span class="line">在底层集合迭代过程中被修改。</span><br><span class="line">故障安全作为发生在实例中的一个副本</span><br><span class="line">迭代是不会抛出任何异常的。</span><br><span class="line">快速失败的故障安全范例定义了</span><br><span class="line">当遭遇故障时系统是如何反应的。</span><br><span class="line">例如，用于失败的快速迭代器ArrayList</span><br><span class="line">和用于故障安全的迭代器ConcurrentHashMap。</span><br><span class="line"></span><br><span class="line">ConcurrentHashMap被作为</span><br><span class="line">故障安全迭代器的一个实例，</span><br><span class="line">它允许完整的并发检索和更新。</span><br><span class="line">当有大量的并发更新时，</span><br><span class="line">ConcurrentHashMap此时可以被使用。</span><br><span class="line">这非常类似于Hashtable，</span><br><span class="line">但ConcurrentHashMap不锁定</span><br><span class="line">整个表来提供并发，</span><br><span class="line">所以从这点上ConcurrentHashMap的性能</span><br><span class="line">似乎更好一些。</span><br><span class="line">所以当有大量更新时</span><br><span class="line">ConcurrentHashMap应该被使用。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题6&quot;&gt;&lt;a href=&quot;#Java面试题6&quot; class=&quot;headerlink&quot; title=&quot;Java面试题6&quot;&gt;&lt;/a&gt;Java面试题6&lt;/h3&gt;&lt;h5 id=&quot;51-HashMap的实现原理&quot;&gt;&lt;a href=&quot;#51-HashMap的实现原
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题5</title>
    <link href="https://daytable.github.io/2018/12/05/Java%E9%9D%A2%E8%AF%95%E9%A2%985/"/>
    <id>https://daytable.github.io/2018/12/05/Java面试题5/</id>
    <published>2018-12-05T00:28:09.000Z</published>
    <updated>2018-12-05T00:30:31.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题5"><a href="#Java面试题5" class="headerlink" title="Java面试题5"></a>Java面试题5</h3><h5 id="41-Iterator、ListIterator-和-Enumeration的区别？"><a href="#41-Iterator、ListIterator-和-Enumeration的区别？" class="headerlink" title="41.Iterator、ListIterator 和 Enumeration的区别？"></a>41.Iterator、ListIterator 和 Enumeration的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">迭代器是一种设计模式，</span><br><span class="line">它是一个对象，</span><br><span class="line">它可以遍历并选择序列中的对象，</span><br><span class="line">而开发人员不需要了解</span><br><span class="line">该序列的底层结构。</span><br><span class="line">迭代器通常被称为“轻量级”对象，</span><br><span class="line">因为创建它的代价小。</span><br><span class="line">Java中的Iterator功能比较简单，</span><br><span class="line">并且只能单向移动：</span><br><span class="line">(1) 使用方法iterator()要求容器返回一个Iterator。</span><br><span class="line">第一次调用Iterator的next()方法时，</span><br><span class="line">它返回序列的第一个元素。</span><br><span class="line">注意：iterator()方法是java.lang.Iterable接口</span><br><span class="line">被Collection继承。</span><br><span class="line">(2) 使用next()获得序列中的下一个元素。</span><br><span class="line">(3) 使用hasNext()检查序列中是否还有元素。</span><br><span class="line">(4) 使用remove()将迭代器新返回的元素删除。</span><br><span class="line">Iterator是Java迭代器最简单的实现，</span><br><span class="line">为List设计的ListIterator具有更多的功能，</span><br><span class="line">它可以从两个方向遍历List，</span><br><span class="line">也可以从List中插入和删除元素。</span><br><span class="line">-------------</span><br><span class="line">ListIterator的特点:</span><br><span class="line">它的父类接口是Iterator，</span><br><span class="line">名称是系列表迭代器，</span><br><span class="line">允许程序员按任一方向遍历列表、</span><br><span class="line">迭代期间修改列表，</span><br><span class="line">并获得迭代器在列表中的当前位置。</span><br><span class="line">ListIterator没有当前元素，</span><br><span class="line">它的光标位置始终位于调用previous()</span><br><span class="line">所返回的元素和调用next()</span><br><span class="line">所返回的元素之间。</span><br><span class="line">长度为n的列表的迭代器有n+1个</span><br><span class="line">可能的指针位置。</span><br><span class="line">------------------</span><br><span class="line">Enumeration的特点:</span><br><span class="line">API中是这样描述的,</span><br><span class="line">它主要是和Vector结合配套使用。</span><br><span class="line">另外此接口的功能与Iterator接口的功能是重复的，</span><br><span class="line">此外,Iterator接口添加了</span><br><span class="line">一个可选的移除操作，</span><br><span class="line">并且使用较短的方法名。</span><br><span class="line">新的实现应该优先</span><br><span class="line">考虑使用Iterator接口</span><br><span class="line">而不是Enumeration接口。</span><br><span class="line">-----------------------</span><br><span class="line">java中的集合类都提供了</span><br><span class="line">返回Iterator的方法，</span><br><span class="line">就是迭代器，</span><br><span class="line">它和Enumeration的主要区别</span><br><span class="line">其实就是Iterator可以删除元素，</span><br><span class="line">但是Enumration却不能。</span><br></pre></td></tr></table></figure><h5 id="42-Java-中-Set-与-List-有什么不同"><a href="#42-Java-中-Set-与-List-有什么不同" class="headerlink" title="42.Java 中 Set 与 List 有什么不同?"></a>42.Java 中 Set 与 List 有什么不同?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">1、Set 不允许重复,List允许重复 </span><br><span class="line">2、Set 没有顺序，List有顺序 </span><br><span class="line"></span><br><span class="line">List接口对Collection进行了简单的扩充，</span><br><span class="line">它的具体实现类常用的有ArrayList和LinkedList。</span><br><span class="line">你可以将任何东西放到一个List容器中，</span><br><span class="line">并在需要时从中取出。</span><br><span class="line">ArrayList从其命名中可以看出</span><br><span class="line">它是一种类似数组的形式进行存储，</span><br><span class="line">因此它的随机访问速度极快，</span><br><span class="line">而LinkedList的内部实现是链表，</span><br><span class="line">它适合于在链表中间</span><br><span class="line">需要频繁进行插入和删除操作。</span><br><span class="line">在具体应用时可以根据需要自由选择。</span><br><span class="line">前面说的Iterator只能对容器进行向前遍历，</span><br><span class="line">而ListIterator则继承了Iterator的思想，</span><br><span class="line">并提供了对List进行双向遍历的方法。 </span><br><span class="line"></span><br><span class="line">Set接口也是Collection的一种扩展，</span><br><span class="line">而与List不同的时，</span><br><span class="line">在Set中的对象元素不能重复，</span><br><span class="line">也就是说你不能把同样的东西</span><br><span class="line">两次放入同一个Set容器中。</span><br><span class="line">它的常用具体实现有HashSet和TreeSet类。</span><br><span class="line">HashSet能快速定位一个元素，</span><br><span class="line">但是你放到HashSet中的对象</span><br><span class="line">需要实现hashCode()方法，</span><br><span class="line">它使用了前面说过的哈希码的算法。</span><br><span class="line">而TreeSet则将放入</span><br><span class="line">其中的元素按序存放，</span><br><span class="line">这就要求你放入</span><br><span class="line">其中的对象是可排序的，</span><br><span class="line">这就用到了集合框架提供的</span><br><span class="line">另外两个实用类Comparable和Comparator。</span><br><span class="line">一个类是可排序的，</span><br><span class="line">它就应该实现Comparable接口。</span><br><span class="line">有时多个类具有相同的排序算法，</span><br><span class="line">那就不需要在每分别重复定义</span><br><span class="line">相同的排序算法，</span><br><span class="line">只要实现Comparator接口即可。</span><br><span class="line">集合框架中还有两个很实用的公用类：</span><br><span class="line">Collections和Arrays。</span><br><span class="line">Collections提供了对一个Collection容器</span><br><span class="line">进行诸如排序、复制、查找和填充等</span><br><span class="line">一些非常有用的方法，</span><br><span class="line">Arrays则是对一个数组进行类似的操作。</span><br></pre></td></tr></table></figure><h5 id="43-arraylist-与-vector-的区别"><a href="#43-arraylist-与-vector-的区别" class="headerlink" title="43.arraylist 与 vector 的区别?"></a>43.arraylist 与 vector 的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">ArrayList与Vector的区别，</span><br><span class="line">这主要包括两个方面：. </span><br><span class="line">1.同步性：Vector是线程安全的，</span><br><span class="line">也就是说是它的方法之间是线程同步的，</span><br><span class="line">而ArrayList是线程序不安全的，</span><br><span class="line">它的方法之间是线程不同步的。</span><br><span class="line">如果只有一个线程会访问到集合，</span><br><span class="line">那最好是使用ArrayList，</span><br><span class="line">因为它不考虑线程安全，</span><br><span class="line">效率会高些；</span><br><span class="line">如果有多个线程会访问到集合，</span><br><span class="line">那最好是使用Vector，</span><br><span class="line">因为不需要我们自己</span><br><span class="line">再去考虑和编写线程安全的代码。</span><br><span class="line"></span><br><span class="line">备注：</span><br><span class="line">对于Vector&amp;ArrayList、Hashtable&amp;HashMap，</span><br><span class="line">要记住线程安全的问题，</span><br><span class="line">记住Vector与Hashtable是旧的，</span><br><span class="line">是java一诞生就提供了的，</span><br><span class="line">它们是线程安全的，ArrayList与HashMap是java2时才提供的，</span><br><span class="line">它们是线程不安全的。</span><br><span class="line"></span><br><span class="line">2.数据增长：ArrayList与Vector都有一个初始的容量大小，</span><br><span class="line">当存储进它们里面的元素的个数超过了容量时，</span><br><span class="line">就需要增加ArrayList与Vector的存储空间，</span><br><span class="line">每次要增加存储空间时，</span><br><span class="line">不是只增加一个存储单元，</span><br><span class="line">而是增加多个存储单元，</span><br><span class="line">每次增加的存储单元的个数</span><br><span class="line">在内存空间利用与程序效率之间</span><br><span class="line">要取得一定的平衡。Vector默认增长为原来两倍，</span><br><span class="line">而ArrayList的增长策略</span><br><span class="line">在文档中没有明确规定</span><br><span class="line">从源代码看到的是增长为原来的1.5倍。</span><br><span class="line">ArrayList与Vector都可以设置初始的空间大小</span><br><span class="line">，Vector还可以设置增长的空间大小，</span><br><span class="line">而ArrayList没有提供</span><br><span class="line">设置增长空间的方法。</span><br><span class="line">总结：</span><br><span class="line">即Vector增长原来的一倍，ArrayList增加原来的0.5倍。</span><br></pre></td></tr></table></figure><h5 id="44-什么类实现了List接口？"><a href="#44-什么类实现了List接口？" class="headerlink" title="44.什么类实现了List接口？"></a>44.什么类实现了List接口？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List接口的实现类中</span><br><span class="line">最经常使用最重要的就是这三个：</span><br><span class="line">ArrayList、</span><br><span class="line">Vector、</span><br><span class="line">LinkedList。</span><br><span class="line">1.三个都直接实现了AbstractList这个抽象类</span><br><span class="line">2,ArrayList和Vector都实现了</span><br><span class="line">RandomAccess接口。</span><br><span class="line">而LinkedList没有。</span><br><span class="line">这是什么意思呢？              </span><br><span class="line">在JDK 中，</span><br><span class="line">RandomAccess接口是一个空接口，</span><br><span class="line">所以它没有实际意义。就是一个标记，</span><br><span class="line">标记这个类支持高速随机訪问，</span><br><span class="line">所以，arrayList和 vector是支持随机訪问的，</span><br><span class="line">可是LinkedList不支持持         </span><br><span class="line">3.serializbale接口表明他们都支持序列化。</span><br></pre></td></tr></table></figure><h5 id="45-什么类实现了Set接口？"><a href="#45-什么类实现了Set接口？" class="headerlink" title="45.什么类实现了Set接口？"></a>45.什么类实现了Set接口？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">HashSet</span><br><span class="line">LinkedHashSet</span><br><span class="line">TreeSet</span><br><span class="line"></span><br><span class="line">HashSet是使用哈希表（hash table）实现的，</span><br><span class="line">其中的元素是无序的。</span><br><span class="line">HashSet的</span><br><span class="line">add、</span><br><span class="line">remove、</span><br><span class="line">contains方法 </span><br><span class="line">的时间复杂度为常量O(1)。</span><br><span class="line">--------------------</span><br><span class="line">TreeSet使用树形结构</span><br><span class="line">算法书中的红黑树red-black tree</span><br><span class="line">实现的。</span><br><span class="line">TreeSet中的元素是可排序的，</span><br><span class="line">但add、remove和contains方法的时间</span><br><span class="line">复杂度为O(log(n))。</span><br><span class="line">TreeSet还提供了</span><br><span class="line">first()、</span><br><span class="line">last()、</span><br><span class="line">headSet()、</span><br><span class="line">tailSet()等</span><br><span class="line">方法来操作排序后的集合。</span><br><span class="line">-----------------------</span><br><span class="line">LinkedHashSet介于HashSet和TreeSet之间。</span><br><span class="line">它基于一个由链表实现的哈希表，</span><br><span class="line">保留了元素插入顺序。</span><br><span class="line">LinkedHashSet中基本方法的</span><br><span class="line">时间复杂度为O(1)。</span><br></pre></td></tr></table></figure><h5 id="46-如何保证一个集合线程安全？"><a href="#46-如何保证一个集合线程安全？" class="headerlink" title="46.如何保证一个集合线程安全？"></a>46.如何保证一个集合线程安全？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Java提供了不同层面的线程安全支持。</span><br><span class="line">在传统集合框架内部，</span><br><span class="line">除了Hashtable等同步容器，</span><br><span class="line">还提供了所谓的同步包装器</span><br><span class="line">（Synchronized Wrapper），</span><br><span class="line">可以调用Collections工具类提供的包装方法，</span><br><span class="line">来获取一个同步的包装容器，</span><br><span class="line">例如Collections.synchronizedMap()。</span><br><span class="line">但是它们都是利用非常粗粒度的同步方式，</span><br><span class="line">在高并发情况下的性能比较低下。</span><br><span class="line">另外，更加普遍的选择是利用并发包</span><br><span class="line">（java.util.concurrent）</span><br><span class="line">提供的线程安全容器类：</span><br><span class="line">各种并发容器，</span><br><span class="line">比如ConcurrentHashMap、</span><br><span class="line">CopyOnWriteArrayList。</span><br><span class="line">各种线程安全队列（Queue/Deque），</span><br><span class="line">比如ArrayBlockingQueue、</span><br><span class="line">SynchronousQueue。</span><br><span class="line">各种有序容器的线程安全版本等。</span><br><span class="line">具体保证线程安全的方式，</span><br><span class="line">包括有从简单的synchronized方式，</span><br><span class="line">到基于更加精细化的，</span><br><span class="line">比如基于分离锁实现的</span><br><span class="line">ConcurrentHashMap等并发实现等。</span><br><span class="line">具体选择要看开发的场景需求，</span><br><span class="line">总体来说，</span><br><span class="line">并发包内提供的容器通用场景，</span><br><span class="line">远远优于早期的简单同步实现。</span><br><span class="line"></span><br><span class="line">为什么需要ConcurrentHashMap</span><br><span class="line">首先，Hashtable本身比较低效，</span><br><span class="line">因为它的实现基本就是</span><br><span class="line">将put、get、size等方法</span><br><span class="line">简单粗暴地加上“synchronized”。</span><br><span class="line">这就导致了所有并发操作都要竞争同一把锁，</span><br><span class="line">一个线程在进行同步操作时，</span><br><span class="line">其它线程只能等待，</span><br><span class="line">大大降低了并发操作的性能。</span><br></pre></td></tr></table></figure><h5 id="47-是否可以往-TreeSet-或者-HashSet-中添加-null-元素？"><a href="#47-是否可以往-TreeSet-或者-HashSet-中添加-null-元素？" class="headerlink" title="47.是否可以往 TreeSet 或者 HashSet 中添加 null 元素？"></a>47.是否可以往 TreeSet 或者 HashSet 中添加 null 元素？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.TreeSet 是二差树实现的,</span><br><span class="line">Treeset中的数据是自动排好序的，</span><br><span class="line">不允许放入null值 </span><br><span class="line"></span><br><span class="line">2.HashSet 是哈希表实现的,</span><br><span class="line">HashSet中的数据是无序的，</span><br><span class="line">可以放入null，</span><br><span class="line">但只能放入一个null，</span><br><span class="line">两者中的值都不能重复，</span><br><span class="line">就如数据库中唯一约束 </span><br><span class="line"></span><br><span class="line">3.HashSet要求放入的对象</span><br><span class="line">必须实现HashCode()方法，</span><br><span class="line">放入的对象，是以hashcode码作为标识的，</span><br><span class="line">而具有相同内容的String对象，</span><br><span class="line">hashcode是一样，</span><br><span class="line">所以放入的内容不能重复。</span><br><span class="line">但是同一个类的对象可以放入不同的实例</span><br></pre></td></tr></table></figure><h5 id="48-hashCode-和-equals-方法的重要性？如何在Java中使用它们？"><a href="#48-hashCode-和-equals-方法的重要性？如何在Java中使用它们？" class="headerlink" title="48.hashCode() 和 equals() 方法的重要性？如何在Java中使用它们？"></a>48.hashCode() 和 equals() 方法的重要性？如何在Java中使用它们？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">Java中的HashMap使用</span><br><span class="line">hashCode()和equals()方法</span><br><span class="line">来确定键值对的索引，</span><br><span class="line">当根据键获取值的时候</span><br><span class="line">也会用到这两个方法。 </span><br><span class="line">如果没有正确的实现这两个方法，</span><br><span class="line">两个不同的键可能会有相同的hash值，</span><br><span class="line">因此可能会被集合认为是相等的。 </span><br><span class="line">而且，这两个方法也用来发现重复元素，</span><br><span class="line">所以这两个方法的实现对HashMap的</span><br><span class="line">精确性和正确性是至关重要的。</span><br><span class="line"></span><br><span class="line">同一个对象（没有发生过修改）</span><br><span class="line">无论何时调用hashCode()，</span><br><span class="line">得到的返回值必须一样。</span><br><span class="line">hashCode()返回值相等，</span><br><span class="line">对象不一定相等，</span><br><span class="line">通过hashCode()和equals()</span><br><span class="line">必须能唯一确定一个对象。</span><br><span class="line">一旦重写了equals()，</span><br><span class="line">就必须重写hashCode()。</span><br><span class="line">而且hashCode()生成哈希值的依据应该是</span><br><span class="line">equals()中用来比较是否相等的字段。</span><br><span class="line">如果两个由equals()规定相等的对象</span><br><span class="line">生成的hashCode不等，</span><br><span class="line">对于HashMap来说，</span><br><span class="line">他们可能分别映射到不同位置，</span><br><span class="line">没有调用equals()比较是否相等的机会，</span><br><span class="line">两个实际上相等的对象可能被插入到不同位置，</span><br><span class="line">出现错误。</span><br><span class="line">其他一些基于哈希方法的集合类</span><br><span class="line">可能也会有这个问题。</span><br><span class="line">----------------</span><br><span class="line">怎么判断两个对象是相同的？</span><br><span class="line">使用等号== 判断两个对象是否相同，</span><br><span class="line">这种是严格的相同，</span><br><span class="line">即内存中的同一个对象</span><br><span class="line"> Object的equal方法就是使用==判断两个对象是否相同</span><br><span class="line">------------</span><br><span class="line">集合set要求元素是唯一的，怎么实现？</span><br><span class="line">要实现元素的唯一，</span><br><span class="line">需要在往集合set中添加元素时，</span><br><span class="line">判断集合set是否存在相同的元素，</span><br><span class="line">如果存在，则不添加，反之。</span><br><span class="line">那么怎么确定两个元素是否相同，</span><br><span class="line">1.如果是使用等号==判断两个元素是否相同，</span><br><span class="line">即默认使用Object的equals的方法。</span><br><span class="line">2.如果没有使用等号==判断两个元素是否相同，</span><br><span class="line">而是按照某种业务规则判断两个元素是否相同，</span><br><span class="line">即重写了Object的equals的方法。</span><br><span class="line">----------------------</span><br><span class="line">当重写equals方法，必须重写hashCode方法吗？</span><br><span class="line">不是必须的，</span><br><span class="line">得看具体的情况</span><br><span class="line">当equals方法返回的结果和使用等号</span><br><span class="line">比较的结果是一致的时候，</span><br><span class="line">是没有必要重写hashCode方法。</span><br><span class="line">当用等号比较对象，</span><br><span class="line">只有是内存中同一个对象实例，</span><br><span class="line">才会返回true，</span><br><span class="line">当然调用其hashCode（）方法</span><br><span class="line">肯定返回相同的值，</span><br><span class="line">这满足了满足了hashCode的约束条件，</span><br><span class="line">所以不用重写hashCode（）方法。</span><br><span class="line"></span><br><span class="line">当equals方法返回的结果</span><br><span class="line">和使用等号比较的结果是不一致的时候，</span><br><span class="line">就需要重写hashCode方法。</span><br><span class="line">当重写后的equals方法</span><br><span class="line">不认为只有是在内存中同一个对象实例，</span><br><span class="line">才返回true，</span><br><span class="line">如果不重新hashCode方法（）</span><br><span class="line">Object的hashCode（）方法 是对内存地址的映射，</span><br><span class="line">hashCode方法返回的值肯定是不同的，</span><br><span class="line">这违背了hashCode的约束条件，</span><br><span class="line">所以必须要重新hashCode方法，</span><br><span class="line">并满足对hashCode的约束条件。</span><br></pre></td></tr></table></figure><h5 id="49-array-和-arraylist-的区别？"><a href="#49-array-和-arraylist-的区别？" class="headerlink" title="49.array 和 arraylist 的区别？"></a>49.array 和 arraylist 的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">两者间的区别：Array 的容量是固定的，</span><br><span class="line">ArrayList 的容量是根据需求自动扩展</span><br><span class="line">ArrayList 提供了 添加、插入或移除</span><br><span class="line"> 某一范围元素的方法</span><br><span class="line">而 Array 中，</span><br><span class="line">只能一次获取或设置一个元素值</span><br><span class="line">用Synchronized方法可以</span><br><span class="line">很容易地创建ArrayList的同步版本</span><br><span class="line">而 Array 将一直保持</span><br><span class="line">它知道用户实现同步为止 </span><br><span class="line">array 数组的用法</span><br><span class="line">type [] name = new type [size]；</span><br><span class="line">注意：size不能省略，type前后要一致</span><br><span class="line">缺点：在数据间插入数据是</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ArrayList 动态数组的用法</span><br><span class="line">是 Array 的复杂版本</span><br><span class="line"> 动态的增加和减少元素，</span><br><span class="line">实现 ICollection 和 IList 接口</span><br><span class="line">灵活的设置数组大小</span><br></pre></td></tr></table></figure><h5 id="50-如何将一个字符串转换为arraylist"><a href="#50-如何将一个字符串转换为arraylist" class="headerlink" title="50.如何将一个字符串转换为arraylist?"></a>50.如何将一个字符串转换为arraylist?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string 转 ArrayList</span><br><span class="line">先将字符串按照某个字符切割，转为string数组</span><br><span class="line">然后用Arrays的asList方法，将数组转为Listpublic class test1 &#123;</span><br><span class="line">    public static void main(String[] args)  &#123;        //string 转 ArrayList</span><br><span class="line">        String str1 = &quot;a,b,c&quot;;</span><br><span class="line">        ArrayList&lt;String&gt; list = </span><br><span class="line">        new ArrayList&lt;String&gt;(Arrays.asList(str1.split(&quot;,&quot;)));</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ArrayList 转 stringpublic class test1 &#123;public static void main(String[] args)  &#123;  </span><br><span class="line"> //ArrayList 转 stringArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();       </span><br><span class="line">      list.add(&quot;a&quot;);       </span><br><span class="line">      list.add(&quot;b&quot;);     </span><br><span class="line">      list.add(&quot;c&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(list);//[a, b, c]</span><br><span class="line">    </span><br><span class="line">        String list_str = StringUtils.join(list,&quot;,&quot;);</span><br><span class="line">    </span><br><span class="line">        System.out.println(list_str);//a,b,c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题5&quot;&gt;&lt;a href=&quot;#Java面试题5&quot; class=&quot;headerlink&quot; title=&quot;Java面试题5&quot;&gt;&lt;/a&gt;Java面试题5&lt;/h3&gt;&lt;h5 id=&quot;41-Iterator、ListIterator-和-Enumeration的区别
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>hibernate简介</title>
    <link href="https://daytable.github.io/2018/12/04/hibernate%E7%AE%80%E4%BB%8B/"/>
    <id>https://daytable.github.io/2018/12/04/hibernate简介/</id>
    <published>2018-12-04T05:29:18.000Z</published>
    <updated>2018-12-04T05:43:44.217Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hibernate-简介"><a href="#hibernate-简介" class="headerlink" title="hibernate 简介"></a>hibernate 简介</h2><p>hibernate是一个开源框架，它是对象关联关系映射的框架，它对JDBC做了轻量级的封装，使java程序员可以使用面向对象的思想来操纵数据库。</p><p>hibernate核心接口</p><ul><li>session：负责被持久化对象CRUD操作</li><li>sessionFactory:负责初始化hibernate，创建session对象</li><li>configuration:负责配置并启动hibernate，创建SessionFactory</li><li>Transaction:负责事物相关的操作</li><li>Query和Criteria接口：负责执行各种数据库查询<h2 id="hibernate工作原理："><a href="#hibernate工作原理：" class="headerlink" title="hibernate工作原理："></a>hibernate工作原理：</h2></li></ul><ol><li>通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件</li><li>由hibernate.cfg.xml中的<mapping resource="com/xx/User.hbm.xml">读取并解析映射信息</mapping></li><li>通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory</li><li>Session session = sf.openSession();//打开Sesssion</li><li>Transaction tx = session.beginTransaction();//创建并启动事务Transation</li><li>persistent operate操作数据，持久化操作</li><li>tx.commit();//提交事务</li><li>关闭Session</li><li>关闭SessionFactory<h2 id="为什么要用hibernate："><a href="#为什么要用hibernate：" class="headerlink" title="为什么要用hibernate："></a>为什么要用hibernate：</h2></li><li>对JDBC访问数据库的代码做了封装，大大简化了数据访问层（DAO层）繁琐的重复性代码。</li><li>Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作</li><li>hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。</li><li>hibernate映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。<h2 id="Hibernate的查询方式"><a href="#Hibernate的查询方式" class="headerlink" title="Hibernate的查询方式"></a>Hibernate的查询方式</h2>HQL、Criteria,本地sql 查询<br><strong>HQL:</strong> </li><li>属性查询</li><li>参数查询、命名参数查询</li><li>关联查询</li><li>分页查询</li><li>统计函数<h2 id="如何优化Hibernate？"><a href="#如何优化Hibernate？" class="headerlink" title="如何优化Hibernate？"></a>如何优化Hibernate？</h2>1.使用双向一对多关联，不使用单向一对多<br>2.灵活使用单向一对多关联<br>3.不用一对一，用多对一取代<br>4.配置对象缓存，不使用集合缓存<br>5.一对多集合使用Bag,多对多集合使用Set<br>6.继承类使用显式多态</li></ol><h2 id="hibernate的开发步骤："><a href="#hibernate的开发步骤：" class="headerlink" title="hibernate的开发步骤："></a>hibernate的开发步骤：</h2><p>开发步骤</p><ol><li><p>搭建好环境</p><ul><li>引入hibernate最小的jar包</li><li>备Hibernate.cfg.xml启动配置文件</li></ul></li><li><p>写实体类(pojo== entity)</p></li><li><p>为实体类写映射文件”User.hbm.xml”或者jpa 注解</p><ul><li>在hibernate.cfg.xml添加映射的实体</li></ul></li><li><p>创建库表</p></li><li><p>写测试类</p><ul><li>获得Configuration</li><li>创建SessionFactory</li><li>打开Session</li><li>开启事务</li><li>使用session操作数据</li><li>提交事务</li><li>关闭资源<h2 id="hibernate-get-load-方法总结"><a href="#hibernate-get-load-方法总结" class="headerlink" title="hibernate get load 方法总结"></a>hibernate get load 方法总结</h2><strong>1.返回值：</strong><br>get()返回的是查询出来的实体对象，而load()查询出来的是一个目标实体的代理对象。</li></ul></li></ol><p>load方式检索不到的话会抛出org.hibernate.ObjectNotFoundException异常；</p><p>get方法检索不到的话会返回null； </p><p><strong>2.从检索执行机制上对比：</strong></p><p>load方法的执行则比较复杂首先查找session的persistent Context（一级缓存）中是否有缓存，如果有则直接返回，如果没有则去查找二级缓存，如果有则返回，如果没有则判断是否是lazy，若不是lazy，直接访问数据库检索，查到记录返回（并且同时在二级缓存中存放查到的数据方便下次使用，若再下次使用时在二级缓存命中，就是查到数据，则有可能将数据放到一级缓存中。），查不到抛出异常。 若是lazy，则返回代理对象，而不到数据库中查找，除非使用此对象时，才到数据库中查找。</p><p>get方法先到一级缓存，然后二级，最后db查找。</p><h2 id="hibernate-–-list和iterator方法的区别"><a href="#hibernate-–-list和iterator方法的区别" class="headerlink" title="hibernate – list和iterator方法的区别"></a>hibernate – list和iterator方法的区别</h2><p><strong>1.获取方式不一样:</strong></p><p>List的获取方式为：List<customers> list = query.list();</customers></p><p>Iterator的获取方式：Iterator<customers> it = query.iterate();<br><strong>2.执行sql不一样:</strong></customers></p><p>list()会直接查询数据库。</p><p>iterator()会先到数据库中把id都取出来，然后真正要遍历某个对象的时候先到缓存中找，如果找不到，以id为条件再发一条sql到数据库，这样如果缓存中没有数据，则查询数据库的次数为n+1次。</p><p><strong>3.list只查询一级缓存，而iterator会从二级缓存中查 </strong></p><p><strong>4.list方法返回的对象都是实体对象，而iterator返回的是代理对象</strong></p><p><strong>5.session中list第二次发出，仍会到数据库査询</strong></p><p><strong>6.iterate 第二次，首先找session 级缓存</strong></p><h2 id="Hibernate的优-缺点："><a href="#Hibernate的优-缺点：" class="headerlink" title="Hibernate的优/缺点："></a>Hibernate的优/缺点：</h2><p><strong>优点：</strong><br>1.更加对象化</p><pre><code>以对象化的思维操作数据库，我们只需要操作对象就可以了，开发更加对象化。</code></pre><p>2.移植性</p><pre><code>因为Hibernate做了持久层的封装，你就不知道数据库，你写的所有的代码都具有可复用性。</code></pre><p>3.Hibernate是一个没有侵入性的框架，没有侵入性的框架我们称为轻量级框架。</p><pre><code>对比Struts的Action和ActionForm，都需要继承，离不开Struts。Hibernate不需要继承任何类，不需要实现任何接口。这样的对象叫POJO对象。</code></pre><p>4.Hibernate代码测试方便。</p><p>5.提高效率，提高生产力。</p><p><strong>缺点：</strong></p><p>1.使用数据库特性的语句，将很难调优</p><p>2.对大批量数据更新存在问题</p><p>3.系统中存在大量的攻击查询功能</p><h2 id="Hibernate-openSession-和-getCurrentSession的区别"><a href="#Hibernate-openSession-和-getCurrentSession的区别" class="headerlink" title="Hibernate openSession() 和 getCurrentSession的区别"></a>Hibernate openSession() 和 getCurrentSession的区别</h2><p><strong>方式说明</strong></p><p>1.采用getCurrentSession()创建的Session会绑定到当前的线程中去、而采用OpenSession()则不会。</p><p>2.采用getCurrentSession()创建的Session在commit或rollback后会自动关闭，采用OpenSession()必须手动关闭。</p><p>3.采用getCurrentSession()需要在Hibernate.cfg.xml配置文件中加入如下配置：</p><p>如果是本地事物，及JDBC一个数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;propety name=”Hibernate.current_session_context_class”&gt;thread&lt;/propety&gt;</span><br></pre></td></tr></table></figure><p>如果是全局事物，及jta事物、多个数据库资源或事物资源：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;propety name=”Hibernate.current_session_context_class”&gt;jta&lt;/propety&gt;</span><br></pre></td></tr></table></figure></p><p><strong>总之:</strong></p><p>getCurrentSession ()  使用当前的session</p><p>openSession()         重新建立一个新的session</p><p>hibernate交给spring 管理的时，则首选getCurrentSession () </p><h2 id="Hibernate的缓存机制"><a href="#Hibernate的缓存机制" class="headerlink" title="Hibernate的缓存机制"></a>Hibernate的缓存机制</h2><p>一. 为什么要用Hibernate缓存：</p><p>​    Hibernate是一个ORM框架，会经常访问物理数据库。因此为了降低应用程序对数据库的访问频次，从而提高了应用程序的运行性能。</p><p>二. Hibernate缓存原理：</p><p>​    1. Hibernate的一级缓存是Session的缓存，Session内置的缓存是不能被卸载的，Session的缓存是事务范围的缓存，即对应一个数据库事务或者一个应用事务的生命周期（例如买火车票这个动作，库存减一，买家加一，这就是一个事务），一级缓存中，持久化类的每个实例都具有唯一的OID，一级缓存存放的是数据库数据的拷贝。</p><p>​    2. Hibernate的二级缓存是SessionFactory的缓存，由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采取并发访问策略达到事务隔离。</p><p>​    二级缓存是可选了，默认情况下二级缓存是不会启用的。二级缓存存放元数据和预定义的SQL，且是只读的。</p><p>​    什么数据适合存放在二级缓存中呢？</p><p>​    1）很少被修改的数据</p><p>​    2）不太重要的数据，允许偶尔出现并发的数据</p><p>​    3）不会被并发访问的数据</p><p>​    4）常量数据</p><p>三. Hibernate缓存何时被清除：</p><p>​    1. commit()方法被调用的时候。</p><p>​    2. 执行查询时会清除缓存，从而保证查询结果能反映对象的最新状态。</p><p>​    3. 显式调用session的flush()方法。</p><h2 id="Hibernate中的一级缓存、二级缓存和懒加载"><a href="#Hibernate中的一级缓存、二级缓存和懒加载" class="headerlink" title="Hibernate中的一级缓存、二级缓存和懒加载"></a>Hibernate中的一级缓存、二级缓存和懒加载</h2><p><strong>为什么使用缓存</strong><br>　　hibernate使用缓存减少对数据库的访问次数，从而提升hibernate的执行效率。hibernate中有两种类型的缓存：一级缓存和二级缓存。<br><strong>一级缓存</strong></p><ul><li><p>Hibenate中一级缓存，也叫做session的缓存，当调用session的save/saveOrUpdate/get/load/list/iterator方法的时候，都会把对象放入session的缓存中。</p><ul><li><p>一级缓存可以在session范围内减少数据库的访问次数，只在session范围有效，session关闭，一级缓存失效。</p></li><li><p>session的缓存由hibernate维护， 用户不能操作缓存内容； 如果想操作缓存内容，必须通过hibernate提供的evit/clear方法操作。</p></li></ul></li></ul><p><strong>特点</strong></p><p>只在当前session范围有效，作用时间短，效果不是特别明显！ </p><p>在短时间内多次操作数据库，效果比较明显！<br><strong>二级缓存</strong><br>Hibernate提供了基于应用程序级别的缓存， 可以跨多个session，即不同的session都可以访问缓存数据。 这个缓存也叫二级缓存。</p><p>Hibernate提供的二级缓存有默认的实现，且是一种可插配的缓存框架！如果用户想用二级缓存，只需要在hibernate.cfg.xml中配置即可； 不想用，直接移除，不影响代码。如果用户觉得hibernate提供的框架框架不好用，自己可以换其他的缓存框架或自己实现缓存框架。</p><p><strong>懒加载</strong><br>当用到数据的时候才向数据库查询，这就是hibernate的懒加载特性。<br>lazy 值</p><pre><code>true     使用懒加载false    关闭懒加载extra   在集合数据懒加载时候提升效率，在真正使用数据的时候才向数据库发送查询的sql，如果调用集合的size()/isEmpty()方法，只是统计，不真正查询数据！</code></pre><h2 id="hibernate-常见的主键策略有哪些"><a href="#hibernate-常见的主键策略有哪些" class="headerlink" title="hibernate 常见的主键策略有哪些"></a>hibernate 常见的主键策略有哪些</h2><p><strong>1.assigned</strong><br>   主键由外部程序负责生成，在 save() 之前必须指定一个。Hibernate不负责维护主键生成。与Hibernate和底层数据库都无关，可以跨数据库。在存储对象前，必须要使用主键的setter方法给主键赋值，至于这个值怎么生成，完全由自己决定，这种方法应该尽量避免</p><p><strong>2.increment</strong></p><p>   由Hibernate从数据库中取出主键的最大值（每个session只取1次），以该值为基础，每次增量为1，在内存中生成主键，不依赖于底层的数据库，因此可以跨数据库。</p><p><strong>3.sequence</strong></p><p>   采用数据库提供的sequence机制生成主键，需要数据库支持sequence。如oralce、DB、SAP DB、PostgerSQL、McKoi中的sequence。MySQL这种不支持sequence的数据库</p><p><strong>4.identity</strong></p><p>   identity由底层数据库生成标识符。identity是由数据库自己生成的，但这个主键必须设置为自增长，使用identity的前提条件是底层数据库支持自动增长字段类型，如DB2、SQL Server、MySQL、Sybase和HypersonicSQL等，Oracle这类没有自增字段的则不支持。 </p><p><strong>5.native </strong></p><p>   native由hibernate根据使用的数据库自行判断采用identity、hilo、sequence其中一种作为主键生成方式，灵活性很强。如果能支持identity则使用identity，如果支持sequence则使用sequence。<br><strong>6.uuid:</strong><br>   适用于char,varchar类型的作为主键.</p><h2 id="谈谈Hibernate中inverse的作用"><a href="#谈谈Hibernate中inverse的作用" class="headerlink" title="谈谈Hibernate中inverse的作用"></a>谈谈Hibernate中inverse的作用</h2><p>inverse属性默认是false,就是说关系的两端都来维护关系。<br>比如Student和Teacher是多对多关系，用一个中间表TeacherStudent维护。Gp)i<br>如果Student这边inverse=”true”, 那么关系由另一端Teacher维护，就是说当插入Student时，不会操作TeacherStudent表（中间表）。只有Teacher插入或删除时才会触发对中间表的操作。所以两边都inverse=”true”是不对的，会导致任何操作都不触发对中间表的影响；当两边都inverse=”false”或默认时，会导致在中间表中插入两次关系。</p><h2 id="简述cascade属性的作用"><a href="#简述cascade属性的作用" class="headerlink" title="简述cascade属性的作用"></a>简述cascade属性的作用</h2><p>1.all   :对象所有操作进行级联操作<br>2.save-update :  执行保存和更改操作时进行级联操作<br>3.save 执行保存操作时进行级联操作。<br>4.delete :  执行删除操作时进行级联操作<br>5.none : 对所有操作不进行级联操作       默认。</p><h2 id="什么是SessionFactory-她是线程安全么？"><a href="#什么是SessionFactory-她是线程安全么？" class="headerlink" title="什么是SessionFactory,她是线程安全么？"></a>什么是SessionFactory,她是线程安全么？</h2><p>sessionFactory就是一个用于创建Hibernate的Session对象的工厂。SessionFactory通常是在应用启动时创建好的，应用程序中的代码用它来获得Session对象。作为一个单个的数据存储，它也是 线程安全的，所以多个线程可同时使用同一个SessionFactory。Java JEE应用一般只有一个SessionFactory，服务于客户请求的各线程都通过这个工厂来获得Hibernate的Session实例，这也是为什么SessionFactory接口的实现必须是线程安全的原因。还有，SessionFactory的内部状态包含着同对象关系影射有关的所有元数据，它是 不可变的，一旦创建好后就不能对其进行修改了。 </p><h2 id="update（）和saveOrUpdate（）的区别"><a href="#update（）和saveOrUpdate（）的区别" class="headerlink" title="update（）和saveOrUpdate（）的区别"></a>update（）和saveOrUpdate（）的区别</h2><p>   update()和saveOrUpdate()是用来对跨Session的PO(实体类)进行状态管理的。<br>   update()方法操作的对象必须是持久化了的对象。也就是说，如果此对象在数据库中不存在的话，就不能使用update()方法。<br>   saveOrUpdate()方法操作的对象既可以使持久化了的，也可以使没有持久化的对象。如果是持久化了的对象调用saveOrUpdate()则会   更新数据库中的对象；如果是未持久化的对象使用此方法,则save到数据库中。</p><h2 id="hibernate拒绝连接、服务器崩溃的原因？最少写5个"><a href="#hibernate拒绝连接、服务器崩溃的原因？最少写5个" class="headerlink" title="hibernate拒绝连接、服务器崩溃的原因？最少写5个"></a>hibernate拒绝连接、服务器崩溃的原因？最少写5个</h2><ol><li><p>db没有打开  </p></li><li><p>网络连接可能出了问题</p></li><li><p>连接配置错了</p></li><li><p>驱动的driver，url是否都写对了</p></li><li><p>LIB下加入相应驱动，数据连接代码是否有误</p></li><li><p>数据库配置可能有问题</p></li><li><p>当前联接太多了，服务器都有访问人数限制的</p></li><li><p>服务器的相应端口没有开，即它不提供相应的服务</p></li></ol><h2 id="hibernate的三种状态之间如何转换"><a href="#hibernate的三种状态之间如何转换" class="headerlink" title="hibernate的三种状态之间如何转换"></a>hibernate的三种状态之间如何转换</h2><p>当对象由<strong>瞬时状态(Transient)</strong>一save()时，就变成了持久化状态。<br>当我们在Session里存储对象的时候，实际是在Session的Map里存了一份，    也就是它的缓存里放了一份，然后，又到数据库里存了一份，在缓存里这一份叫持久对象(Persistent)。<br>Session 一 Close()了，它的缓存也都关闭了，整个Session也就失效了，    这个时候，这个对象变成了<strong>游离状态(Detached)</strong>，但数据库中还是存在的。<br>当游离状态(Detached)update()时，又变为了<strong>持久状态(Persistent)</strong>。    当持久状态(Persistent)delete()时，又变为了瞬时状态(Transient),    此时，数据库中没有与之对应的记录。</p><h2 id="Hibernate-的OpenSessionView-问题"><a href="#Hibernate-的OpenSessionView-问题" class="headerlink" title="Hibernate 的OpenSessionView 问题"></a>Hibernate 的OpenSessionView 问题</h2><ol><li>用于解决懒加载异常, 主要功能就是把 Hibernate Session 和一个请求的线程绑定在一起, 直到页面完整输出, 这样就可以保证页面读取数据的时候 Session 一直是开启的状态, 如果去获取延迟加载对象也不会报错。</li><li>问题: 如果在业务处理阶段大批量处理数据, 有可能导致一级缓存里的对象占用内存过多导致内存溢出, 另外一个是连接问题: Session 和数据库 Connection 是绑定在一起的, 如果业务处理缓慢也会导致数据库连接得不到及时的释放, 造成连接池连接不够. 所以在并发量较大的项目中不建议使用此种方式, 可以考虑使用迫切左外连接 (LEFT OUTER JOIN FETCH) 或手工对关联的对象进行初始化.</li><li>配置 Filter 的时候要放在 Struts2 过滤器的前面, 因为它要页面完全显示完后再退出<h2 id="hibernate-jpa-注解"><a href="#hibernate-jpa-注解" class="headerlink" title="hibernate jpa 注解"></a>hibernate jpa 注解</h2><strong>1.@Entity(name=”EntityName”)</strong><br>必须,name为可选,对应数据库中一的个表</li></ol><p><strong>2.@Table(name=””,catalog=””,schema=””)</strong><br>可选,通常和@Entity配合使用，只能标注在实体的class定义处,表示实体对应的数据库表的信息<br>name:可选,表示表的名称。默认地，表名和实体名称一致,只有在不一致的情况下才需要指定表名<br>catalog:可选,表示Catalog名称，默认为Catalog(“”)。<br>schema:可选,表示Schema名称，默认为Schema(“”)。</p><p><strong>3.@id</strong><br>必须<br>@id定义了映射到数据库表的主键的属性,一个实体只能有一个属性被映射为主键.置于getXxxx()前.</p><p><strong>4.@GeneratedValue(strategy=GenerationType,generator=””)</strong><br>可选<br>strategy:表示主键生成策略,有AUTO,INDENTITY,SEQUENCE 和 TABLE 4种,分别表示让ORM框架自动选择,<br>根据数据库的Identity字段生成,根据数据库表的Sequence字段生成,以有根据一个额外的表生成主键,默认为AUTO<br>generator:表示主键生成器的名称,这个属性通常和ORM框架相关,例如,Hibernate可以指定uuid等主键生成方式.<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Id</span><br><span class="line">@GeneratedValues(strategy=StrategyType.SEQUENCE)</span><br><span class="line">    public int getPk() &#123;</span><br><span class="line">    return pk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>5.@Basic(fetch=FetchType,optional=true)</strong><br>可选<br>@Basic表示一个简单的属性到数据库表的字段的映射,对于没有任何标注的getXxxx()方法,默认即为@Basic<br><strong>fetch:</strong> 表示该属性的读取策略,有EAGER和LAZY两种,分别表示主支抓取和延迟加载,默认为EAGER.<br><strong>optional</strong>:表示该属性是否允许为null,默认为true<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Basic(optional=false)</span><br><span class="line">public String getAddress() &#123;</span><br><span class="line">    return address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>6.@Column</strong><br>可选<br>@Column描述了数据库表中该字段的详细定义,这对于根据JPA注解生成数据库表结构的工具非常有作用.<br><strong>name:</strong>表示数据库表中该字段的名称,默认情形属性名称一致<br><strong>nullable:</strong>表示该字段是否允许为null,默认为true<br><strong>unique:</strong>表示该字段是否是唯一标识,默认为false<br><strong>length:</strong>表示该字段的大小,仅对String类型的字段有效<br><strong>insertable:</strong>表示在ORM框架执行插入操作时,该字段是否应出现INSETRT语句中,默认为true<br><strong>updateable:</strong>表示在ORM框架执行更新操作时,该字段是否应该出现在UPDATE语句中,默认为true.对于一经创建就不可以更改的字段,该属性非常有用,如对于birthday字段.<br><strong>columnDefinition:</strong> 表示该字段在数据库中的实际类型.通常ORM框架可以根据属性类型自动判断数据库中字段的类型,但是对于Date类型仍无法确定数据库中字段类型究竟是 DATE,TIME还是<strong>TIMESTAMP</strong>.此外,String的默认映射类型为VARCHAR,如果要将String类型映射到特定数据库的BLOB或 TEXT字段类型,该属性非常有用.<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Column(name=&quot;BIRTH&quot;, nullable=&quot;false&quot;, columnDefinition=&quot;DATE&quot;)</span><br><span class="line">public String getBithday() &#123;</span><br><span class="line">    return birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>7.@Transient</strong><br>可选<br>@Transient表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性.<br>如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//根据birth计算出age属性</span><br><span class="line">@Transient</span><br><span class="line">public int getAge() &#123;</span><br><span class="line">    return getYear(new Date()) – getYear(birth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>8.@ManyToOne(fetch=FetchType,cascade=CascadeType)</strong><br>可选<br>@ManyToOne表示一个多对一的映射,该注解标注的属性通常是数据库表的外键<br><strong>optional:</strong>是否允许该字段为null,该属性应该根据数据库表的外键约束来确定,默认为true<br><strong>fetch:</strong>表示抓取策略,默认为FetchType.EAGER<br><strong>cascade:</strong>表示默认的级联操作策略,可以指定为ALL,PERSIST,MERGE,REFRESH和REMOVE中的若干组合,默认为无级联操作<br><strong>targetEntity:</strong>表示该属性关联的实体类型.该属性通常不必指定,ORM框架根据属性类型自动判断targetEntity.<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//订单Order和用户User是一个ManyToOne的关系</span><br><span class="line">//在Order类中定义</span><br><span class="line">@ManyToOne()</span><br><span class="line">@JoinColumn(name=”USER”)</span><br><span class="line">public User getUser() &#123;</span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>9.@JoinColumn</strong><br>可选<br>@JoinColumn和@Column类似,介量描述的不是一个简单字段,而一一个关联字段,例如.描述一个@ManyToOne的字段.<br>name:该字段的名称.由于@JoinColumn描述的是一个关联字段,如ManyToOne,则默认的名称由其关联的实体决定.<br>例如,实体Order有一个user属性来关联实体User,则Order的user属性为一个外键,<br>其默认的名称为实体User的名称+下划线+实体User的主键名称<br>示例:<br>见@ManyToOne<br>@OneToMany(fetch=FetchType,cascade=CascadeType)<br>可选<br>10.@OneToMany描述一个一对多的关联,该属性应该为集体类型,在数据库中并没有实际字段.<br>fetch:表示抓取策略,默认为FetchType.LAZY,因为关联的多个对象通常不必从数据库预先读取到内存<br>cascade:表示级联操作策略,对于OneToMany类型的关联非常重要,通常该实体更新或删除时,其关联的实体也应当被更新或删除<br>例如:实体User和Order是OneToMany的关系,则实体User被删除时,其关联的实体Order也应该被全部删除<br>示例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@OneTyMany(cascade=ALL)</span><br><span class="line">public List getOrders() &#123;</span><br><span class="line">    return orders;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Hibernate验证注解"><a href="#Hibernate验证注解" class="headerlink" title="Hibernate验证注解"></a>Hibernate验证注解</h3><table><thead><tr><th>注解</th><th style="text-align:left">适用类型</th><th style="text-align:left">说明</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td>@Pattern</td><td style="text-align:left">String</td><td style="text-align:left">通过正则表达式来验证字符串</td><td style="text-align:left">@Pattern(regex=”[a-z]{6}”)</td></tr><tr><td>@Length</td><td style="text-align:left">String</td><td style="text-align:left">验证字符串的长度</td><td style="text-align:left">@length(min=3,max=20)</td></tr><tr><td>@Email</td><td style="text-align:left">String</td><td style="text-align:left">验证一个Email地址是否有效</td><td style="text-align:left">@email</td></tr><tr><td>@Range</td><td style="text-align:left">Long</td><td style="text-align:left">验证一个整型是否在有效的范围内</td><td style="text-align:left">@Range(min=0,max=100)</td></tr><tr><td>@Min</td><td style="text-align:left">Long</td><td style="text-align:left">验证一个整型必须不小于指定值</td><td style="text-align:left">@Min(value=10)</td></tr><tr><td>@Max</td><td style="text-align:left">Long</td><td style="text-align:left">验证一个整型必须不大于指定值</td><td style="text-align:left">@Max(value=20)</td></tr><tr><td>@Size</td><td style="text-align:left">集合或数组</td><td style="text-align:left">集合或数组的大小是否在指定范围内</td><td style="text-align:left">@Size(min=1,max=255)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;hibernate-简介&quot;&gt;&lt;a href=&quot;#hibernate-简介&quot; class=&quot;headerlink&quot; title=&quot;hibernate 简介&quot;&gt;&lt;/a&gt;hibernate 简介&lt;/h2&gt;&lt;p&gt;hibernate是一个开源框架，它是对象关联关系映射的框架
      
    
    </summary>
    
      <category term="hibernate简介" scheme="https://daytable.github.io/categories/hibernate%E7%AE%80%E4%BB%8B/"/>
    
    
      <category term="Hibernate" scheme="https://daytable.github.io/tags/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title>HQL的连接查询</title>
    <link href="https://daytable.github.io/2018/12/04/HQL%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    <id>https://daytable.github.io/2018/12/04/HQL的连接查询/</id>
    <published>2018-12-04T05:24:57.000Z</published>
    <updated>2018-12-04T05:27:04.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HQL的连接查询"><a href="#HQL的连接查询" class="headerlink" title="HQL的连接查询"></a>HQL的连接查询</h1><h3 id="HQL支持各种各样的连接查询"><a href="#HQL支持各种各样的连接查询" class="headerlink" title="HQL支持各种各样的连接查询"></a>HQL支持各种各样的连接查询</h3><table><thead><tr><th>连接类型</th><th>HQL语法</th></tr></thead><tbody><tr><td>内联结</td><td>inner join            或 join</td></tr><tr><td>迫切内联结</td><td>inner join fetch   或 join fetch</td></tr><tr><td>左外连接</td><td>left outer join      或 leftjoin</td></tr><tr><td>迫切左外连接</td><td>left outer join fetch    或 left join fetch</td></tr><tr><td>右外连接</td><td>right outer join           或 right join</td></tr></tbody></table><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table><thead><tr><th style="text-align:center">聚合函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">count()</td><td style="text-align:center">统计记录条数</td></tr><tr><td style="text-align:center">sum()</td><td style="text-align:center">求和</td></tr><tr><td style="text-align:center">max()</td><td style="text-align:center">求最大值</td></tr><tr><td style="text-align:center">min()</td><td style="text-align:center">求最小值</td></tr><tr><td style="text-align:center">avg()</td><td style="text-align:center">求平均值</td></tr></tbody></table><h3 id="子查询语句应用在HQl查询语句的where子句中"><a href="#子查询语句应用在HQl查询语句的where子句中" class="headerlink" title="子查询语句应用在HQl查询语句的where子句中"></a>子查询语句应用在HQl查询语句的where子句中</h3><table><thead><tr><th style="text-align:center">关键字</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">all</td><td>返回的所有记录</td></tr><tr><td style="text-align:center">any</td><td>返回的任意一条数据</td></tr><tr><td style="text-align:center">some</td><td>和”any”意思相同</td></tr><tr><td style="text-align:center">in</td><td>与”=any”意思相同</td></tr><tr><td style="text-align:center">exists</td><td>至少返回一条记录</td></tr></tbody></table><h3 id="HQL提供了操作集合的函数或属性"><a href="#HQL提供了操作集合的函数或属性" class="headerlink" title="HQL提供了操作集合的函数或属性"></a>HQL提供了操作集合的函数或属性</h3><table><thead><tr><th>函数或属性</th><th>说明</th></tr></thead><tbody><tr><td>size()或size</td><td>获取集合中元素的数目</td></tr><tr><td>minIndex()或minIndex</td><td>对于建立了索引的集合,获得最小的索引</td></tr><tr><td>maxIndex()或maxIndex</td><td>对于建立了索引的几个 获得最大的索引</td></tr><tr><td>minElement()或minElement</td><td>对于包含基本类型元素的集合 获取最小值的元素</td></tr><tr><td>maxElement()或maxElement</td><td>对于包含基本类型元素的集合,获取最大值的元素</td></tr><tr><td>elements()</td><td>获取集合中的所有元素</td></tr></tbody></table><h2 id="Hibernate查询优化的策略"><a href="#Hibernate查询优化的策略" class="headerlink" title="Hibernate查询优化的策略"></a>Hibernate查询优化的策略</h2><p>1.使用延迟加载等方式避免加载多余数据<br>2.通过使用连接查询,配置二级缓存,查询缓存等方式减少select语句数目<br>3.结合缓存机制 使用iterate()方法减少查询字段数及数据库访问次数</p><h2 id="HQl优化"><a href="#HQl优化" class="headerlink" title="HQl优化"></a>HQl优化</h2><p>1.注意避免or,not,like使用不当导致的索引失效<br>2.注意避免having子句,distinct导致的开销<br>3.注意避免对索引字段使用函数或进行计算导致的索引失效</p><h2 id="ibernate提供了注解来替代hbm-xml文件完成对象-关系映射"><a href="#ibernate提供了注解来替代hbm-xml文件完成对象-关系映射" class="headerlink" title="ibernate提供了注解来替代hbm.xml文件完成对象-关系映射"></a>ibernate提供了注解来替代hbm.xml文件完成对象-关系映射</h2><h2 id="使用Hibernate注解的步骤如下"><a href="#使用Hibernate注解的步骤如下" class="headerlink" title="使用Hibernate注解的步骤如下:"></a>使用Hibernate注解的步骤如下:</h2><p>1.使用注解配置持久化类以及对象关联关系<br>2.在Hibernate配置文件(hibernate.cfg.xml)中声明持久化类 <mapping class="持久化类完整限定名"></mapping></p><h2 id="注解含义以及作用"><a href="#注解含义以及作用" class="headerlink" title="注解含义以及作用"></a>注解含义以及作用</h2><table><thead><tr><th>注解</th><th>含义和作用</th></tr></thead><tbody><tr><td>@Entity</td><td>将一个类声明为一个持久化类</td></tr><tr><td>@Table</td><td>为持久化类映射指定表</td></tr><tr><td>@Id</td><td>明了持久化类的标识属性</td></tr><tr><td>@GeneratedValue</td><td>定义标识属性值的生成策略</td></tr><tr><td>@SequenceGenerator</td><td>定义序列生产器</td></tr><tr><td>@Column</td><td>将属性映射到列(字段)</td></tr><tr><td>@Transient</td><td>将忽略这些属性</td></tr><tr><td><u>@OneToOne</u></td><td><u>建立持久化类之间的一对一关联关系</u> </td></tr><tr><td>@OneToMany</td><td>建立持久化类之间的一对多关联关系</td></tr><tr><td>@ManyToOne</td><td>建立持久化类之间的多对一关联关系</td></tr><tr><td>@JoinColumn</td><td>和@ManyToOne配合,指定外键列</td></tr><tr><td>@ManyToMany</td><td>建立持久化类之间的多对多关联关系</td></tr></tbody></table><p>注:下划线是几乎不用的注解 没意义</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HQL的连接查询&quot;&gt;&lt;a href=&quot;#HQL的连接查询&quot; class=&quot;headerlink&quot; title=&quot;HQL的连接查询&quot;&gt;&lt;/a&gt;HQL的连接查询&lt;/h1&gt;&lt;h3 id=&quot;HQL支持各种各样的连接查询&quot;&gt;&lt;a href=&quot;#HQL支持各种各样的连接查询&quot;
      
    
    </summary>
    
      <category term="HQL连接查询" scheme="https://daytable.github.io/categories/HQL%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2/"/>
    
    
      <category term="HQL" scheme="https://daytable.github.io/tags/HQL/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题4</title>
    <link href="https://daytable.github.io/2018/12/04/Java%E9%9D%A2%E8%AF%95%E9%A2%984/"/>
    <id>https://daytable.github.io/2018/12/04/Java面试题4/</id>
    <published>2018-12-04T00:24:57.000Z</published>
    <updated>2018-12-04T07:00:09.094Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题4"><a href="#Java面试题4" class="headerlink" title="Java面试题4"></a>Java面试题4</h3><h5 id="31-静态变量和实例变量的区别？"><a href="#31-静态变量和实例变量的区别？" class="headerlink" title="31.静态变量和实例变量的区别？"></a>31.静态变量和实例变量的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">静态变量也叫类变量，</span><br><span class="line">这种变量前加了static修饰符。</span><br><span class="line">可以直接用类名调用，</span><br><span class="line">也可以用对象调用，</span><br><span class="line">而且所有对象的同一个类变量 </span><br><span class="line">都是共享同一块内存空间。</span><br><span class="line"></span><br><span class="line">实例变量也叫对象变量，</span><br><span class="line">这种变量没有加static修饰符。</span><br><span class="line">只能通过对象调用， </span><br><span class="line">而且所有对象的同一个实例变量</span><br><span class="line">是共享不同的内存空间的。</span><br><span class="line"></span><br><span class="line">区别在于：</span><br><span class="line">静态变量是所有对象共有的，</span><br><span class="line">某一个对象将它的值改变了，</span><br><span class="line">其他对象再去获取它的值，</span><br><span class="line">得到的是改变后的值；</span><br><span class="line">实例变量则是每一个对象私有的，</span><br><span class="line">某一个对象将它的值改变了，</span><br><span class="line">不影响其他对象取值的结果，</span><br><span class="line">其他对象仍会得到实例变量</span><br><span class="line">一开始就被赋予的值。</span><br><span class="line"></span><br><span class="line">实例变量必须创建对象后</span><br><span class="line">才可以通过这个对象来使用，</span><br><span class="line">静态变量</span><br><span class="line">则可以直接使用类名来引用。</span><br></pre></td></tr></table></figure><h5 id="32-垃圾回收器的基本原理是什么？"><a href="#32-垃圾回收器的基本原理是什么？" class="headerlink" title="32.垃圾回收器的基本原理是什么？"></a>32.垃圾回收器的基本原理是什么？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收器是Java平台中用的</span><br><span class="line">最频繁的一种对象销毁方法。</span><br><span class="line">垃圾回收器会全程侦测</span><br><span class="line">Java应用程序的运行情况。</span><br><span class="line">当发现有些对象成为垃圾时，</span><br><span class="line">垃圾回收器就会销毁这些对象，</span><br><span class="line">并释放这些对象所占用的内存空间。</span><br><span class="line">在这里，程序开发人员需要知道，</span><br><span class="line">在哪些情况下垃圾回收器</span><br><span class="line">会认为这些对象是垃圾对象。</span><br><span class="line">通常情况下，如果发生以下两种情况时，</span><br><span class="line">系统会认为这些对象是垃圾对象，</span><br><span class="line">需要销毁。</span><br><span class="line">一是将一个NULL值赋值给对象。</span><br><span class="line">二是对象其超出了作用范围，</span><br></pre></td></tr></table></figure><h5 id="33-垃圾回收器可以马上回收内存吗？"><a href="#33-垃圾回收器可以马上回收内存吗？" class="headerlink" title="33.垃圾回收器可以马上回收内存吗？"></a>33.垃圾回收器可以马上回收内存吗？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不会马上回收，</span><br><span class="line">只有在必须回收时才会回收，</span><br><span class="line">或者你可以调用垃圾回收方法，</span><br><span class="line">虚拟机会在空闲时回收，</span><br><span class="line">至于什么时候回收，</span><br><span class="line">虚拟机说了算</span><br></pre></td></tr></table></figure><h5 id="34-有什么办法主动通知虚拟机进行垃圾回收？"><a href="#34-有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="34.有什么办法主动通知虚拟机进行垃圾回收？"></a>34.有什么办法主动通知虚拟机进行垃圾回收？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">对于GC来说，</span><br><span class="line">当程序员创建对象时，</span><br><span class="line">GC就开始监控这个对象的地址、</span><br><span class="line">大小以及使用情况。 </span><br><span class="line">通常，GC采用有向图的方式</span><br><span class="line">记录和管理堆(heap)中的所有对象。</span><br><span class="line">通过这种方式确定哪些对象是”可达的”，</span><br><span class="line">哪些对象是”不可达的”。</span><br><span class="line">当GC确定一些对象为”不可达”时，</span><br><span class="line">GC就有责任回收这些内存空间。</span><br><span class="line">可以。程序员可以手动</span><br><span class="line">执行System.gc()，</span><br><span class="line">通知GC运行，</span><br><span class="line">但是Java语言规范</span><br><span class="line">并不保证GC一定会执行。</span><br><span class="line">System.gc()的工作原理Java中的内存分配</span><br><span class="line">是随着new一个新的对象来实现的，</span><br><span class="line">这个很简单，</span><br><span class="line">而且也还是有一些</span><br><span class="line">可以“改进”内存回收的机制的，</span><br><span class="line">其中最显眼的</span><br><span class="line">就是这个System.gc()函数。</span><br><span class="line"></span><br><span class="line">乍一看这个函数似乎是可以进行垃圾回收的，</span><br><span class="line">可事实并不是那么简单。</span><br><span class="line">其实这个gc()函数的作用只是提醒虚拟机：</span><br><span class="line">程序员希望进行一次垃圾回收。</span><br><span class="line">但是它不能保证垃圾回收一定会进行，</span><br><span class="line">而且具体什么时候进行</span><br><span class="line">是取决于具体的虚拟机的，</span><br><span class="line">不同的虚拟机有不同的对策。</span><br></pre></td></tr></table></figure><h5 id="35-内部类可以引用他包含类的成员吗？"><a href="#35-内部类可以引用他包含类的成员吗？" class="headerlink" title="35.内部类可以引用他包含类的成员吗？"></a>35.内部类可以引用他包含类的成员吗？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">完全可以。</span><br><span class="line">如果不是静态内部类，</span><br><span class="line">那没有什么限制！ </span><br><span class="line">一个内部类对象可以访问</span><br><span class="line">创建它的外部类对象的成员包括私有成员。</span><br><span class="line">如果你把静态嵌套类当作内部类的一种特例，</span><br><span class="line">那在这种情况下不可以访问外部类的</span><br><span class="line">普通成员变量，</span><br><span class="line">而只能访问外部类中的静态成员。</span><br><span class="line"></span><br><span class="line">内部类的访问规则：</span><br><span class="line">1、内部类可以直接访问外部类中的成员，</span><br><span class="line">包括私有。</span><br><span class="line">之所以可以直接访问外部类中的成员，</span><br><span class="line">是因为内部类中持有了</span><br><span class="line">一个外部类的引用，</span><br><span class="line">格式 外部类名.this</span><br><span class="line"></span><br><span class="line">2、外部类要访问内部类，</span><br><span class="line">必须建立内部类对象。</span><br><span class="line"></span><br><span class="line">内部类定义在局部时，</span><br><span class="line">1、不可以被成员修饰符修饰</span><br><span class="line">2、可以直接访问外部类中的成员，</span><br><span class="line">因为还持有外部类中的引用。</span><br><span class="line">但是不可以访问它所在的局部中的变量。</span><br><span class="line">只能访问被final修饰的局部变量。</span><br></pre></td></tr></table></figure><h5 id="36-Java-中的异常处理机制的简单原理和应用？"><a href="#36-Java-中的异常处理机制的简单原理和应用？" class="headerlink" title="36.Java 中的异常处理机制的简单原理和应用？"></a>36.Java 中的异常处理机制的简单原理和应用？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> 一、Execption可以分为</span><br><span class="line">java标准定义的异常</span><br><span class="line">程序员自定义异常2种1.</span><br><span class="line">一种是当程序违反了java语规则的时候,</span><br><span class="line">JAVA虚拟机就会将发生的错误</span><br><span class="line">表示为一个异常.</span><br><span class="line">这里语法规则指的是</span><br><span class="line">JAVA类库内置的语义检查。</span><br><span class="line">例如 int i = 2 / 0 </span><br><span class="line"> 或者 String str = null;</span><br><span class="line"> str.length();2.</span><br><span class="line"></span><br><span class="line">另一种情况就是JAVA允许程序员</span><br><span class="line">扩展这种语义检查，</span><br><span class="line">程序员可以创建自己的异常，</span><br><span class="line">并自由选择在何时用throw关键字</span><br><span class="line">引发异常。</span><br><span class="line"></span><br><span class="line">例如 Exception ex = new Exception(&quot;这是我自定义的异常;</span><br><span class="line">throw ex;</span><br><span class="line"></span><br><span class="line">所有的异常都是Thowable的子类。</span><br><span class="line">异常处理是与程序执行是并行的。</span><br><span class="line"></span><br><span class="line">二、异常的处理方式</span><br><span class="line">1.捕获异常</span><br><span class="line"></span><br><span class="line"> try &#123;</span><br><span class="line">  int i = 2 / 0;</span><br><span class="line"> &#125; catch (Exception ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">   System.out.println(&quot;异常信息：&quot; + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.上抛异常 throws</span><br><span class="line">public void test() throws Exception &#123; </span><br><span class="line">    String str = null;</span><br><span class="line">    str.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="37-运行时异常与一般异常有何异同？"><a href="#37-运行时异常与一般异常有何异同？" class="headerlink" title="37.运行时异常与一般异常有何异同？"></a>37.运行时异常与一般异常有何异同？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(1)运行时异常</span><br><span class="line">都是RuntimeException类</span><br><span class="line">及其子类异常，</span><br><span class="line">如NullPointerException、</span><br><span class="line">IndexOutOfBoundsException等，</span><br><span class="line">这些异常是不检查异常，</span><br><span class="line">程序中可以选择捕获处理，</span><br><span class="line">也可以不处理。</span><br><span class="line">这些异常一般是由程序逻辑错误引起的，</span><br><span class="line">程序应该从逻辑角度</span><br><span class="line">尽可能避免这类异常的发生。</span><br><span class="line"></span><br><span class="line">当出现RuntimeException的时候，</span><br><span class="line">我们可以不处理。</span><br><span class="line">当出现这样的异常时，</span><br><span class="line">总是由虚拟机接管。</span><br><span class="line">比如：我们从来没有人</span><br><span class="line">去处理过NullPointerException异常，</span><br><span class="line">它就是运行时异常，</span><br><span class="line">并且这种异常还是最常见的异常之一。</span><br><span class="line"></span><br><span class="line">出现运行时异常后，</span><br><span class="line">系统会把异常一直往上层抛，</span><br><span class="line">一直遇到处理代码。</span><br><span class="line">如果没有处理块，</span><br><span class="line">到最上层，</span><br><span class="line">如果是多线程就由Thread.run()抛出，</span><br><span class="line">如果是单线程就被main()抛出。</span><br><span class="line">抛出之后，</span><br><span class="line">如果是线程，</span><br><span class="line">这个线程也就退出了。</span><br><span class="line">如果是主程序抛出的异常，</span><br><span class="line">那么这整个程序也就退出了。</span><br><span class="line">运行时异常是Exception的子类，</span><br><span class="line">也有一般异常的特点，</span><br><span class="line">是可以被Catch块处理的。</span><br><span class="line">只不过往往我们不对他处理罢了。</span><br><span class="line">也就是说，</span><br><span class="line">你如果不对运行时异常进行处理，</span><br><span class="line">那么出现运行时异常之后，</span><br><span class="line">要么是线程中止，</span><br><span class="line">要么是主程序终止。 </span><br><span class="line"></span><br><span class="line">如果不想终止，</span><br><span class="line">则必须扑捉所有的运行时异常，</span><br><span class="line">决不让这个处理线程退出。</span><br><span class="line">队列里面出现异常数据了，</span><br><span class="line">正常的处理应该是把异常数据舍弃，</span><br><span class="line">然后记录日志。</span><br><span class="line">不应该由于异常数据</span><br><span class="line">而影响下面对正常数据的处理。</span><br><span class="line"></span><br><span class="line">(2)非运行时异常</span><br><span class="line">是RuntimeException以外的异常，</span><br><span class="line">类型上都属于Exception类及其子类。</span><br><span class="line">如 IOException、SQLException 等</span><br><span class="line">以及用户自定义的Exception异常。</span><br><span class="line">对于这种异常，</span><br><span class="line">JAVA编译器强制要求我们</span><br><span class="line">必需对出现的这些异常进行catch并处理，</span><br><span class="line">否则程序就不能编译通过。</span><br><span class="line">所以，面对这种异常不管我们是否愿意，</span><br><span class="line">只能自己去写一大堆catch块</span><br><span class="line">去处理可能的异常。</span><br></pre></td></tr></table></figure><h5 id="38-为什么Map接口不继承Collection-接口？"><a href="#38-为什么Map接口不继承Collection-接口？" class="headerlink" title="38.为什么Map接口不继承Collection 接口？"></a>38.为什么Map接口不继承Collection 接口？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection是最基本的集合接口，</span><br><span class="line">声明了适用于JAVA集合（只包括Set和List）</span><br><span class="line">的通用方法。 </span><br><span class="line">Set 和List 都继承了Conllection；</span><br><span class="line">Set具有与Collection完全一样的接口，</span><br><span class="line">因此没有任何额外的功能，</span><br><span class="line">不像前面有两个不同的List。</span><br><span class="line">实际上Set就是Collection,只 是行为不同。</span><br><span class="line">(这是继承与多态思想的典型应用：表现不同的行为。)</span><br><span class="line">Set不保存重复的元素</span><br><span class="line">(至于如何判断元素相同则较为负责) </span><br><span class="line"></span><br><span class="line"> Map没有继承于Collection接口 </span><br><span class="line">从Map集合中检索元素时，</span><br><span class="line">只要给出键对象，</span><br><span class="line">就会返回对应的值对象。</span><br></pre></td></tr></table></figure><h5 id="39-Collection-和-Map-的区别"><a href="#39-Collection-和-Map-的区别" class="headerlink" title="39.Collection 和 Map 的区别"></a>39.Collection 和 Map 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">容器内每个为之所存储的元素个数不同。</span><br><span class="line">Collection类型者，</span><br><span class="line">每个位置只有一个元素。Map类型者，</span><br><span class="line">持有 key-value pair，</span><br><span class="line">像个小型数据库</span><br><span class="line"></span><br><span class="line">尽管Map接口和它的实现也是集合框架的一部分，</span><br><span class="line">但Map不是集合，</span><br><span class="line">集合也不是Map。</span><br><span class="line">因此，Map继承Collection毫无意义，</span><br><span class="line">反之亦然。</span><br><span class="line">如果Map继承Collection接口，</span><br><span class="line">那么元素去哪儿？Map包含key-value对，</span><br><span class="line">它提供抽取key或value列表集合的方法，</span><br><span class="line">但是它不适合“一组对象”规范。</span><br></pre></td></tr></table></figure><h5 id="40-comparable-和-comparator的不同之处？"><a href="#40-comparable-和-comparator的不同之处？" class="headerlink" title="40.comparable 和 comparator的不同之处？"></a>40.comparable 和 comparator的不同之处？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Comparable可以认为是一个内比较器，</span><br><span class="line">实现了Comparable接口的类有一个特点，</span><br><span class="line">就是这些类是可以和自己比较的，</span><br><span class="line">至于具体和另一个实现了Comparable接口的类如何比较，</span><br><span class="line">则依赖compareTo方法的实现，</span><br><span class="line">compareTo方法也被称为自然比较方法。</span><br><span class="line">如果开发者add进入</span><br><span class="line">一个Collection的对象想要Collections的sort方法</span><br><span class="line">帮你自动进行排序的话，</span><br><span class="line">那么这个对象必须实现Comparable接口。</span><br><span class="line">compareTo方法的返回值是int，</span><br><span class="line">有三种情况：</span><br><span class="line">1、比较者大于被比较者</span><br><span class="line">（也就是compareTo方法里面的对象），</span><br><span class="line">那么返回正整数</span><br><span class="line">2、比较者等于被比较者，那么返回</span><br><span class="line">03、比较者小于被比较者，那么返回负整数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Comparator可以认为是是一个外比较器，</span><br><span class="line">个人认为有两种情况</span><br><span class="line">可以使用实现Comparator接口的方式：</span><br><span class="line">1、一个对象不支持自己和自己比较</span><br><span class="line">（没有实现Comparable接口），</span><br><span class="line">但是又想对两个对象进行比较</span><br><span class="line">2、一个对象实现了Comparable接口，</span><br><span class="line">但是开发者认为compareTo方法中的</span><br><span class="line">比较方式并不是自己想要的那种比较方式</span><br><span class="line"></span><br><span class="line">Comparator接口里面有一个compare方法，</span><br><span class="line">方法有两个参数T o1和T o2，</span><br><span class="line">是泛型的表示方式，</span><br><span class="line">分别表示待比较的两个对象，</span><br><span class="line">方法返回值和Comparable接口一样是int，</span><br><span class="line">有三种情况：</span><br><span class="line">1、o1大于o2，返回正整数</span><br><span class="line">2、o1等于o2，返回</span><br><span class="line">03、o1小于o2，返回负整数</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">两种比较器Comparable和Comparator，</span><br><span class="line">后者相比前者有如下优点：</span><br><span class="line"></span><br><span class="line">1、如果实现类没有实现Comparable接口，</span><br><span class="line">又想对两个类进行比较</span><br><span class="line">或者实现类实现了Comparable接口，</span><br><span class="line">但是对compareTo方法内的比较算法不满意，</span><br><span class="line">那么可以实现Comparator接口，</span><br><span class="line">自定义一个比较器，</span><br><span class="line">写比较算法</span><br><span class="line"></span><br><span class="line">2、实现Comparable接口的方式比</span><br><span class="line">实现Comparator接口的耦合性要强一些，</span><br><span class="line">如果要修改比较算法，</span><br><span class="line">要修改Comparable接口的实现类，</span><br><span class="line">而实现Comparator的类是在外部进行比较的，</span><br><span class="line">不需要对实现类有任何修 改。</span><br><span class="line">从这个角度说，</span><br><span class="line">其实有些不太好，</span><br><span class="line">尤其在我们将实现类的.class文件</span><br><span class="line">打成一个.jar文件</span><br><span class="line">提供给开发者使用的时候。</span><br><span class="line">实际上实现Comparator 接口的方式</span><br><span class="line">后面会写到就是一种典型的策略模式。</span><br><span class="line"></span><br><span class="line">当然，这不是鼓励用Comparator，</span><br><span class="line">意思是开发者还是要在具体场景下</span><br><span class="line">选择最合适的那种比较器而已。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题4&quot;&gt;&lt;a href=&quot;#Java面试题4&quot; class=&quot;headerlink&quot; title=&quot;Java面试题4&quot;&gt;&lt;/a&gt;Java面试题4&lt;/h3&gt;&lt;h5 id=&quot;31-静态变量和实例变量的区别？&quot;&gt;&lt;a href=&quot;#31-静态变量和实例变量的
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题3</title>
    <link href="https://daytable.github.io/2018/12/03/Java%E9%9D%A2%E8%AF%95%E9%A2%983/"/>
    <id>https://daytable.github.io/2018/12/03/Java面试题3/</id>
    <published>2018-12-03T00:39:36.000Z</published>
    <updated>2018-12-04T06:59:37.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题3"><a href="#Java面试题3" class="headerlink" title="Java面试题3"></a>Java面试题3</h3><h5 id="21-final-finally-finalize的区别"><a href="#21-final-finally-finalize的区别" class="headerlink" title="21.final, finally, finalize的区别"></a>21.final, finally, finalize的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、final修饰符（关键字）。</span><br><span class="line">被final修饰的类，</span><br><span class="line">就意味着不能再派生出新的子类，</span><br><span class="line">不能作为父类而被子类继承。</span><br><span class="line">因此一个类不能既被abstract声明，</span><br><span class="line">又被final声明。将变量或方法声明为final，</span><br><span class="line">可以保证他们在使用的过程中不被修改。</span><br><span class="line">被声明为final的变量</span><br><span class="line">必须在声明时给出变量的初始值，</span><br><span class="line">而在以后的引用中只能读取。</span><br><span class="line">被final声明的方法也同样只能使用，</span><br><span class="line">即不能方法重写。</span><br></pre></td></tr></table></figure><h5 id="22-finally是在异常处理时"><a href="#22-finally是在异常处理时" class="headerlink" title="22.finally是在异常处理时"></a>22.finally是在异常处理时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">提供finally块来执行任何清除操作。</span><br><span class="line">不管有没有异常被抛出、捕获，</span><br><span class="line">finally块都会被执行。</span><br><span class="line">try块中的内容是在无异常时执行到结束。</span><br><span class="line">catch块中的内容，</span><br><span class="line">是在try块内容发生catch所声明的异常时，</span><br><span class="line">跳转到catch块中执行。finally块则是无论异常是否发生，</span><br><span class="line">都会执行finally块的内容，</span><br><span class="line">所以在代码逻辑中有需要</span><br><span class="line">无论发生什么都必须执行的代码，</span><br><span class="line">就可以放在finally块中。3、finalize是方法名。</span><br><span class="line">java技术允许使用finalize（）方法</span><br><span class="line">在垃圾收集器将对象从内存中</span><br><span class="line">清除出去之前做必要的清理工作。</span><br><span class="line">这个方法是由垃圾收集器</span><br><span class="line">在确定这个对象没有被引用时对这个对象调用的。</span><br><span class="line">它是在object类中定义的，</span><br><span class="line">因此所有的类都继承了它。</span><br><span class="line">子类覆盖finalize（）方法</span><br><span class="line">以整理系统资源或者被执行其他清理工作。</span><br><span class="line">finalize（）方法是在垃圾收集器</span><br><span class="line">删除对象之前对这个对象调用的。 </span><br><span class="line"></span><br><span class="line">###2.Overload和Override的区别。</span><br><span class="line">首先重载和重写是应用于</span><br><span class="line">两个不同场景下面的两种不同的手段：</span><br><span class="line">两者各自的特征：</span><br><span class="line">重载（Overload）:</span><br><span class="line">首先是位于一个类之中或者其子类中，</span><br><span class="line">具有相同的方法名，</span><br><span class="line">但是方法的参数不同，</span><br><span class="line">返回值类型可以相同也可以不同。</span><br><span class="line">（1）：方法名必须相同</span><br><span class="line">（2）：方法的参数列表一定不一样。</span><br><span class="line">（3）：访问修饰符和返回值类型</span><br><span class="line">可以相同也可以不同。</span><br><span class="line">其实简单而言：</span><br><span class="line">重载就是对于不同的情况写不同的方法。</span><br><span class="line"> 比如，同一个类中，</span><br><span class="line">写不同的构造函数用于初始化不同的参数。</span><br><span class="line"></span><br><span class="line">重写（override）：</span><br><span class="line">一般都是表示子类和父类之间的关系，</span><br><span class="line">其主要的特征是：</span><br><span class="line">方法名相同，</span><br><span class="line">参数相同，</span><br><span class="line">但是具体的实现不同。</span><br><span class="line"></span><br><span class="line">重写的特征：</span><br><span class="line">（1）：方法名必须相同，返回值类型必须相同</span><br><span class="line">（2）：参数列表必须相同</span><br><span class="line">（3）：访问权限不能比父类中被</span><br><span class="line">重写的方法的访问权限更低。</span><br><span class="line">例如：如果父类的一个方法被声明为public，</span><br><span class="line">那么在子类中重写该方法</span><br><span class="line">就不能声明为protected。</span><br><span class="line">（4）：子类和父类在同一个包中，</span><br><span class="line">那么子类可以重写父类所有方法，</span><br><span class="line">除了声明为private和final的方法。</span><br><span class="line">（5）：构造方法不能被重写，</span><br><span class="line">简单而言：就是具体的实现类</span><br><span class="line">对于父类的该方法实现不满意，</span><br><span class="line">需要自己在写一个满足于自己要求的方法。</span><br></pre></td></tr></table></figure><h5 id="23-Java中的String-StringBuilder-StringBuffer三者的区别"><a href="#23-Java中的String-StringBuilder-StringBuffer三者的区别" class="headerlink" title="23. Java中的String,StringBuilder,StringBuffer三者的区别?"></a>23. Java中的String,StringBuilder,StringBuffer三者的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">首先说运行速度，或者说是执行速度，</span><br><span class="line">在这方面运行速度快慢为：</span><br><span class="line">StringBuilder &gt; </span><br><span class="line">StringBuffer &gt; </span><br><span class="line">StringString最慢的原因：</span><br><span class="line">String为字符串常量，</span><br><span class="line">而StringBuilder和</span><br><span class="line">StringBuffer均为字符串变量，</span><br><span class="line">即String对象一旦创建之后</span><br><span class="line">该对象是不可更改的，</span><br><span class="line">但后两者的对象是变量，</span><br><span class="line">是可以更改的。</span><br><span class="line">而StringBuilder和StringBuffer的</span><br><span class="line">对象是变量，</span><br><span class="line">对变量进行操作就是</span><br><span class="line">直接对该对象进行更改，</span><br><span class="line">而不进行创建和回收的操作，</span><br><span class="line">所以速度要比String快很多。</span><br><span class="line">String            ----&gt;     字符串常量</span><br><span class="line">StringBuffer      ----&gt;     字符串变量（线程安全的）</span><br><span class="line">StringBuilder     ----&gt;     字符串变量（非线程安全的）</span><br><span class="line">String：</span><br><span class="line">适用于少量的字符串操作的情况</span><br><span class="line">StringBuilder：</span><br><span class="line">适用于单线程下在字符缓冲区进行大量操作的情况</span><br><span class="line">StringBuffer：</span><br><span class="line">适用多线程下在字符缓冲区进行大量操作的情况</span><br></pre></td></tr></table></figure><h5 id="24-GC是什么-为什么要有GC"><a href="#24-GC是什么-为什么要有GC" class="headerlink" title="24.GC是什么? 为什么要有GC?"></a>24.GC是什么? 为什么要有GC?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GC是垃圾收集的意思，</span><br><span class="line">内存处理是编程人员容易出现问题的地方，</span><br><span class="line">忘记或者错误的内存回收</span><br><span class="line">会导致程序或系统的不稳定甚至崩溃，</span><br><span class="line">Java提供的GC功能</span><br><span class="line">可以自动监测对象是否超过作用域</span><br><span class="line">从而达到自动回收内存的目的，</span><br><span class="line">Java语言没有提供释放已分配内存的</span><br><span class="line">显示操作方法。</span><br><span class="line">Java程序员不用担心内存管理，</span><br><span class="line">因为垃圾收集器会自动进行管理。</span><br><span class="line">要请求垃圾收集，</span><br><span class="line">可以调用下面的方法之一：</span><br><span class="line">System.gc()或Runtime.getRuntime().gc()，</span><br><span class="line">但JVM可以屏蔽掉显示的垃圾回收调用。 </span><br><span class="line"></span><br><span class="line">垃圾回收可以有效的防止内存泄露，</span><br><span class="line">有效的使用可以使用的内存。</span><br><span class="line">垃圾回收器通常是作为</span><br><span class="line">一个单独的低优先级的线程运行，</span><br><span class="line">不可预知的情况下对内存堆中</span><br><span class="line">已经死亡的或者长时间</span><br><span class="line">没有使用的对象进行清除和回收，</span><br><span class="line">程序员不能实时的调用垃圾回收器</span><br><span class="line">对某个对象或所有对象进行垃圾回收。</span><br><span class="line">Java有了GC，</span><br><span class="line">就不需要程序员去人工释放内存空间。</span><br><span class="line">当Java虚拟机发觉内存资源紧张的时候，</span><br><span class="line">就会自动地去清理</span><br><span class="line">无用变量所占用的内存空间。</span><br><span class="line">当然，如果需要，</span><br><span class="line">程序员可以在Java程序中显式地使用System.gc()</span><br><span class="line">来强制进行一次立即的内存清理。</span><br></pre></td></tr></table></figure><h5 id="25-构造器如何工作？"><a href="#25-构造器如何工作？" class="headerlink" title="25.构造器如何工作？"></a>25.构造器如何工作？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java在构造实例时的顺序是这样的：</span><br><span class="line">1、分配对象空间，</span><br><span class="line">并将对象中成员初始化为0或者空</span><br><span class="line">java不允许用户操纵一个不定值的对象。 　　</span><br><span class="line">2、执行属性值的显式初始化 　　</span><br><span class="line">3、执行构造器 　　</span><br><span class="line">4 、将变量关联到堆中的对象上</span><br></pre></td></tr></table></figure><h5 id="26-构造器Constructor是否可被override"><a href="#26-构造器Constructor是否可被override" class="headerlink" title="26.构造器Constructor是否可被override?"></a>26.构造器Constructor是否可被override?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">构造器Constructor不能被继承，</span><br><span class="line">因此不能重写Overriding，</span><br><span class="line">但可以被重载Overloading </span><br><span class="line">1). 构造器不能是</span><br><span class="line">native,final,static,synchronized 的,</span><br><span class="line">可以是public,private,或什么都没有。 </span><br><span class="line">2). 构造器函数里可以写return呢,</span><br><span class="line">但后面什么都不许有(包括null) </span><br><span class="line">3). 构造器不能返回值. </span><br><span class="line">但如果有个&quot;构造器&quot;返值了,</span><br><span class="line">它就不是构造器喽,只是个普通方法 </span><br><span class="line">4). super();this();</span><br><span class="line">这两个方法只能在构造方法里调用. </span><br><span class="line">5). 成员变量声明时候赋值,比构造函数还早.</span><br></pre></td></tr></table></figure><h5 id="27-写一个Singleton出来。"><a href="#27-写一个Singleton出来。" class="headerlink" title="27.写一个Singleton出来。"></a>27.写一个Singleton出来。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Singleton模式主要作用是保证在Java应用程序中，</span><br><span class="line">一个类Class只有一个实例存在。 </span><br><span class="line">一般Singleton模式通常有几种种形式: </span><br><span class="line">第一种形式: 定义一个类，</span><br><span class="line">它的构造函数为private的，</span><br><span class="line">它有一个static的private的该类变量，</span><br><span class="line">在类初始化时实例话，</span><br><span class="line">通过一个public的getInstance方法获取对它的引用,</span><br><span class="line">继而调用其中的方法。 </span><br><span class="line"></span><br><span class="line">public class Singleton &#123; </span><br><span class="line"> private Singleton()&#123;&#125; </span><br><span class="line">　　//在自己内部定义自己一个实例，是不是很奇怪？ 　　</span><br><span class="line">    //注意这是private 只供内部调用 　　</span><br><span class="line">    private static Singleton instance = new Singleton(); </span><br><span class="line">　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 　</span><br><span class="line">  　public static Singleton getInstance() &#123; </span><br><span class="line">　　　　return instance; 　　 </span><br><span class="line">　　 &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">第二种形式: </span><br><span class="line">public class Singleton &#123; </span><br><span class="line">　　private static Singleton instance = null; </span><br><span class="line">　　public static synchronized Singleton getInstance() &#123; </span><br><span class="line">　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　</span><br><span class="line">　　//使用时生成实例，提高了效率！ 　　</span><br><span class="line">  　if (instance==null) </span><br><span class="line">　　　　instance＝new Singleton(); </span><br><span class="line">        return instance; 　　</span><br><span class="line">  　&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">其他形式: </span><br><span class="line">定义一个类，</span><br><span class="line">它的构造函数为private的，</span><br><span class="line">所有方法为static的。 </span><br><span class="line">一般认为第一种形式要更加安全些</span><br></pre></td></tr></table></figure><h5 id="28-error和exception有什么区别"><a href="#28-error和exception有什么区别" class="headerlink" title="28.error和exception有什么区别?"></a>28.error和exception有什么区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Error类和Exception类都继承自Throwable类。</span><br><span class="line">二者的不同之处：</span><br><span class="line">Exception：</span><br><span class="line">1．可以是可被控制(checked) </span><br><span class="line">或不可控制的(unchecked)。</span><br><span class="line">2．表示一个由程序员导致的错误。</span><br><span class="line">3．应该在应用程序级被处理。</span><br><span class="line"></span><br><span class="line">Error：</span><br><span class="line">1．总是不可控制的(unchecked)。</span><br><span class="line">2．经常用来用于表示系统错误或低层资源的错误。</span><br><span class="line">3．如何可能的话，应该在系统级被捕捉。</span><br><span class="line"></span><br><span class="line">error 表示恢复不是不可能</span><br><span class="line">但很困难的情况下的一种严重问题。</span><br><span class="line">比如说内存溢出。</span><br><span class="line">不可能指望程序能处理这样的情况。 </span><br><span class="line"></span><br><span class="line">exception 表示一种设计或实现问题。</span><br><span class="line">也就是说，</span><br><span class="line">它表示如果程序运行正常，</span><br><span class="line">从不会发生的情况。</span><br></pre></td></tr></table></figure><h5 id="29-HashMap和Hashtable的区别"><a href="#29-HashMap和Hashtable的区别" class="headerlink" title="29.HashMap和Hashtable的区别?"></a>29.HashMap和Hashtable的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hashmap:</span><br><span class="line">1.线程不安全</span><br><span class="line">2.允许有null的键和值</span><br><span class="line">3.效率高一点、</span><br><span class="line">4.方法不是Synchronize的要提供外同步</span><br><span class="line">5.有containsvalue和containsKey方法</span><br><span class="line">6.HashMap 是Java1.2 </span><br><span class="line">引进的Map interface 的一个实现</span><br><span class="line">7.HashMap是Hashtable的轻量级实现hashtable:</span><br><span class="line">1.线程安全</span><br><span class="line">2.不允许有null的键和值</span><br><span class="line">3.效率稍低、</span><br><span class="line">4.方法是是Synchronize的</span><br><span class="line">5.有contains方法方法</span><br><span class="line">6.Hashtable 继承于Dictionary 类</span><br><span class="line">7.Hashtable 比HashMap 要旧</span><br></pre></td></tr></table></figure><h5 id="30-和equals-区别"><a href="#30-和equals-区别" class="headerlink" title="30.==和equals()区别?"></a>30.==和equals()区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">对于==，</span><br><span class="line">如果作用于基本数据类型的变量，</span><br><span class="line">则直接比较其存储的 </span><br><span class="line">“值”是否相等；</span><br><span class="line">如果作用于引用类型的变量，</span><br><span class="line">则比较的是所指向的对象的地址</span><br><span class="line"></span><br><span class="line">对于equals方法，</span><br><span class="line">注意：equals方法不能作用于</span><br><span class="line">基本数据类型的变量</span><br><span class="line">如果没有对equals方法进行重写，</span><br><span class="line">则比较的是引用类型的变量所指向的对象的地址；</span><br><span class="line">诸如String、Date等类</span><br><span class="line">对equals方法进行了重写的话，</span><br><span class="line">比较的是所指向的对象的内容。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题3&quot;&gt;&lt;a href=&quot;#Java面试题3&quot; class=&quot;headerlink&quot; title=&quot;Java面试题3&quot;&gt;&lt;/a&gt;Java面试题3&lt;/h3&gt;&lt;h5 id=&quot;21-final-finally-finalize的区别&quot;&gt;&lt;a href=&quot;#2
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题2</title>
    <link href="https://daytable.github.io/2018/12/02/Java%E9%9D%A2%E8%AF%95%E9%A2%982/"/>
    <id>https://daytable.github.io/2018/12/02/Java面试题2/</id>
    <published>2018-12-02T05:01:09.000Z</published>
    <updated>2018-12-04T06:59:06.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题2"><a href="#Java面试题2" class="headerlink" title="Java面试题2"></a>Java面试题2</h3><h5 id="11-面向对象的特征有哪些方面"><a href="#11-面向对象的特征有哪些方面" class="headerlink" title="11.面向对象的特征有哪些方面"></a>11.面向对象的特征有哪些方面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.抽象：</span><br><span class="line">抽象就是忽略一个主题中与当前目标无关的那些方面，</span><br><span class="line">以便更充分地注意与当前目标有关的方面。</span><br><span class="line">抽象并不打算了解全部问题，而只是选择其中的一部分，</span><br><span class="line">暂时不用部分细节。</span><br><span class="line">抽象包括两个方面，</span><br><span class="line">一是过程抽象，</span><br><span class="line">二是数据抽象。</span><br><span class="line"></span><br><span class="line">2.继承：</span><br><span class="line">继承是一种联结类的层次模型，</span><br><span class="line">并且允许和鼓励类的重用，</span><br><span class="line">它提供了一种明确表述共性的方法。</span><br><span class="line">对象的一个新类可以从现有的类中派生，</span><br><span class="line">这个过程称为类继承。</span><br><span class="line">新类继承了原始类的特性，</span><br><span class="line">新类称为原始类的派生类（子类），</span><br><span class="line">而原始类称为新类的基类（父类）。</span><br><span class="line">派生类可以从它的基类那里继承方法和实例变量，</span><br><span class="line">并且类可以修改或增加新的方法使之更适合特殊的需要。</span><br><span class="line"></span><br><span class="line">3.封装：</span><br><span class="line">封装是把过程和数据包围起来，</span><br><span class="line">对数据的访问只能通过已定义的界面。</span><br><span class="line">面向对象计算始于这个基本概念，</span><br><span class="line">即现实世界可以被描绘成一系列完全自治、</span><br><span class="line">封装的对象，</span><br><span class="line">这些对象通过一个受保护的接口访问其他对象。</span><br><span class="line">4. 多态性：</span><br><span class="line">多态性是指允许不同类的对象对同一消息作出响应。</span><br><span class="line">多态性包括参数化多态性和包含多态性。</span><br><span class="line">多态性语言具有灵活、抽象、行为共享、代码共享的优势，</span><br><span class="line">很好的解决了应用程序函数同名问题。</span><br></pre></td></tr></table></figure><h5 id="12-java-创建对象的几种方式"><a href="#12-java-创建对象的几种方式" class="headerlink" title="12.java 创建对象的几种方式"></a>12.java 创建对象的几种方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">采用new通过反射</span><br><span class="line">采用clone通过序列化机制</span><br><span class="line">前2者都需要显式地调用构造方法。</span><br><span class="line">造成耦合性最高的恰好是第一种，</span><br><span class="line">因此你发现无论什么框架，</span><br><span class="line">只要涉及到解耦必先减少new的使用。</span><br></pre></td></tr></table></figure><h5 id="13-修饰符public-private-protected-以及不写时的区别"><a href="#13-修饰符public-private-protected-以及不写时的区别" class="headerlink" title="13.修饰符public,private,protected,以及不写时的区别"></a>13.修饰符public,private,protected,以及不写时的区别</h5><table><thead><tr><th>修饰符</th><th style="text-align:left">当前类</th><th style="text-align:left">同一package</th><th style="text-align:left">子孙类</th><th style="text-align:left">其他package</th></tr></thead><tbody><tr><td>public</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td>protected</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">×</td></tr><tr><td>default</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr><tr><td>private</td><td style="text-align:left">√</td><td style="text-align:left">×</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不写时默认为friendly/default</span><br><span class="line">friendly权限是java的默认权限，</span><br><span class="line">也称作包（package）访问权限</span><br><span class="line">只要不加private、public、protect的</span><br><span class="line">就是friendly访问权限，</span><br><span class="line">所有的成员仅限同一个包内的成员访问</span><br></pre></td></tr></table></figure><h5 id="14-String-s-new-String-“xyz”-创建了几个String-Object"><a href="#14-String-s-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="14.String s = new String(“xyz”);创建了几个String Object"></a>14.String s = new String(“xyz”);创建了几个String Object</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个，一个字符对象，一个字符对象引用对象</span><br></pre></td></tr></table></figure><h5 id="15-Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#15-Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?"></a>15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.round(11.5)==12;Math.round(-11.5)==-11;</span><br><span class="line">round方法返回与参数最接近的长整数，</span><br><span class="line">参数加1/2后求其floor</span><br></pre></td></tr></table></figure><h5 id="16-Java有没有goto"><a href="#16-Java有没有goto" class="headerlink" title="16.Java有没有goto?"></a>16.Java有没有goto?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java中的保留字，现在没有在java中使用</span><br></pre></td></tr></table></figure><h5 id="17-Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型"><a href="#17-Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型"></a>17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法的重写Overriding和重载Overloading是Java多态性的不同表现。</span><br><span class="line">重写Overriding是父类与子类之间多态性的一种表现，</span><br><span class="line">重载Overloading是一个类中多态性的一种表现。</span><br><span class="line">如果在子类中定义某方法与其父类有相同的名称和参数，</span><br><span class="line">我们说该方法被重写 (Overriding)。</span><br><span class="line">子类的对象使用这个方法时，</span><br><span class="line">将调用子类中的定义，</span><br><span class="line">对它而言，</span><br><span class="line">父类中的定义如同被&quot;屏蔽&quot;了。</span><br><span class="line">如果在一个类中定义了多个同名的方法，</span><br><span class="line">它们或有不同的参数个数或有不同的参数类型，</span><br><span class="line">则称为方法的重载(Overloading)。</span><br><span class="line">Overloaded的方法是可以改变返回值的类型</span><br></pre></td></tr></table></figure><h5 id="18-abstract-class和interface有什么区别"><a href="#18-abstract-class和interface有什么区别" class="headerlink" title="18.abstract class和interface有什么区别"></a>18.abstract class和interface有什么区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类</span><br><span class="line">被叫做抽象类（abstract class），</span><br><span class="line">它用于要创建一个体现某些基本行为的类，</span><br><span class="line">并为该类声明方法，</span><br><span class="line">但不能在该类中实现该类的情况。</span><br><span class="line">不能创建abstract 类的实例。</span><br><span class="line"></span><br><span class="line">然而可以创建一个变量，</span><br><span class="line">其类型是一个抽象类，</span><br><span class="line">并让它指向具体子类的一个实例。</span><br><span class="line">不能有抽象构造函数或抽象静态方法。</span><br><span class="line">Abstract 类的子类为它们父类中的</span><br><span class="line">所有抽象方法提供实现，</span><br><span class="line">否则它们也是抽象类为。</span><br><span class="line"></span><br><span class="line">取而代之，在子类中实现该方法。</span><br><span class="line">知道其行为的其它类可以在类中实现这些方法</span><br><span class="line">接口（interface）是抽象类的变体。</span><br><span class="line"></span><br><span class="line">在接口中，所有方法都是抽象的。</span><br><span class="line">多继承性可通过实现这样的接口而获得。</span><br><span class="line">接口中的所有方法都是抽象的，</span><br><span class="line">没有一个有程序体。</span><br><span class="line"></span><br><span class="line">接口只可以定义static final成员变量。</span><br><span class="line">接口的实现与子类相似，</span><br><span class="line">除了该实现类不能从接口定义中继承行为。</span><br><span class="line"></span><br><span class="line">当类实现特殊接口时，</span><br><span class="line">它定义（即将程序体给予）所有这种接口的方法。</span><br><span class="line">然后，它可以在实现了该接口的类的</span><br><span class="line">任何对象上调用接口的方法。</span><br><span class="line"></span><br><span class="line">由于有抽象类，</span><br><span class="line">它允许使用接口名作为引用变量的类型。</span><br><span class="line">通常的动态联编将生效。</span><br><span class="line">引用可以转换到接口类型或</span><br><span class="line">从接口类型转换，instanceof 运算符可以用来</span><br><span class="line">决定某对象的类是否实现了接口</span><br></pre></td></tr></table></figure><h5 id="19-接口是否可继承接口"><a href="#19-接口是否可继承接口" class="headerlink" title="19.接口是否可继承接口?"></a>19.接口是否可继承接口?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接口可以继承接口。</span><br><span class="line">抽象类可以实现(implements)接口，</span><br><span class="line">抽象类是否可继承实体类，但</span><br><span class="line">前提是实体类必须有明确的构造函数</span><br></pre></td></tr></table></figure><h5 id="20-swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"><a href="#20-swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上" class="headerlink" title="20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"></a>20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">swtich（）里面必须是int和enum--即枚举类型。</span><br><span class="line">short、 char 或者 byte</span><br><span class="line">他会自动转换为int的。。</span><br><span class="line">long不能自动转换为int..</span><br><span class="line">因为long比int范围大..</span><br><span class="line">可能会丢失精度..</span><br><span class="line"></span><br><span class="line">在java的1.7之后的jdk版本，</span><br><span class="line">java中的switch里面表达式的类型</span><br><span class="line">可以是string类型,</span><br><span class="line">之前是不可以使用的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题2&quot;&gt;&lt;a href=&quot;#Java面试题2&quot; class=&quot;headerlink&quot; title=&quot;Java面试题2&quot;&gt;&lt;/a&gt;Java面试题2&lt;/h3&gt;&lt;h5 id=&quot;11-面向对象的特征有哪些方面&quot;&gt;&lt;a href=&quot;#11-面向对象的特征有哪些方
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题1</title>
    <link href="https://daytable.github.io/2018/12/01/Java%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>https://daytable.github.io/2018/12/01/Java面试题1/</id>
    <published>2018-12-01T06:26:34.000Z</published>
    <updated>2018-12-04T07:14:12.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题-1"><a href="#Java面试题-1" class="headerlink" title="Java面试题(1)"></a>Java面试题(1)</h3><h5 id="1-简述JDK、JRE、JVM？"><a href="#1-简述JDK、JRE、JVM？" class="headerlink" title="1.简述JDK、JRE、JVM？"></a>1.简述JDK、JRE、JVM？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">一、JDK </span><br><span class="line">JDK(Java Development Kit) 是整个JAVA的核心，</span><br><span class="line">包括了Java运行环境（Java Runtime Envirnment），</span><br><span class="line">一堆Java工具（javac/java/jdb等）</span><br><span class="line">和Java基础的类库（即Java API 包括rt.jar）。 </span><br><span class="line">JDK是java开发工具包，</span><br><span class="line">基本上每个学java的人都会先在机器 上装一个JDK，</span><br><span class="line">那他都包含哪几部分呢？</span><br><span class="line">在目录下面有 六个文件夹、</span><br><span class="line">一个src类库源码压缩包、和其他几个声明文件。</span><br><span class="line">其中，真正在运行java时起作用的 </span><br><span class="line">是以下四个文件夹：bin、include、lib、 jre。</span><br><span class="line">有这样一个关系，JDK包含JRE，而JRE包 含JVM。 </span><br><span class="line">bin:最主要的是编译器(javac.exe) </span><br><span class="line">include:java和JVM交互用的头文件 </span><br><span class="line">lib：类库 </span><br><span class="line">jre:java运行环境 </span><br><span class="line"></span><br><span class="line">二、JRE </span><br><span class="line">JRE（Java Runtime Environment，Java运行环境）</span><br><span class="line">包含JVM标准实现及Java核心类库。</span><br><span class="line">JRE是Java运行环境，并不是一个开发环境，</span><br><span class="line">所以没有包含任何开发工具（如编译器和调试器） </span><br><span class="line">JRE是指java运行环境。</span><br><span class="line">光有JVM还不能成class的 执行，</span><br><span class="line">因为在解释class的时候JVM需要调用解释所需要的类库lib。 （</span><br><span class="line">jre里有运行.class的java.exe） </span><br><span class="line">JRE （ Java Runtime Environment ），</span><br><span class="line">是运行 Java 程序必不可少的</span><br><span class="line">（除非用其他一些编译环境编译成.exe可执行文件……），</span><br><span class="line">JRE的 地位就象一台PC机一样，</span><br><span class="line">我们写好的Win64应用程序需要操作系统帮 我们运行，</span><br><span class="line">同样的，我们编写的Java程序也必须要JRE才能运行。</span><br><span class="line"></span><br><span class="line">三、JVM </span><br><span class="line">JVM（Java Virtual Machine），</span><br><span class="line">即java虚拟机, java运行时的环境，</span><br><span class="line">JVM是一种用于计算设备的规范，</span><br><span class="line">它是一个虚构出来的计算机，</span><br><span class="line">是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line">针对java用户，</span><br><span class="line">也就是拥有可运行的.class文件包（jar或者war）的用户。</span><br><span class="line">里面主要包含了jvm和java运行时基本类库（rt.jar）。</span><br><span class="line">rt.jar可以简单粗暴地理解为：</span><br><span class="line">它就是java源码编译成的jar包。</span><br><span class="line">Java虚拟机在执行字节码时，</span><br><span class="line">把字节码解释成具体平台上的机器指令执行。</span><br><span class="line">这就是Java的能够“一次编译，</span><br><span class="line">到处运行”的原因。</span><br></pre></td></tr></table></figure><h5 id="2-JDK、JRE、JVM三者的有什么联系和区别？"><a href="#2-JDK、JRE、JVM三者的有什么联系和区别？" class="headerlink" title="2.JDK、JRE、JVM三者的有什么联系和区别？"></a>2.JDK、JRE、JVM三者的有什么联系和区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.三者联系：</span><br><span class="line">JVM不能单独搞定class的执行，</span><br><span class="line">解释class的时候JVM需要调用解释所需要的类库lib。</span><br><span class="line">在JDK下面的的jre目录里面</span><br><span class="line">有两个文件夹bin和lib,</span><br><span class="line">在这里可以认为bin里的就是jvm，</span><br><span class="line">lib中则是jvm工作所需要的类库，</span><br><span class="line">而jvm和 lib和起来就称为jre。</span><br><span class="line">JVM+Lib=JRE。</span><br><span class="line">总体来说就是，</span><br><span class="line">我们利用JDK（调用JAVA API）开发了属于</span><br><span class="line">我们自己的JAVA程序后，</span><br><span class="line">通过JDK中的编译程序（javac）</span><br><span class="line">将我们的文本java文件编译成JAVA字节码，</span><br><span class="line">在JRE上运行这些JAVA字节码，</span><br><span class="line">JVM解析这些字节码，</span><br><span class="line">映射到CPU指令集或OS的系统调用。2.三者区别： </span><br><span class="line">JDK和JRE区别：</span><br><span class="line">在bin文件夹下会发现，</span><br><span class="line">JDK有javac.exe而JRE里面没有，</span><br><span class="line">javac指令是用来将java文件编译成class文件的，</span><br><span class="line">这是开发者需要的，</span><br><span class="line">而用户（只需要运行的人）是不需要的。</span><br><span class="line">JDK还有jar.exe, javadoc.exe等等</span><br><span class="line">用于开发的可执行指令文件。</span><br><span class="line">这也证实了一个是开发环境，</span><br><span class="line">一个是运行环境。 </span><br><span class="line">b.JRE和JVM区别：</span><br><span class="line">JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，</span><br><span class="line">尤其是rt.jar。</span><br></pre></td></tr></table></figure><h5 id="3-简述Java程序编译和运行的过程？"><a href="#3-简述Java程序编译和运行的过程？" class="headerlink" title="3.简述Java程序编译和运行的过程？"></a>3.简述Java程序编译和运行的过程？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java程序从源文件创建到程序运行要经过两大步骤：</span><br><span class="line">1、源文件由编译器编译成字节码（ByteCode）； </span><br><span class="line">2、字节码由java虚拟机解释运行。</span><br><span class="line">因为java程序既要编译同时</span><br><span class="line">也要经过JVM的解释运行，</span><br><span class="line">所以说Java被称为半解释语言</span><br></pre></td></tr></table></figure><p><img src="/2018/12/01/Java面试题1/bianyi.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">第一步（编译）：</span><br><span class="line">创建完源文件之后，</span><br><span class="line">程序先要被JVM中的java编译器</span><br><span class="line">进行编译为.class文件。</span><br><span class="line">java编译一个类时，</span><br><span class="line">如果这个类所依赖的类还没有被编译，</span><br><span class="line"></span><br><span class="line">编译器会自动的先编译这个所依赖的类，</span><br><span class="line">然后引用。</span><br><span class="line">如果java编译器在指定的目录下</span><br><span class="line">找不到该类所依赖的类的 .class文件或者 .java源文件，</span><br><span class="line">就会报&quot;Cant found sysbol&quot;的异常错误。</span><br><span class="line"></span><br><span class="line">编译后的字节码文件格式</span><br><span class="line">主要分为两部分：</span><br><span class="line">常量池和方法字节码。</span><br><span class="line">常量池记录的是代码出现过的（常量、类名、成员变量等）</span><br><span class="line">以及符号引用（类引用、方法引用，成员变量引用等）；</span><br><span class="line">方法字节码中放的是各个方法的字节码。</span><br><span class="line"></span><br><span class="line">第二步（运行）：</span><br><span class="line">java类运行的过程大概分为两个步骤：</span><br><span class="line">（1）类的加载 </span><br><span class="line">（2）类的执行。</span><br><span class="line">需要说明的一点的是：</span><br><span class="line">JVM主要在程序第一次运行时主动使用类的时候，</span><br><span class="line">才会立即去加载。</span><br><span class="line">换言之，</span><br><span class="line">JVM并不是在运行时就会把所有使用到的类</span><br><span class="line">都加载到内存中，</span><br><span class="line">而是用到，不得不加载的时候，</span><br><span class="line">才加载进来，而且只加载一次！</span><br></pre></td></tr></table></figure></p><h5 id="4-请说出八种基础数据类型及字节大小？"><a href="#4-请说出八种基础数据类型及字节大小？" class="headerlink" title="4.请说出八种基础数据类型及字节大小？"></a>4.请说出八种基础数据类型及字节大小？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. byte                  8位</span><br><span class="line">2. short                16位</span><br><span class="line">3. int                  32位</span><br><span class="line">4. long                 64位</span><br><span class="line">5. float                32位</span><br><span class="line">6. double               64位</span><br><span class="line">7. boolean               1位</span><br><span class="line">8. char                 16位</span><br></pre></td></tr></table></figure><h5 id="5-说说-amp-和-amp-amp-的区别？"><a href="#5-说说-amp-和-amp-amp-的区别？" class="headerlink" title="5.说说&amp;和&amp;&amp;的区别？"></a>5.说说&amp;和&amp;&amp;的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;和&amp;&amp;都是逻辑运算符，</span><br><span class="line">都是判断两边同时真则为真，否则为假；</span><br><span class="line">但是&amp;&amp;当第一个条件不成之后，</span><br><span class="line">后面的条件都不执行了，</span><br><span class="line">而&amp;则还是继续执行，</span><br><span class="line">直到整个条件语句执行完为止。</span><br></pre></td></tr></table></figure><h5 id="6-float型float-f-3-4是否正确"><a href="#6-float型float-f-3-4是否正确" class="headerlink" title="6.float型float f=3.4是否正确?"></a>6.float型float f=3.4是否正确?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">不正确；</span><br><span class="line">精度不准确,</span><br><span class="line">应该用强制类型转换，</span><br><span class="line">如下所示：float f=(float)3.4</span><br></pre></td></tr></table></figure><h5 id="7-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#7-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a>7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">short s1 = 1; s1 = s1 + 1; </span><br><span class="line">s1+1运算结果是int型，</span><br><span class="line">需要强制转换类型； </span><br><span class="line"></span><br><span class="line">short s1 = 1; s1 += 1;</span><br><span class="line">可以正确编译,自动类型提升。</span><br></pre></td></tr></table></figure><h5 id="8-int-和-Integer-有什么区别"><a href="#8-int-和-Integer-有什么区别" class="headerlink" title="8.int 和 Integer 有什么区别?"></a>8.int 和 Integer 有什么区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Java 提供两种不同的类型：</span><br><span class="line">引用类型和原始类型（或内置类型）；</span><br><span class="line">int是java的原始数据类型，</span><br><span class="line">Integer是java为int提供的封装类。 </span><br><span class="line"></span><br><span class="line">引用类型和原始类型的行为完全不同，</span><br><span class="line">并且它们具有不同的语义。</span><br><span class="line">引用类型和原始类型具有不同的特征和用法，</span><br><span class="line"></span><br><span class="line">它们包括：大小和速度问题，</span><br><span class="line">这种类型以哪种类型的数据结构存储，</span><br><span class="line"></span><br><span class="line">当引用类型和原始类型</span><br><span class="line">用作某个类的实例数据时所指定的缺省值。</span><br><span class="line"></span><br><span class="line">对象引用实例变量的缺省值为 null，</span><br><span class="line">而原始类型实例变量的缺省值</span><br><span class="line">与它们的类型有关。</span><br></pre></td></tr></table></figure><h5 id="9-在JAVA中，如何跳出当前的多重嵌套循环？"><a href="#9-在JAVA中，如何跳出当前的多重嵌套循环？" class="headerlink" title="9.在JAVA中，如何跳出当前的多重嵌套循环？"></a>9.在JAVA中，如何跳出当前的多重嵌套循环？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在最外层循环前加label标识,</span><br><span class="line">然后用break:label方法即可跳出多重循环。</span><br><span class="line">ok:while(true)&#123;    while(true)&#123;        break ok;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-使用嵌套的for循环打印九九乘法表。"><a href="#10-使用嵌套的for循环打印九九乘法表。" class="headerlink" title="10.使用嵌套的for循环打印九九乘法表。"></a>10.使用嵌套的for循环打印九九乘法表。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;       </span><br><span class="line">  for (int i = 1; i &lt;= 9; i++) &#123;            </span><br><span class="line">    for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">      System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题-1&quot;&gt;&lt;a href=&quot;#Java面试题-1&quot; class=&quot;headerlink&quot; title=&quot;Java面试题(1)&quot;&gt;&lt;/a&gt;Java面试题(1)&lt;/h3&gt;&lt;h5 id=&quot;1-简述JDK、JRE、JVM？&quot;&gt;&lt;a href=&quot;#1-简述JDK
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://daytable.github.io/2018/11/09/hello-world/"/>
    <id>https://daytable.github.io/2018/11/09/hello-world/</id>
    <published>2018-11-09T10:54:47.838Z</published>
    <updated>2018-11-09T10:54:47.841Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
