<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>惬意</title>
  
  <subtitle>Don&#39;t let your dreams just be dreams</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://daytable.github.io/"/>
  <updated>2018-12-04T04:54:18.854Z</updated>
  <id>https://daytable.github.io/</id>
  
  <author>
    <name>惬意</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试</title>
    <link href="https://daytable.github.io/2018/12/04/%E6%B5%8B%E8%AF%95/"/>
    <id>https://daytable.github.io/2018/12/04/测试/</id>
    <published>2018-12-04T04:49:13.000Z</published>
    <updated>2018-12-04T04:54:18.854Z</updated>
    
    <content type="html"><![CDATA[<p>! <a href="测试/7.png"> </a><br><img src="/2018/12/04/测试/7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;! &lt;a href=&quot;测试/7.png&quot;&gt; &lt;/a&gt;&lt;br&gt;&lt;img src=&quot;/2018/12/04/测试/7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="测试图片" scheme="https://daytable.github.io/categories/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87/"/>
    
    
      <category term="测试" scheme="https://daytable.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题(4)</title>
    <link href="https://daytable.github.io/2018/12/04/Java%E9%9D%A2%E8%AF%95%E9%A2%98(4)/"/>
    <id>https://daytable.github.io/2018/12/04/Java面试题(4)/</id>
    <published>2018-12-04T00:24:57.000Z</published>
    <updated>2018-12-04T00:28:05.549Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题-4"><a href="#Java面试题-4" class="headerlink" title="Java面试题(4)"></a>Java面试题(4)</h3><h5 id="31-静态变量和实例变量的区别？"><a href="#31-静态变量和实例变量的区别？" class="headerlink" title="31.静态变量和实例变量的区别？"></a>31.静态变量和实例变量的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">静态变量也叫类变量，</span><br><span class="line">这种变量前加了static修饰符。</span><br><span class="line">可以直接用类名调用，</span><br><span class="line">也可以用对象调用，</span><br><span class="line">而且所有对象的同一个类变量 </span><br><span class="line">都是共享同一块内存空间。</span><br><span class="line"></span><br><span class="line">实例变量也叫对象变量，</span><br><span class="line">这种变量没有加static修饰符。</span><br><span class="line">只能通过对象调用， </span><br><span class="line">而且所有对象的同一个实例变量</span><br><span class="line">是共享不同的内存空间的。</span><br><span class="line"></span><br><span class="line">区别在于：</span><br><span class="line">静态变量是所有对象共有的，</span><br><span class="line">某一个对象将它的值改变了，</span><br><span class="line">其他对象再去获取它的值，</span><br><span class="line">得到的是改变后的值；</span><br><span class="line">实例变量则是每一个对象私有的，</span><br><span class="line">某一个对象将它的值改变了，</span><br><span class="line">不影响其他对象取值的结果，</span><br><span class="line">其他对象仍会得到实例变量</span><br><span class="line">一开始就被赋予的值。</span><br><span class="line"></span><br><span class="line">实例变量必须创建对象后</span><br><span class="line">才可以通过这个对象来使用，</span><br><span class="line">静态变量</span><br><span class="line">则可以直接使用类名来引用。</span><br></pre></td></tr></table></figure><h5 id="32-垃圾回收器的基本原理是什么？"><a href="#32-垃圾回收器的基本原理是什么？" class="headerlink" title="32.垃圾回收器的基本原理是什么？"></a>32.垃圾回收器的基本原理是什么？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">垃圾回收器是Java平台中用的</span><br><span class="line">最频繁的一种对象销毁方法。</span><br><span class="line">垃圾回收器会全程侦测</span><br><span class="line">Java应用程序的运行情况。</span><br><span class="line">当发现有些对象成为垃圾时，</span><br><span class="line">垃圾回收器就会销毁这些对象，</span><br><span class="line">并释放这些对象所占用的内存空间。</span><br><span class="line">在这里，程序开发人员需要知道，</span><br><span class="line">在哪些情况下垃圾回收器</span><br><span class="line">会认为这些对象是垃圾对象。</span><br><span class="line">通常情况下，如果发生以下两种情况时，</span><br><span class="line">系统会认为这些对象是垃圾对象，</span><br><span class="line">需要销毁。</span><br><span class="line">一是将一个NULL值赋值给对象。</span><br><span class="line">二是对象其超出了作用范围，</span><br></pre></td></tr></table></figure><h5 id="33-垃圾回收器可以马上回收内存吗？"><a href="#33-垃圾回收器可以马上回收内存吗？" class="headerlink" title="33.垃圾回收器可以马上回收内存吗？"></a>33.垃圾回收器可以马上回收内存吗？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不会马上回收，</span><br><span class="line">只有在必须回收时才会回收，</span><br><span class="line">或者你可以调用垃圾回收方法，</span><br><span class="line">虚拟机会在空闲时回收，</span><br><span class="line">至于什么时候回收，</span><br><span class="line">虚拟机说了算</span><br></pre></td></tr></table></figure><h5 id="34-有什么办法主动通知虚拟机进行垃圾回收？"><a href="#34-有什么办法主动通知虚拟机进行垃圾回收？" class="headerlink" title="34.有什么办法主动通知虚拟机进行垃圾回收？"></a>34.有什么办法主动通知虚拟机进行垃圾回收？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">对于GC来说，</span><br><span class="line">当程序员创建对象时，</span><br><span class="line">GC就开始监控这个对象的地址、</span><br><span class="line">大小以及使用情况。 </span><br><span class="line">通常，GC采用有向图的方式</span><br><span class="line">记录和管理堆(heap)中的所有对象。</span><br><span class="line">通过这种方式确定哪些对象是”可达的”，</span><br><span class="line">哪些对象是”不可达的”。</span><br><span class="line">当GC确定一些对象为”不可达”时，</span><br><span class="line">GC就有责任回收这些内存空间。</span><br><span class="line">可以。程序员可以手动</span><br><span class="line">执行System.gc()，</span><br><span class="line">通知GC运行，</span><br><span class="line">但是Java语言规范</span><br><span class="line">并不保证GC一定会执行。</span><br><span class="line">System.gc()的工作原理Java中的内存分配</span><br><span class="line">是随着new一个新的对象来实现的，</span><br><span class="line">这个很简单，</span><br><span class="line">而且也还是有一些</span><br><span class="line">可以“改进”内存回收的机制的，</span><br><span class="line">其中最显眼的</span><br><span class="line">就是这个System.gc()函数。</span><br><span class="line"></span><br><span class="line">乍一看这个函数似乎是可以进行垃圾回收的，</span><br><span class="line">可事实并不是那么简单。</span><br><span class="line">其实这个gc()函数的作用只是提醒虚拟机：</span><br><span class="line">程序员希望进行一次垃圾回收。</span><br><span class="line">但是它不能保证垃圾回收一定会进行，</span><br><span class="line">而且具体什么时候进行</span><br><span class="line">是取决于具体的虚拟机的，</span><br><span class="line">不同的虚拟机有不同的对策。</span><br></pre></td></tr></table></figure><h5 id="35-内部类可以引用他包含类的成员吗？"><a href="#35-内部类可以引用他包含类的成员吗？" class="headerlink" title="35.内部类可以引用他包含类的成员吗？"></a>35.内部类可以引用他包含类的成员吗？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">完全可以。</span><br><span class="line">如果不是静态内部类，</span><br><span class="line">那没有什么限制！ </span><br><span class="line">一个内部类对象可以访问</span><br><span class="line">创建它的外部类对象的成员包括私有成员。</span><br><span class="line">如果你把静态嵌套类当作内部类的一种特例，</span><br><span class="line">那在这种情况下不可以访问外部类的</span><br><span class="line">普通成员变量，</span><br><span class="line">而只能访问外部类中的静态成员。</span><br><span class="line"></span><br><span class="line">内部类的访问规则：</span><br><span class="line">1、内部类可以直接访问外部类中的成员，</span><br><span class="line">包括私有。</span><br><span class="line">之所以可以直接访问外部类中的成员，</span><br><span class="line">是因为内部类中持有了</span><br><span class="line">一个外部类的引用，</span><br><span class="line">格式 外部类名.this</span><br><span class="line"></span><br><span class="line">2、外部类要访问内部类，</span><br><span class="line">必须建立内部类对象。</span><br><span class="line"></span><br><span class="line">内部类定义在局部时，</span><br><span class="line">1、不可以被成员修饰符修饰</span><br><span class="line">2、可以直接访问外部类中的成员，</span><br><span class="line">因为还持有外部类中的引用。</span><br><span class="line">但是不可以访问它所在的局部中的变量。</span><br><span class="line">只能访问被final修饰的局部变量。</span><br></pre></td></tr></table></figure><h5 id="36-Java-中的异常处理机制的简单原理和应用？"><a href="#36-Java-中的异常处理机制的简单原理和应用？" class="headerlink" title="36.Java 中的异常处理机制的简单原理和应用？"></a>36.Java 中的异常处理机制的简单原理和应用？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> 一、Execption可以分为</span><br><span class="line">java标准定义的异常</span><br><span class="line">程序员自定义异常2种1.</span><br><span class="line">一种是当程序违反了java语规则的时候,</span><br><span class="line">JAVA虚拟机就会将发生的错误</span><br><span class="line">表示为一个异常.</span><br><span class="line">这里语法规则指的是</span><br><span class="line">JAVA类库内置的语义检查。</span><br><span class="line">例如 int i = 2 / 0 </span><br><span class="line"> 或者 String str = null;</span><br><span class="line"> str.length();2.</span><br><span class="line"></span><br><span class="line">另一种情况就是JAVA允许程序员</span><br><span class="line">扩展这种语义检查，</span><br><span class="line">程序员可以创建自己的异常，</span><br><span class="line">并自由选择在何时用throw关键字</span><br><span class="line">引发异常。</span><br><span class="line"></span><br><span class="line">例如 Exception ex = new Exception(&quot;这是我自定义的异常;</span><br><span class="line">throw ex;</span><br><span class="line"></span><br><span class="line">所有的异常都是Thowable的子类。</span><br><span class="line">异常处理是与程序执行是并行的。</span><br><span class="line"></span><br><span class="line">二、异常的处理方式</span><br><span class="line">1.捕获异常</span><br><span class="line"></span><br><span class="line"> try &#123;</span><br><span class="line">  int i = 2 / 0;</span><br><span class="line"> &#125; catch (Exception ex) &#123;</span><br><span class="line">   ex.printStackTrace();</span><br><span class="line">   System.out.println(&quot;异常信息：&quot; + ex.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.上抛异常 throws</span><br><span class="line">public void test() throws Exception &#123; </span><br><span class="line">    String str = null;</span><br><span class="line">    str.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="37-运行时异常与一般异常有何异同？"><a href="#37-运行时异常与一般异常有何异同？" class="headerlink" title="37.运行时异常与一般异常有何异同？"></a>37.运行时异常与一般异常有何异同？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">(1)运行时异常</span><br><span class="line">都是RuntimeException类</span><br><span class="line">及其子类异常，</span><br><span class="line">如NullPointerException、</span><br><span class="line">IndexOutOfBoundsException等，</span><br><span class="line">这些异常是不检查异常，</span><br><span class="line">程序中可以选择捕获处理，</span><br><span class="line">也可以不处理。</span><br><span class="line">这些异常一般是由程序逻辑错误引起的，</span><br><span class="line">程序应该从逻辑角度</span><br><span class="line">尽可能避免这类异常的发生。</span><br><span class="line"></span><br><span class="line">当出现RuntimeException的时候，</span><br><span class="line">我们可以不处理。</span><br><span class="line">当出现这样的异常时，</span><br><span class="line">总是由虚拟机接管。</span><br><span class="line">比如：我们从来没有人</span><br><span class="line">去处理过NullPointerException异常，</span><br><span class="line">它就是运行时异常，</span><br><span class="line">并且这种异常还是最常见的异常之一。</span><br><span class="line"></span><br><span class="line">出现运行时异常后，</span><br><span class="line">系统会把异常一直往上层抛，</span><br><span class="line">一直遇到处理代码。</span><br><span class="line">如果没有处理块，</span><br><span class="line">到最上层，</span><br><span class="line">如果是多线程就由Thread.run()抛出，</span><br><span class="line">如果是单线程就被main()抛出。</span><br><span class="line">抛出之后，</span><br><span class="line">如果是线程，</span><br><span class="line">这个线程也就退出了。</span><br><span class="line">如果是主程序抛出的异常，</span><br><span class="line">那么这整个程序也就退出了。</span><br><span class="line">运行时异常是Exception的子类，</span><br><span class="line">也有一般异常的特点，</span><br><span class="line">是可以被Catch块处理的。</span><br><span class="line">只不过往往我们不对他处理罢了。</span><br><span class="line">也就是说，</span><br><span class="line">你如果不对运行时异常进行处理，</span><br><span class="line">那么出现运行时异常之后，</span><br><span class="line">要么是线程中止，</span><br><span class="line">要么是主程序终止。 </span><br><span class="line"></span><br><span class="line">如果不想终止，</span><br><span class="line">则必须扑捉所有的运行时异常，</span><br><span class="line">决不让这个处理线程退出。</span><br><span class="line">队列里面出现异常数据了，</span><br><span class="line">正常的处理应该是把异常数据舍弃，</span><br><span class="line">然后记录日志。</span><br><span class="line">不应该由于异常数据</span><br><span class="line">而影响下面对正常数据的处理。</span><br><span class="line"></span><br><span class="line">(2)非运行时异常</span><br><span class="line">是RuntimeException以外的异常，</span><br><span class="line">类型上都属于Exception类及其子类。</span><br><span class="line">如 IOException、SQLException 等</span><br><span class="line">以及用户自定义的Exception异常。</span><br><span class="line">对于这种异常，</span><br><span class="line">JAVA编译器强制要求我们</span><br><span class="line">必需对出现的这些异常进行catch并处理，</span><br><span class="line">否则程序就不能编译通过。</span><br><span class="line">所以，面对这种异常不管我们是否愿意，</span><br><span class="line">只能自己去写一大堆catch块</span><br><span class="line">去处理可能的异常。</span><br></pre></td></tr></table></figure><h5 id="38-为什么Map接口不继承Collection-接口？"><a href="#38-为什么Map接口不继承Collection-接口？" class="headerlink" title="38.为什么Map接口不继承Collection 接口？"></a>38.为什么Map接口不继承Collection 接口？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection是最基本的集合接口，</span><br><span class="line">声明了适用于JAVA集合（只包括Set和List）</span><br><span class="line">的通用方法。 </span><br><span class="line">Set 和List 都继承了Conllection；</span><br><span class="line">Set具有与Collection完全一样的接口，</span><br><span class="line">因此没有任何额外的功能，</span><br><span class="line">不像前面有两个不同的List。</span><br><span class="line">实际上Set就是Collection,只 是行为不同。</span><br><span class="line">(这是继承与多态思想的典型应用：表现不同的行为。)</span><br><span class="line">Set不保存重复的元素</span><br><span class="line">(至于如何判断元素相同则较为负责) </span><br><span class="line"></span><br><span class="line"> Map没有继承于Collection接口 </span><br><span class="line">从Map集合中检索元素时，</span><br><span class="line">只要给出键对象，</span><br><span class="line">就会返回对应的值对象。</span><br></pre></td></tr></table></figure><h5 id="39-Collection-和-Map-的区别"><a href="#39-Collection-和-Map-的区别" class="headerlink" title="39.Collection 和 Map 的区别"></a>39.Collection 和 Map 的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">容器内每个为之所存储的元素个数不同。</span><br><span class="line">Collection类型者，</span><br><span class="line">每个位置只有一个元素。Map类型者，</span><br><span class="line">持有 key-value pair，</span><br><span class="line">像个小型数据库</span><br><span class="line"></span><br><span class="line">尽管Map接口和它的实现也是集合框架的一部分，</span><br><span class="line">但Map不是集合，</span><br><span class="line">集合也不是Map。</span><br><span class="line">因此，Map继承Collection毫无意义，</span><br><span class="line">反之亦然。</span><br><span class="line">如果Map继承Collection接口，</span><br><span class="line">那么元素去哪儿？Map包含key-value对，</span><br><span class="line">它提供抽取key或value列表集合的方法，</span><br><span class="line">但是它不适合“一组对象”规范。</span><br></pre></td></tr></table></figure><h5 id="40-comparable-和-comparator的不同之处？"><a href="#40-comparable-和-comparator的不同之处？" class="headerlink" title="40.comparable 和 comparator的不同之处？"></a>40.comparable 和 comparator的不同之处？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Comparable可以认为是一个内比较器，</span><br><span class="line">实现了Comparable接口的类有一个特点，</span><br><span class="line">就是这些类是可以和自己比较的，</span><br><span class="line">至于具体和另一个实现了Comparable接口的类如何比较，</span><br><span class="line">则依赖compareTo方法的实现，</span><br><span class="line">compareTo方法也被称为自然比较方法。</span><br><span class="line">如果开发者add进入</span><br><span class="line">一个Collection的对象想要Collections的sort方法</span><br><span class="line">帮你自动进行排序的话，</span><br><span class="line">那么这个对象必须实现Comparable接口。</span><br><span class="line">compareTo方法的返回值是int，</span><br><span class="line">有三种情况：</span><br><span class="line">1、比较者大于被比较者</span><br><span class="line">（也就是compareTo方法里面的对象），</span><br><span class="line">那么返回正整数</span><br><span class="line">2、比较者等于被比较者，那么返回</span><br><span class="line">03、比较者小于被比较者，那么返回负整数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Comparator可以认为是是一个外比较器，</span><br><span class="line">个人认为有两种情况</span><br><span class="line">可以使用实现Comparator接口的方式：</span><br><span class="line">1、一个对象不支持自己和自己比较</span><br><span class="line">（没有实现Comparable接口），</span><br><span class="line">但是又想对两个对象进行比较</span><br><span class="line">2、一个对象实现了Comparable接口，</span><br><span class="line">但是开发者认为compareTo方法中的</span><br><span class="line">比较方式并不是自己想要的那种比较方式</span><br><span class="line"></span><br><span class="line">Comparator接口里面有一个compare方法，</span><br><span class="line">方法有两个参数T o1和T o2，</span><br><span class="line">是泛型的表示方式，</span><br><span class="line">分别表示待比较的两个对象，</span><br><span class="line">方法返回值和Comparable接口一样是int，</span><br><span class="line">有三种情况：</span><br><span class="line">1、o1大于o2，返回正整数</span><br><span class="line">2、o1等于o2，返回</span><br><span class="line">03、o1小于o2，返回负整数</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">两种比较器Comparable和Comparator，</span><br><span class="line">后者相比前者有如下优点：</span><br><span class="line"></span><br><span class="line">1、如果实现类没有实现Comparable接口，</span><br><span class="line">又想对两个类进行比较</span><br><span class="line">或者实现类实现了Comparable接口，</span><br><span class="line">但是对compareTo方法内的比较算法不满意，</span><br><span class="line">那么可以实现Comparator接口，</span><br><span class="line">自定义一个比较器，</span><br><span class="line">写比较算法</span><br><span class="line"></span><br><span class="line">2、实现Comparable接口的方式比</span><br><span class="line">实现Comparator接口的耦合性要强一些，</span><br><span class="line">如果要修改比较算法，</span><br><span class="line">要修改Comparable接口的实现类，</span><br><span class="line">而实现Comparator的类是在外部进行比较的，</span><br><span class="line">不需要对实现类有任何修 改。</span><br><span class="line">从这个角度说，</span><br><span class="line">其实有些不太好，</span><br><span class="line">尤其在我们将实现类的.class文件</span><br><span class="line">打成一个.jar文件</span><br><span class="line">提供给开发者使用的时候。</span><br><span class="line">实际上实现Comparator 接口的方式</span><br><span class="line">后面会写到就是一种典型的策略模式。</span><br><span class="line"></span><br><span class="line">当然，这不是鼓励用Comparator，</span><br><span class="line">意思是开发者还是要在具体场景下</span><br><span class="line">选择最合适的那种比较器而已。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题-4&quot;&gt;&lt;a href=&quot;#Java面试题-4&quot; class=&quot;headerlink&quot; title=&quot;Java面试题(4)&quot;&gt;&lt;/a&gt;Java面试题(4)&lt;/h3&gt;&lt;h5 id=&quot;31-静态变量和实例变量的区别？&quot;&gt;&lt;a href=&quot;#31-静态变量
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题(3)</title>
    <link href="https://daytable.github.io/2018/12/03/Java%E9%9D%A2%E8%AF%95%E9%A2%98(3)/"/>
    <id>https://daytable.github.io/2018/12/03/Java面试题(3)/</id>
    <published>2018-12-03T00:39:36.000Z</published>
    <updated>2018-12-04T00:23:34.599Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题-3"><a href="#Java面试题-3" class="headerlink" title="Java面试题(3)"></a>Java面试题(3)</h3><h5 id="21-final-finally-finalize的区别"><a href="#21-final-finally-finalize的区别" class="headerlink" title="21.final, finally, finalize的区别"></a>21.final, finally, finalize的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、final修饰符（关键字）。</span><br><span class="line">被final修饰的类，</span><br><span class="line">就意味着不能再派生出新的子类，</span><br><span class="line">不能作为父类而被子类继承。</span><br><span class="line">因此一个类不能既被abstract声明，</span><br><span class="line">又被final声明。将变量或方法声明为final，</span><br><span class="line">可以保证他们在使用的过程中不被修改。</span><br><span class="line">被声明为final的变量</span><br><span class="line">必须在声明时给出变量的初始值，</span><br><span class="line">而在以后的引用中只能读取。</span><br><span class="line">被final声明的方法也同样只能使用，</span><br><span class="line">即不能方法重写。</span><br></pre></td></tr></table></figure><h5 id="22-finally是在异常处理时"><a href="#22-finally是在异常处理时" class="headerlink" title="22.finally是在异常处理时"></a>22.finally是在异常处理时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">提供finally块来执行任何清除操作。</span><br><span class="line">不管有没有异常被抛出、捕获，</span><br><span class="line">finally块都会被执行。</span><br><span class="line">try块中的内容是在无异常时执行到结束。</span><br><span class="line">catch块中的内容，</span><br><span class="line">是在try块内容发生catch所声明的异常时，</span><br><span class="line">跳转到catch块中执行。finally块则是无论异常是否发生，</span><br><span class="line">都会执行finally块的内容，</span><br><span class="line">所以在代码逻辑中有需要</span><br><span class="line">无论发生什么都必须执行的代码，</span><br><span class="line">就可以放在finally块中。3、finalize是方法名。</span><br><span class="line">java技术允许使用finalize（）方法</span><br><span class="line">在垃圾收集器将对象从内存中</span><br><span class="line">清除出去之前做必要的清理工作。</span><br><span class="line">这个方法是由垃圾收集器</span><br><span class="line">在确定这个对象没有被引用时对这个对象调用的。</span><br><span class="line">它是在object类中定义的，</span><br><span class="line">因此所有的类都继承了它。</span><br><span class="line">子类覆盖finalize（）方法</span><br><span class="line">以整理系统资源或者被执行其他清理工作。</span><br><span class="line">finalize（）方法是在垃圾收集器</span><br><span class="line">删除对象之前对这个对象调用的。 </span><br><span class="line"></span><br><span class="line">###2.Overload和Override的区别。</span><br><span class="line">首先重载和重写是应用于</span><br><span class="line">两个不同场景下面的两种不同的手段：</span><br><span class="line">两者各自的特征：</span><br><span class="line">重载（Overload）:</span><br><span class="line">首先是位于一个类之中或者其子类中，</span><br><span class="line">具有相同的方法名，</span><br><span class="line">但是方法的参数不同，</span><br><span class="line">返回值类型可以相同也可以不同。</span><br><span class="line">（1）：方法名必须相同</span><br><span class="line">（2）：方法的参数列表一定不一样。</span><br><span class="line">（3）：访问修饰符和返回值类型</span><br><span class="line">可以相同也可以不同。</span><br><span class="line">其实简单而言：</span><br><span class="line">重载就是对于不同的情况写不同的方法。</span><br><span class="line"> 比如，同一个类中，</span><br><span class="line">写不同的构造函数用于初始化不同的参数。</span><br><span class="line"></span><br><span class="line">重写（override）：</span><br><span class="line">一般都是表示子类和父类之间的关系，</span><br><span class="line">其主要的特征是：</span><br><span class="line">方法名相同，</span><br><span class="line">参数相同，</span><br><span class="line">但是具体的实现不同。</span><br><span class="line"></span><br><span class="line">重写的特征：</span><br><span class="line">（1）：方法名必须相同，返回值类型必须相同</span><br><span class="line">（2）：参数列表必须相同</span><br><span class="line">（3）：访问权限不能比父类中被</span><br><span class="line">重写的方法的访问权限更低。</span><br><span class="line">例如：如果父类的一个方法被声明为public，</span><br><span class="line">那么在子类中重写该方法</span><br><span class="line">就不能声明为protected。</span><br><span class="line">（4）：子类和父类在同一个包中，</span><br><span class="line">那么子类可以重写父类所有方法，</span><br><span class="line">除了声明为private和final的方法。</span><br><span class="line">（5）：构造方法不能被重写，</span><br><span class="line">简单而言：就是具体的实现类</span><br><span class="line">对于父类的该方法实现不满意，</span><br><span class="line">需要自己在写一个满足于自己要求的方法。</span><br></pre></td></tr></table></figure><h5 id="23-Java中的String-StringBuilder-StringBuffer三者的区别"><a href="#23-Java中的String-StringBuilder-StringBuffer三者的区别" class="headerlink" title="23. Java中的String,StringBuilder,StringBuffer三者的区别?"></a>23. Java中的String,StringBuilder,StringBuffer三者的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">首先说运行速度，或者说是执行速度，</span><br><span class="line">在这方面运行速度快慢为：</span><br><span class="line">StringBuilder &gt; </span><br><span class="line">StringBuffer &gt; </span><br><span class="line">StringString最慢的原因：</span><br><span class="line">String为字符串常量，</span><br><span class="line">而StringBuilder和</span><br><span class="line">StringBuffer均为字符串变量，</span><br><span class="line">即String对象一旦创建之后</span><br><span class="line">该对象是不可更改的，</span><br><span class="line">但后两者的对象是变量，</span><br><span class="line">是可以更改的。</span><br><span class="line">而StringBuilder和StringBuffer的</span><br><span class="line">对象是变量，</span><br><span class="line">对变量进行操作就是</span><br><span class="line">直接对该对象进行更改，</span><br><span class="line">而不进行创建和回收的操作，</span><br><span class="line">所以速度要比String快很多。</span><br><span class="line">String            ----&gt;     字符串常量</span><br><span class="line">StringBuffer      ----&gt;     字符串变量（线程安全的）</span><br><span class="line">StringBuilder     ----&gt;     字符串变量（非线程安全的）</span><br><span class="line">String：</span><br><span class="line">适用于少量的字符串操作的情况</span><br><span class="line">StringBuilder：</span><br><span class="line">适用于单线程下在字符缓冲区进行大量操作的情况</span><br><span class="line">StringBuffer：</span><br><span class="line">适用多线程下在字符缓冲区进行大量操作的情况</span><br></pre></td></tr></table></figure><h5 id="24-GC是什么-为什么要有GC"><a href="#24-GC是什么-为什么要有GC" class="headerlink" title="24.GC是什么? 为什么要有GC?"></a>24.GC是什么? 为什么要有GC?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GC是垃圾收集的意思，</span><br><span class="line">内存处理是编程人员容易出现问题的地方，</span><br><span class="line">忘记或者错误的内存回收</span><br><span class="line">会导致程序或系统的不稳定甚至崩溃，</span><br><span class="line">Java提供的GC功能</span><br><span class="line">可以自动监测对象是否超过作用域</span><br><span class="line">从而达到自动回收内存的目的，</span><br><span class="line">Java语言没有提供释放已分配内存的</span><br><span class="line">显示操作方法。</span><br><span class="line">Java程序员不用担心内存管理，</span><br><span class="line">因为垃圾收集器会自动进行管理。</span><br><span class="line">要请求垃圾收集，</span><br><span class="line">可以调用下面的方法之一：</span><br><span class="line">System.gc()或Runtime.getRuntime().gc()，</span><br><span class="line">但JVM可以屏蔽掉显示的垃圾回收调用。 </span><br><span class="line"></span><br><span class="line">垃圾回收可以有效的防止内存泄露，</span><br><span class="line">有效的使用可以使用的内存。</span><br><span class="line">垃圾回收器通常是作为</span><br><span class="line">一个单独的低优先级的线程运行，</span><br><span class="line">不可预知的情况下对内存堆中</span><br><span class="line">已经死亡的或者长时间</span><br><span class="line">没有使用的对象进行清除和回收，</span><br><span class="line">程序员不能实时的调用垃圾回收器</span><br><span class="line">对某个对象或所有对象进行垃圾回收。</span><br><span class="line">Java有了GC，</span><br><span class="line">就不需要程序员去人工释放内存空间。</span><br><span class="line">当Java虚拟机发觉内存资源紧张的时候，</span><br><span class="line">就会自动地去清理</span><br><span class="line">无用变量所占用的内存空间。</span><br><span class="line">当然，如果需要，</span><br><span class="line">程序员可以在Java程序中显式地使用System.gc()</span><br><span class="line">来强制进行一次立即的内存清理。</span><br></pre></td></tr></table></figure><h5 id="25-构造器如何工作？"><a href="#25-构造器如何工作？" class="headerlink" title="25.构造器如何工作？"></a>25.构造器如何工作？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java在构造实例时的顺序是这样的：</span><br><span class="line">1、分配对象空间，</span><br><span class="line">并将对象中成员初始化为0或者空</span><br><span class="line">java不允许用户操纵一个不定值的对象。 　　</span><br><span class="line">2、执行属性值的显式初始化 　　</span><br><span class="line">3、执行构造器 　　</span><br><span class="line">4 、将变量关联到堆中的对象上</span><br></pre></td></tr></table></figure><h5 id="26-构造器Constructor是否可被override"><a href="#26-构造器Constructor是否可被override" class="headerlink" title="26.构造器Constructor是否可被override?"></a>26.构造器Constructor是否可被override?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">构造器Constructor不能被继承，</span><br><span class="line">因此不能重写Overriding，</span><br><span class="line">但可以被重载Overloading </span><br><span class="line">1). 构造器不能是</span><br><span class="line">native,final,static,synchronized 的,</span><br><span class="line">可以是public,private,或什么都没有。 </span><br><span class="line">2). 构造器函数里可以写return呢,</span><br><span class="line">但后面什么都不许有(包括null) </span><br><span class="line">3). 构造器不能返回值. </span><br><span class="line">但如果有个&quot;构造器&quot;返值了,</span><br><span class="line">它就不是构造器喽,只是个普通方法 </span><br><span class="line">4). super();this();</span><br><span class="line">这两个方法只能在构造方法里调用. </span><br><span class="line">5). 成员变量声明时候赋值,比构造函数还早.</span><br></pre></td></tr></table></figure><h5 id="27-写一个Singleton出来。"><a href="#27-写一个Singleton出来。" class="headerlink" title="27.写一个Singleton出来。"></a>27.写一个Singleton出来。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Singleton模式主要作用是保证在Java应用程序中，</span><br><span class="line">一个类Class只有一个实例存在。 </span><br><span class="line">一般Singleton模式通常有几种种形式: </span><br><span class="line">第一种形式: 定义一个类，</span><br><span class="line">它的构造函数为private的，</span><br><span class="line">它有一个static的private的该类变量，</span><br><span class="line">在类初始化时实例话，</span><br><span class="line">通过一个public的getInstance方法获取对它的引用,</span><br><span class="line">继而调用其中的方法。 </span><br><span class="line"></span><br><span class="line">public class Singleton &#123; </span><br><span class="line"> private Singleton()&#123;&#125; </span><br><span class="line">　　//在自己内部定义自己一个实例，是不是很奇怪？ 　　</span><br><span class="line">    //注意这是private 只供内部调用 　　</span><br><span class="line">    private static Singleton instance = new Singleton(); </span><br><span class="line">　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 　</span><br><span class="line">  　public static Singleton getInstance() &#123; </span><br><span class="line">　　　　return instance; 　　 </span><br><span class="line">　　 &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">第二种形式: </span><br><span class="line">public class Singleton &#123; </span><br><span class="line">　　private static Singleton instance = null; </span><br><span class="line">　　public static synchronized Singleton getInstance() &#123; </span><br><span class="line">　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　</span><br><span class="line">　　//使用时生成实例，提高了效率！ 　　</span><br><span class="line">  　if (instance==null) </span><br><span class="line">　　　　instance＝new Singleton(); </span><br><span class="line">        return instance; 　　</span><br><span class="line">  　&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">其他形式: </span><br><span class="line">定义一个类，</span><br><span class="line">它的构造函数为private的，</span><br><span class="line">所有方法为static的。 </span><br><span class="line">一般认为第一种形式要更加安全些</span><br></pre></td></tr></table></figure><h5 id="28-error和exception有什么区别"><a href="#28-error和exception有什么区别" class="headerlink" title="28.error和exception有什么区别?"></a>28.error和exception有什么区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Error类和Exception类都继承自Throwable类。</span><br><span class="line">二者的不同之处：</span><br><span class="line">Exception：</span><br><span class="line">1．可以是可被控制(checked) </span><br><span class="line">或不可控制的(unchecked)。</span><br><span class="line">2．表示一个由程序员导致的错误。</span><br><span class="line">3．应该在应用程序级被处理。</span><br><span class="line"></span><br><span class="line">Error：</span><br><span class="line">1．总是不可控制的(unchecked)。</span><br><span class="line">2．经常用来用于表示系统错误或低层资源的错误。</span><br><span class="line">3．如何可能的话，应该在系统级被捕捉。</span><br><span class="line"></span><br><span class="line">error 表示恢复不是不可能</span><br><span class="line">但很困难的情况下的一种严重问题。</span><br><span class="line">比如说内存溢出。</span><br><span class="line">不可能指望程序能处理这样的情况。 </span><br><span class="line"></span><br><span class="line">exception 表示一种设计或实现问题。</span><br><span class="line">也就是说，</span><br><span class="line">它表示如果程序运行正常，</span><br><span class="line">从不会发生的情况。</span><br></pre></td></tr></table></figure><h5 id="29-HashMap和Hashtable的区别"><a href="#29-HashMap和Hashtable的区别" class="headerlink" title="29.HashMap和Hashtable的区别?"></a>29.HashMap和Hashtable的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hashmap:</span><br><span class="line">1.线程不安全</span><br><span class="line">2.允许有null的键和值</span><br><span class="line">3.效率高一点、</span><br><span class="line">4.方法不是Synchronize的要提供外同步</span><br><span class="line">5.有containsvalue和containsKey方法</span><br><span class="line">6.HashMap 是Java1.2 </span><br><span class="line">引进的Map interface 的一个实现</span><br><span class="line">7.HashMap是Hashtable的轻量级实现hashtable:</span><br><span class="line">1.线程安全</span><br><span class="line">2.不允许有null的键和值</span><br><span class="line">3.效率稍低、</span><br><span class="line">4.方法是是Synchronize的</span><br><span class="line">5.有contains方法方法</span><br><span class="line">6.Hashtable 继承于Dictionary 类</span><br><span class="line">7.Hashtable 比HashMap 要旧</span><br></pre></td></tr></table></figure><h5 id="30-和equals-区别"><a href="#30-和equals-区别" class="headerlink" title="30.==和equals()区别?"></a>30.==和equals()区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">对于==，</span><br><span class="line">如果作用于基本数据类型的变量，</span><br><span class="line">则直接比较其存储的 </span><br><span class="line">“值”是否相等；</span><br><span class="line">如果作用于引用类型的变量，</span><br><span class="line">则比较的是所指向的对象的地址</span><br><span class="line"></span><br><span class="line">对于equals方法，</span><br><span class="line">注意：equals方法不能作用于</span><br><span class="line">基本数据类型的变量</span><br><span class="line">如果没有对equals方法进行重写，</span><br><span class="line">则比较的是引用类型的变量所指向的对象的地址；</span><br><span class="line">诸如String、Date等类</span><br><span class="line">对equals方法进行了重写的话，</span><br><span class="line">比较的是所指向的对象的内容。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题-3&quot;&gt;&lt;a href=&quot;#Java面试题-3&quot; class=&quot;headerlink&quot; title=&quot;Java面试题(3)&quot;&gt;&lt;/a&gt;Java面试题(3)&lt;/h3&gt;&lt;h5 id=&quot;21-final-finally-finalize的区别&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题(2)</title>
    <link href="https://daytable.github.io/2018/12/02/Java%E9%9D%A2%E8%AF%95%E9%A2%98(2)/"/>
    <id>https://daytable.github.io/2018/12/02/Java面试题(2)/</id>
    <published>2018-12-02T05:01:09.000Z</published>
    <updated>2018-12-04T00:22:42.691Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题-2"><a href="#Java面试题-2" class="headerlink" title="Java面试题(2)"></a>Java面试题(2)</h3><h5 id="11-面向对象的特征有哪些方面"><a href="#11-面向对象的特征有哪些方面" class="headerlink" title="11.面向对象的特征有哪些方面"></a>11.面向对象的特征有哪些方面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.抽象：</span><br><span class="line">抽象就是忽略一个主题中与当前目标无关的那些方面，</span><br><span class="line">以便更充分地注意与当前目标有关的方面。</span><br><span class="line">抽象并不打算了解全部问题，而只是选择其中的一部分，</span><br><span class="line">暂时不用部分细节。</span><br><span class="line">抽象包括两个方面，</span><br><span class="line">一是过程抽象，</span><br><span class="line">二是数据抽象。</span><br><span class="line"></span><br><span class="line">2.继承：</span><br><span class="line">继承是一种联结类的层次模型，</span><br><span class="line">并且允许和鼓励类的重用，</span><br><span class="line">它提供了一种明确表述共性的方法。</span><br><span class="line">对象的一个新类可以从现有的类中派生，</span><br><span class="line">这个过程称为类继承。</span><br><span class="line">新类继承了原始类的特性，</span><br><span class="line">新类称为原始类的派生类（子类），</span><br><span class="line">而原始类称为新类的基类（父类）。</span><br><span class="line">派生类可以从它的基类那里继承方法和实例变量，</span><br><span class="line">并且类可以修改或增加新的方法使之更适合特殊的需要。</span><br><span class="line"></span><br><span class="line">3.封装：</span><br><span class="line">封装是把过程和数据包围起来，</span><br><span class="line">对数据的访问只能通过已定义的界面。</span><br><span class="line">面向对象计算始于这个基本概念，</span><br><span class="line">即现实世界可以被描绘成一系列完全自治、</span><br><span class="line">封装的对象，</span><br><span class="line">这些对象通过一个受保护的接口访问其他对象。</span><br><span class="line">4. 多态性：</span><br><span class="line">多态性是指允许不同类的对象对同一消息作出响应。</span><br><span class="line">多态性包括参数化多态性和包含多态性。</span><br><span class="line">多态性语言具有灵活、抽象、行为共享、代码共享的优势，</span><br><span class="line">很好的解决了应用程序函数同名问题。</span><br></pre></td></tr></table></figure><h5 id="12-java-创建对象的几种方式"><a href="#12-java-创建对象的几种方式" class="headerlink" title="12.java 创建对象的几种方式"></a>12.java 创建对象的几种方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">采用new通过反射</span><br><span class="line">采用clone通过序列化机制</span><br><span class="line">前2者都需要显式地调用构造方法。</span><br><span class="line">造成耦合性最高的恰好是第一种，</span><br><span class="line">因此你发现无论什么框架，</span><br><span class="line">只要涉及到解耦必先减少new的使用。</span><br></pre></td></tr></table></figure><h5 id="13-修饰符public-private-protected-以及不写时的区别"><a href="#13-修饰符public-private-protected-以及不写时的区别" class="headerlink" title="13.修饰符public,private,protected,以及不写时的区别"></a>13.修饰符public,private,protected,以及不写时的区别</h5><table><thead><tr><th>修饰符</th><th style="text-align:left">当前类</th><th style="text-align:left">同一package</th><th style="text-align:left">子孙类</th><th style="text-align:left">其他package</th></tr></thead><tbody><tr><td>public</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td>protected</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">×</td></tr><tr><td>default</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr><tr><td>private</td><td style="text-align:left">√</td><td style="text-align:left">×</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不写时默认为friendly/default</span><br><span class="line">friendly权限是java的默认权限，</span><br><span class="line">也称作包（package）访问权限</span><br><span class="line">只要不加private、public、protect的</span><br><span class="line">就是friendly访问权限，</span><br><span class="line">所有的成员仅限同一个包内的成员访问</span><br></pre></td></tr></table></figure><h5 id="14-String-s-new-String-“xyz”-创建了几个String-Object"><a href="#14-String-s-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="14.String s = new String(“xyz”);创建了几个String Object"></a>14.String s = new String(“xyz”);创建了几个String Object</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个，一个字符对象，一个字符对象引用对象</span><br></pre></td></tr></table></figure><h5 id="15-Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#15-Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?"></a>15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.round(11.5)==12;Math.round(-11.5)==-11;</span><br><span class="line">round方法返回与参数最接近的长整数，</span><br><span class="line">参数加1/2后求其floor</span><br></pre></td></tr></table></figure><h5 id="16-Java有没有goto"><a href="#16-Java有没有goto" class="headerlink" title="16.Java有没有goto?"></a>16.Java有没有goto?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java中的保留字，现在没有在java中使用</span><br></pre></td></tr></table></figure><h5 id="17-Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型"><a href="#17-Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型"></a>17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法的重写Overriding和重载Overloading是Java多态性的不同表现。</span><br><span class="line">重写Overriding是父类与子类之间多态性的一种表现，</span><br><span class="line">重载Overloading是一个类中多态性的一种表现。</span><br><span class="line">如果在子类中定义某方法与其父类有相同的名称和参数，</span><br><span class="line">我们说该方法被重写 (Overriding)。</span><br><span class="line">子类的对象使用这个方法时，</span><br><span class="line">将调用子类中的定义，</span><br><span class="line">对它而言，</span><br><span class="line">父类中的定义如同被&quot;屏蔽&quot;了。</span><br><span class="line">如果在一个类中定义了多个同名的方法，</span><br><span class="line">它们或有不同的参数个数或有不同的参数类型，</span><br><span class="line">则称为方法的重载(Overloading)。</span><br><span class="line">Overloaded的方法是可以改变返回值的类型</span><br></pre></td></tr></table></figure><h5 id="18-abstract-class和interface有什么区别"><a href="#18-abstract-class和interface有什么区别" class="headerlink" title="18.abstract class和interface有什么区别"></a>18.abstract class和interface有什么区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类</span><br><span class="line">被叫做抽象类（abstract class），</span><br><span class="line">它用于要创建一个体现某些基本行为的类，</span><br><span class="line">并为该类声明方法，</span><br><span class="line">但不能在该类中实现该类的情况。</span><br><span class="line">不能创建abstract 类的实例。</span><br><span class="line"></span><br><span class="line">然而可以创建一个变量，</span><br><span class="line">其类型是一个抽象类，</span><br><span class="line">并让它指向具体子类的一个实例。</span><br><span class="line">不能有抽象构造函数或抽象静态方法。</span><br><span class="line">Abstract 类的子类为它们父类中的</span><br><span class="line">所有抽象方法提供实现，</span><br><span class="line">否则它们也是抽象类为。</span><br><span class="line"></span><br><span class="line">取而代之，在子类中实现该方法。</span><br><span class="line">知道其行为的其它类可以在类中实现这些方法</span><br><span class="line">接口（interface）是抽象类的变体。</span><br><span class="line"></span><br><span class="line">在接口中，所有方法都是抽象的。</span><br><span class="line">多继承性可通过实现这样的接口而获得。</span><br><span class="line">接口中的所有方法都是抽象的，</span><br><span class="line">没有一个有程序体。</span><br><span class="line"></span><br><span class="line">接口只可以定义static final成员变量。</span><br><span class="line">接口的实现与子类相似，</span><br><span class="line">除了该实现类不能从接口定义中继承行为。</span><br><span class="line"></span><br><span class="line">当类实现特殊接口时，</span><br><span class="line">它定义（即将程序体给予）所有这种接口的方法。</span><br><span class="line">然后，它可以在实现了该接口的类的</span><br><span class="line">任何对象上调用接口的方法。</span><br><span class="line"></span><br><span class="line">由于有抽象类，</span><br><span class="line">它允许使用接口名作为引用变量的类型。</span><br><span class="line">通常的动态联编将生效。</span><br><span class="line">引用可以转换到接口类型或</span><br><span class="line">从接口类型转换，instanceof 运算符可以用来</span><br><span class="line">决定某对象的类是否实现了接口</span><br></pre></td></tr></table></figure><h5 id="19-接口是否可继承接口"><a href="#19-接口是否可继承接口" class="headerlink" title="19.接口是否可继承接口?"></a>19.接口是否可继承接口?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接口可以继承接口。</span><br><span class="line">抽象类可以实现(implements)接口，</span><br><span class="line">抽象类是否可继承实体类，但</span><br><span class="line">前提是实体类必须有明确的构造函数</span><br></pre></td></tr></table></figure><h5 id="20-swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"><a href="#20-swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上" class="headerlink" title="20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"></a>20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">swtich（）里面必须是int和enum--即枚举类型。</span><br><span class="line">short、 char 或者 byte</span><br><span class="line">他会自动转换为int的。。</span><br><span class="line">long不能自动转换为int..</span><br><span class="line">因为long比int范围大..</span><br><span class="line">可能会丢失精度..</span><br><span class="line"></span><br><span class="line">在java的1.7之后的jdk版本，</span><br><span class="line">java中的switch里面表达式的类型</span><br><span class="line">可以是string类型,</span><br><span class="line">之前是不可以使用的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题-2&quot;&gt;&lt;a href=&quot;#Java面试题-2&quot; class=&quot;headerlink&quot; title=&quot;Java面试题(2)&quot;&gt;&lt;/a&gt;Java面试题(2)&lt;/h3&gt;&lt;h5 id=&quot;11-面向对象的特征有哪些方面&quot;&gt;&lt;a href=&quot;#11-面向对象的
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java面试题(1)</title>
    <link href="https://daytable.github.io/2018/12/01/Java%E9%9D%A2%E8%AF%95%E9%A2%98(1)/"/>
    <id>https://daytable.github.io/2018/12/01/Java面试题(1)/</id>
    <published>2018-12-01T06:26:34.000Z</published>
    <updated>2018-12-04T03:46:28.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试题-1"><a href="#Java面试题-1" class="headerlink" title="Java面试题(1)"></a>Java面试题(1)</h3><h5 id="1-简述JDK、JRE、JVM？"><a href="#1-简述JDK、JRE、JVM？" class="headerlink" title="1.简述JDK、JRE、JVM？"></a>1.简述JDK、JRE、JVM？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">一、JDK </span><br><span class="line">JDK(Java Development Kit) 是整个JAVA的核心，</span><br><span class="line">包括了Java运行环境（Java Runtime Envirnment），</span><br><span class="line">一堆Java工具（javac/java/jdb等）</span><br><span class="line">和Java基础的类库（即Java API 包括rt.jar）。 </span><br><span class="line">JDK是java开发工具包，</span><br><span class="line">基本上每个学java的人都会先在机器 上装一个JDK，</span><br><span class="line">那他都包含哪几部分呢？</span><br><span class="line">在目录下面有 六个文件夹、</span><br><span class="line">一个src类库源码压缩包、和其他几个声明文件。</span><br><span class="line">其中，真正在运行java时起作用的 </span><br><span class="line">是以下四个文件夹：bin、include、lib、 jre。</span><br><span class="line">有这样一个关系，JDK包含JRE，而JRE包 含JVM。 </span><br><span class="line">bin:最主要的是编译器(javac.exe) </span><br><span class="line">include:java和JVM交互用的头文件 </span><br><span class="line">lib：类库 </span><br><span class="line">jre:java运行环境 </span><br><span class="line"></span><br><span class="line">二、JRE </span><br><span class="line">JRE（Java Runtime Environment，Java运行环境）</span><br><span class="line">包含JVM标准实现及Java核心类库。</span><br><span class="line">JRE是Java运行环境，并不是一个开发环境，</span><br><span class="line">所以没有包含任何开发工具（如编译器和调试器） </span><br><span class="line">JRE是指java运行环境。</span><br><span class="line">光有JVM还不能成class的 执行，</span><br><span class="line">因为在解释class的时候JVM需要调用解释所需要的类库lib。 （</span><br><span class="line">jre里有运行.class的java.exe） </span><br><span class="line">JRE （ Java Runtime Environment ），</span><br><span class="line">是运行 Java 程序必不可少的</span><br><span class="line">（除非用其他一些编译环境编译成.exe可执行文件……），</span><br><span class="line">JRE的 地位就象一台PC机一样，</span><br><span class="line">我们写好的Win64应用程序需要操作系统帮 我们运行，</span><br><span class="line">同样的，我们编写的Java程序也必须要JRE才能运行。</span><br><span class="line"></span><br><span class="line">三、JVM </span><br><span class="line">JVM（Java Virtual Machine），</span><br><span class="line">即java虚拟机, java运行时的环境，</span><br><span class="line">JVM是一种用于计算设备的规范，</span><br><span class="line">它是一个虚构出来的计算机，</span><br><span class="line">是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line">针对java用户，</span><br><span class="line">也就是拥有可运行的.class文件包（jar或者war）的用户。</span><br><span class="line">里面主要包含了jvm和java运行时基本类库（rt.jar）。</span><br><span class="line">rt.jar可以简单粗暴地理解为：</span><br><span class="line">它就是java源码编译成的jar包。</span><br><span class="line">Java虚拟机在执行字节码时，</span><br><span class="line">把字节码解释成具体平台上的机器指令执行。</span><br><span class="line">这就是Java的能够“一次编译，</span><br><span class="line">到处运行”的原因。</span><br></pre></td></tr></table></figure><h5 id="2-JDK、JRE、JVM三者的有什么联系和区别？"><a href="#2-JDK、JRE、JVM三者的有什么联系和区别？" class="headerlink" title="2.JDK、JRE、JVM三者的有什么联系和区别？"></a>2.JDK、JRE、JVM三者的有什么联系和区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.三者联系：</span><br><span class="line">JVM不能单独搞定class的执行，</span><br><span class="line">解释class的时候JVM需要调用解释所需要的类库lib。</span><br><span class="line">在JDK下面的的jre目录里面</span><br><span class="line">有两个文件夹bin和lib,</span><br><span class="line">在这里可以认为bin里的就是jvm，</span><br><span class="line">lib中则是jvm工作所需要的类库，</span><br><span class="line">而jvm和 lib和起来就称为jre。</span><br><span class="line">JVM+Lib=JRE。</span><br><span class="line">总体来说就是，</span><br><span class="line">我们利用JDK（调用JAVA API）开发了属于</span><br><span class="line">我们自己的JAVA程序后，</span><br><span class="line">通过JDK中的编译程序（javac）</span><br><span class="line">将我们的文本java文件编译成JAVA字节码，</span><br><span class="line">在JRE上运行这些JAVA字节码，</span><br><span class="line">JVM解析这些字节码，</span><br><span class="line">映射到CPU指令集或OS的系统调用。2.三者区别： </span><br><span class="line">JDK和JRE区别：</span><br><span class="line">在bin文件夹下会发现，</span><br><span class="line">JDK有javac.exe而JRE里面没有，</span><br><span class="line">javac指令是用来将java文件编译成class文件的，</span><br><span class="line">这是开发者需要的，</span><br><span class="line">而用户（只需要运行的人）是不需要的。</span><br><span class="line">JDK还有jar.exe, javadoc.exe等等</span><br><span class="line">用于开发的可执行指令文件。</span><br><span class="line">这也证实了一个是开发环境，</span><br><span class="line">一个是运行环境。 </span><br><span class="line">b.JRE和JVM区别：</span><br><span class="line">JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，</span><br><span class="line">尤其是rt.jar。</span><br></pre></td></tr></table></figure><h5 id="3-简述Java程序编译和运行的过程？"><a href="#3-简述Java程序编译和运行的过程？" class="headerlink" title="3.简述Java程序编译和运行的过程？"></a>3.简述Java程序编译和运行的过程？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">Java程序从源文件创建到程序运行要经过两大步骤：</span><br><span class="line">1、源文件由编译器编译成字节码（ByteCode）； </span><br><span class="line">2、字节码由java虚拟机解释运行。</span><br><span class="line">因为java程序既要编译同时</span><br><span class="line">也要经过JVM的解释运行，</span><br><span class="line">所以说Java被称为半解释语言</span><br><span class="line"></span><br><span class="line">第一步（编译）：</span><br><span class="line">创建完源文件之后，</span><br><span class="line">程序先要被JVM中的java编译器</span><br><span class="line">进行编译为.class文件。</span><br><span class="line">java编译一个类时，</span><br><span class="line">如果这个类所依赖的类还没有被编译，</span><br><span class="line"></span><br><span class="line">编译器会自动的先编译这个所依赖的类，</span><br><span class="line">然后引用。</span><br><span class="line">如果java编译器在指定的目录下</span><br><span class="line">找不到该类所依赖的类的 .class文件或者 .java源文件，</span><br><span class="line">就会报&quot;Cant found sysbol&quot;的异常错误。</span><br><span class="line"></span><br><span class="line">编译后的字节码文件格式</span><br><span class="line">主要分为两部分：</span><br><span class="line">常量池和方法字节码。</span><br><span class="line">常量池记录的是代码出现过的（常量、类名、成员变量等）</span><br><span class="line">以及符号引用（类引用、方法引用，成员变量引用等）；</span><br><span class="line">方法字节码中放的是各个方法的字节码。</span><br><span class="line"></span><br><span class="line">第二步（运行）：</span><br><span class="line">java类运行的过程大概分为两个步骤：</span><br><span class="line">（1）类的加载 </span><br><span class="line">（2）类的执行。</span><br><span class="line">需要说明的一点的是：</span><br><span class="line">JVM主要在程序第一次运行时主动使用类的时候，</span><br><span class="line">才会立即去加载。</span><br><span class="line">换言之，</span><br><span class="line">JVM并不是在运行时就会把所有使用到的类</span><br><span class="line">都加载到内存中，</span><br><span class="line">而是用到，不得不加载的时候，</span><br><span class="line">才加载进来，而且只加载一次！</span><br></pre></td></tr></table></figure><h5 id="4-请说出八种基础数据类型及字节大小？"><a href="#4-请说出八种基础数据类型及字节大小？" class="headerlink" title="4.请说出八种基础数据类型及字节大小？"></a>4.请说出八种基础数据类型及字节大小？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. byte                  8位</span><br><span class="line">2. short                16位</span><br><span class="line">3. int                  32位</span><br><span class="line">4. long                 64位</span><br><span class="line">5. float                32位</span><br><span class="line">6. double               64位</span><br><span class="line">7. boolean               1位</span><br><span class="line">8. char                 16位</span><br></pre></td></tr></table></figure><h5 id="5-说说-amp-和-amp-amp-的区别？"><a href="#5-说说-amp-和-amp-amp-的区别？" class="headerlink" title="5.说说&amp;和&amp;&amp;的区别？"></a>5.说说&amp;和&amp;&amp;的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;和&amp;&amp;都是逻辑运算符，</span><br><span class="line">都是判断两边同时真则为真，否则为假；</span><br><span class="line">但是&amp;&amp;当第一个条件不成之后，</span><br><span class="line">后面的条件都不执行了，</span><br><span class="line">而&amp;则还是继续执行，</span><br><span class="line">直到整个条件语句执行完为止。</span><br></pre></td></tr></table></figure><h5 id="6-float型float-f-3-4是否正确"><a href="#6-float型float-f-3-4是否正确" class="headerlink" title="6.float型float f=3.4是否正确?"></a>6.float型float f=3.4是否正确?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">不正确；</span><br><span class="line">精度不准确,</span><br><span class="line">应该用强制类型转换，</span><br><span class="line">如下所示：float f=(float)3.4</span><br></pre></td></tr></table></figure><h5 id="7-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#7-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a>7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">short s1 = 1; s1 = s1 + 1; </span><br><span class="line">s1+1运算结果是int型，</span><br><span class="line">需要强制转换类型； </span><br><span class="line"></span><br><span class="line">short s1 = 1; s1 += 1;</span><br><span class="line">可以正确编译,自动类型提升。</span><br></pre></td></tr></table></figure><h5 id="8-int-和-Integer-有什么区别"><a href="#8-int-和-Integer-有什么区别" class="headerlink" title="8.int 和 Integer 有什么区别?"></a>8.int 和 Integer 有什么区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Java 提供两种不同的类型：</span><br><span class="line">引用类型和原始类型（或内置类型）；</span><br><span class="line">int是java的原始数据类型，</span><br><span class="line">Integer是java为int提供的封装类。 </span><br><span class="line"></span><br><span class="line">引用类型和原始类型的行为完全不同，</span><br><span class="line">并且它们具有不同的语义。</span><br><span class="line">引用类型和原始类型具有不同的特征和用法，</span><br><span class="line"></span><br><span class="line">它们包括：大小和速度问题，</span><br><span class="line">这种类型以哪种类型的数据结构存储，</span><br><span class="line"></span><br><span class="line">当引用类型和原始类型</span><br><span class="line">用作某个类的实例数据时所指定的缺省值。</span><br><span class="line"></span><br><span class="line">对象引用实例变量的缺省值为 null，</span><br><span class="line">而原始类型实例变量的缺省值</span><br><span class="line">与它们的类型有关。</span><br></pre></td></tr></table></figure><h5 id="9-在JAVA中，如何跳出当前的多重嵌套循环？"><a href="#9-在JAVA中，如何跳出当前的多重嵌套循环？" class="headerlink" title="9.在JAVA中，如何跳出当前的多重嵌套循环？"></a>9.在JAVA中，如何跳出当前的多重嵌套循环？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在最外层循环前加label标识,</span><br><span class="line">然后用break:label方法即可跳出多重循环。</span><br><span class="line">ok:while(true)&#123;    while(true)&#123;        break ok;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-使用嵌套的for循环打印九九乘法表。"><a href="#10-使用嵌套的for循环打印九九乘法表。" class="headerlink" title="10.使用嵌套的for循环打印九九乘法表。"></a>10.使用嵌套的for循环打印九九乘法表。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;       </span><br><span class="line">  for (int i = 1; i &lt;= 9; i++) &#123;            </span><br><span class="line">    for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">      System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java面试题-1&quot;&gt;&lt;a href=&quot;#Java面试题-1&quot; class=&quot;headerlink&quot; title=&quot;Java面试题(1)&quot;&gt;&lt;/a&gt;Java面试题(1)&lt;/h3&gt;&lt;h5 id=&quot;1-简述JDK、JRE、JVM？&quot;&gt;&lt;a href=&quot;#1-简述JDK
      
    
    </summary>
    
      <category term="Java面试题" scheme="https://daytable.github.io/categories/Java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="https://daytable.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://daytable.github.io/2018/11/09/hello-world/"/>
    <id>https://daytable.github.io/2018/11/09/hello-world/</id>
    <published>2018-11-09T10:54:47.838Z</published>
    <updated>2018-11-09T10:54:47.841Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
