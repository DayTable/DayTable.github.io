<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>惬意</title>
  
  <subtitle>Don&#39;t let your dreams just be dreams</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-03T00:41:52.541Z</updated>
  <id>http://yoursite.com/</id>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java每天10道面试题第3天</title>
    <link href="http://yoursite.com/2018/12/03/Java%E6%AF%8F%E5%A4%A910%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC3%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/12/03/Java每天10道面试题第3天/</id>
    <published>2018-12-03T00:39:36.000Z</published>
    <updated>2018-12-03T00:41:52.541Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java每天10道面试题第3天"><a href="#Java每天10道面试题第3天" class="headerlink" title="Java每天10道面试题第3天"></a>Java每天10道面试题第3天</h3><h5 id="21-final-finally-finalize的区别"><a href="#21-final-finally-finalize的区别" class="headerlink" title="21.final, finally, finalize的区别"></a>21.final, finally, finalize的区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1、final修饰符（关键字）。</span><br><span class="line">被final修饰的类，</span><br><span class="line">就意味着不能再派生出新的子类，</span><br><span class="line">不能作为父类而被子类继承。</span><br><span class="line">因此一个类不能既被abstract声明，</span><br><span class="line">又被final声明。将变量或方法声明为final，</span><br><span class="line">可以保证他们在使用的过程中不被修改。</span><br><span class="line">被声明为final的变量</span><br><span class="line">必须在声明时给出变量的初始值，</span><br><span class="line">而在以后的引用中只能读取。</span><br><span class="line">被final声明的方法也同样只能使用，</span><br><span class="line">即不能方法重写。</span><br></pre></td></tr></table></figure><h5 id="22-finally是在异常处理时"><a href="#22-finally是在异常处理时" class="headerlink" title="22.finally是在异常处理时"></a>22.finally是在异常处理时</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">提供finally块来执行任何清除操作。</span><br><span class="line">不管有没有异常被抛出、捕获，</span><br><span class="line">finally块都会被执行。</span><br><span class="line">try块中的内容是在无异常时执行到结束。</span><br><span class="line">catch块中的内容，</span><br><span class="line">是在try块内容发生catch所声明的异常时，</span><br><span class="line">跳转到catch块中执行。finally块则是无论异常是否发生，</span><br><span class="line">都会执行finally块的内容，</span><br><span class="line">所以在代码逻辑中有需要</span><br><span class="line">无论发生什么都必须执行的代码，</span><br><span class="line">就可以放在finally块中。3、finalize是方法名。</span><br><span class="line">java技术允许使用finalize（）方法</span><br><span class="line">在垃圾收集器将对象从内存中</span><br><span class="line">清除出去之前做必要的清理工作。</span><br><span class="line">这个方法是由垃圾收集器</span><br><span class="line">在确定这个对象没有被引用时对这个对象调用的。</span><br><span class="line">它是在object类中定义的，</span><br><span class="line">因此所有的类都继承了它。</span><br><span class="line">子类覆盖finalize（）方法</span><br><span class="line">以整理系统资源或者被执行其他清理工作。</span><br><span class="line">finalize（）方法是在垃圾收集器</span><br><span class="line">删除对象之前对这个对象调用的。 </span><br><span class="line"></span><br><span class="line">###2.Overload和Override的区别。</span><br><span class="line">首先重载和重写是应用于</span><br><span class="line">两个不同场景下面的两种不同的手段：</span><br><span class="line">两者各自的特征：</span><br><span class="line">重载（Overload）:</span><br><span class="line">首先是位于一个类之中或者其子类中，</span><br><span class="line">具有相同的方法名，</span><br><span class="line">但是方法的参数不同，</span><br><span class="line">返回值类型可以相同也可以不同。</span><br><span class="line">（1）：方法名必须相同</span><br><span class="line">（2）：方法的参数列表一定不一样。</span><br><span class="line">（3）：访问修饰符和返回值类型</span><br><span class="line">可以相同也可以不同。</span><br><span class="line">其实简单而言：</span><br><span class="line">重载就是对于不同的情况写不同的方法。</span><br><span class="line"> 比如，同一个类中，</span><br><span class="line">写不同的构造函数用于初始化不同的参数。</span><br><span class="line"></span><br><span class="line">重写（override）：</span><br><span class="line">一般都是表示子类和父类之间的关系，</span><br><span class="line">其主要的特征是：</span><br><span class="line">方法名相同，</span><br><span class="line">参数相同，</span><br><span class="line">但是具体的实现不同。</span><br><span class="line"></span><br><span class="line">重写的特征：</span><br><span class="line">（1）：方法名必须相同，返回值类型必须相同</span><br><span class="line">（2）：参数列表必须相同</span><br><span class="line">（3）：访问权限不能比父类中被</span><br><span class="line">重写的方法的访问权限更低。</span><br><span class="line">例如：如果父类的一个方法被声明为public，</span><br><span class="line">那么在子类中重写该方法</span><br><span class="line">就不能声明为protected。</span><br><span class="line">（4）：子类和父类在同一个包中，</span><br><span class="line">那么子类可以重写父类所有方法，</span><br><span class="line">除了声明为private和final的方法。</span><br><span class="line">（5）：构造方法不能被重写，</span><br><span class="line">简单而言：就是具体的实现类</span><br><span class="line">对于父类的该方法实现不满意，</span><br><span class="line">需要自己在写一个满足于自己要求的方法。</span><br></pre></td></tr></table></figure><h5 id="23-Java中的String-StringBuilder-StringBuffer三者的区别"><a href="#23-Java中的String-StringBuilder-StringBuffer三者的区别" class="headerlink" title="23. Java中的String,StringBuilder,StringBuffer三者的区别?"></a>23. Java中的String,StringBuilder,StringBuffer三者的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">首先说运行速度，或者说是执行速度，</span><br><span class="line">在这方面运行速度快慢为：</span><br><span class="line">StringBuilder &gt; </span><br><span class="line">StringBuffer &gt; </span><br><span class="line">StringString最慢的原因：</span><br><span class="line">String为字符串常量，</span><br><span class="line">而StringBuilder和</span><br><span class="line">StringBuffer均为字符串变量，</span><br><span class="line">即String对象一旦创建之后</span><br><span class="line">该对象是不可更改的，</span><br><span class="line">但后两者的对象是变量，</span><br><span class="line">是可以更改的。</span><br><span class="line">而StringBuilder和StringBuffer的</span><br><span class="line">对象是变量，</span><br><span class="line">对变量进行操作就是</span><br><span class="line">直接对该对象进行更改，</span><br><span class="line">而不进行创建和回收的操作，</span><br><span class="line">所以速度要比String快很多。</span><br><span class="line">String            ----&gt;     字符串常量</span><br><span class="line">StringBuffer      ----&gt;     字符串变量（线程安全的）</span><br><span class="line">StringBuilder     ----&gt;     字符串变量（非线程安全的）</span><br><span class="line">String：</span><br><span class="line">适用于少量的字符串操作的情况</span><br><span class="line">StringBuilder：</span><br><span class="line">适用于单线程下在字符缓冲区进行大量操作的情况</span><br><span class="line">StringBuffer：</span><br><span class="line">适用多线程下在字符缓冲区进行大量操作的情况</span><br></pre></td></tr></table></figure><h5 id="24-GC是什么-为什么要有GC"><a href="#24-GC是什么-为什么要有GC" class="headerlink" title="24.GC是什么? 为什么要有GC?"></a>24.GC是什么? 为什么要有GC?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">GC是垃圾收集的意思，</span><br><span class="line">内存处理是编程人员容易出现问题的地方，</span><br><span class="line">忘记或者错误的内存回收</span><br><span class="line">会导致程序或系统的不稳定甚至崩溃，</span><br><span class="line">Java提供的GC功能</span><br><span class="line">可以自动监测对象是否超过作用域</span><br><span class="line">从而达到自动回收内存的目的，</span><br><span class="line">Java语言没有提供释放已分配内存的</span><br><span class="line">显示操作方法。</span><br><span class="line">Java程序员不用担心内存管理，</span><br><span class="line">因为垃圾收集器会自动进行管理。</span><br><span class="line">要请求垃圾收集，</span><br><span class="line">可以调用下面的方法之一：</span><br><span class="line">System.gc()或Runtime.getRuntime().gc()，</span><br><span class="line">但JVM可以屏蔽掉显示的垃圾回收调用。 </span><br><span class="line"></span><br><span class="line">垃圾回收可以有效的防止内存泄露，</span><br><span class="line">有效的使用可以使用的内存。</span><br><span class="line">垃圾回收器通常是作为</span><br><span class="line">一个单独的低优先级的线程运行，</span><br><span class="line">不可预知的情况下对内存堆中</span><br><span class="line">已经死亡的或者长时间</span><br><span class="line">没有使用的对象进行清除和回收，</span><br><span class="line">程序员不能实时的调用垃圾回收器</span><br><span class="line">对某个对象或所有对象进行垃圾回收。</span><br><span class="line">Java有了GC，</span><br><span class="line">就不需要程序员去人工释放内存空间。</span><br><span class="line">当Java虚拟机发觉内存资源紧张的时候，</span><br><span class="line">就会自动地去清理</span><br><span class="line">无用变量所占用的内存空间。</span><br><span class="line">当然，如果需要，</span><br><span class="line">程序员可以在Java程序中显式地使用System.gc()</span><br><span class="line">来强制进行一次立即的内存清理。</span><br></pre></td></tr></table></figure><h5 id="25-构造器如何工作？"><a href="#25-构造器如何工作？" class="headerlink" title="25.构造器如何工作？"></a>25.构造器如何工作？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Java在构造实例时的顺序是这样的：</span><br><span class="line">1、分配对象空间，</span><br><span class="line">并将对象中成员初始化为0或者空</span><br><span class="line">java不允许用户操纵一个不定值的对象。 　　</span><br><span class="line">2、执行属性值的显式初始化 　　</span><br><span class="line">3、执行构造器 　　</span><br><span class="line">4 、将变量关联到堆中的对象上</span><br></pre></td></tr></table></figure><h5 id="26-构造器Constructor是否可被override"><a href="#26-构造器Constructor是否可被override" class="headerlink" title="26.构造器Constructor是否可被override?"></a>26.构造器Constructor是否可被override?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">构造器Constructor不能被继承，</span><br><span class="line">因此不能重写Overriding，</span><br><span class="line">但可以被重载Overloading </span><br><span class="line">1). 构造器不能是</span><br><span class="line">native,final,static,synchronized 的,</span><br><span class="line">可以是public,private,或什么都没有。 </span><br><span class="line">2). 构造器函数里可以写return呢,</span><br><span class="line">但后面什么都不许有(包括null) </span><br><span class="line">3). 构造器不能返回值. </span><br><span class="line">但如果有个&quot;构造器&quot;返值了,</span><br><span class="line">它就不是构造器喽,只是个普通方法 </span><br><span class="line">4). super();this();</span><br><span class="line">这两个方法只能在构造方法里调用. </span><br><span class="line">5). 成员变量声明时候赋值,比构造函数还早.</span><br></pre></td></tr></table></figure><h5 id="27-写一个Singleton出来。"><a href="#27-写一个Singleton出来。" class="headerlink" title="27.写一个Singleton出来。"></a>27.写一个Singleton出来。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Singleton模式主要作用是保证在Java应用程序中，</span><br><span class="line">一个类Class只有一个实例存在。 </span><br><span class="line">一般Singleton模式通常有几种种形式: </span><br><span class="line">第一种形式: 定义一个类，</span><br><span class="line">它的构造函数为private的，</span><br><span class="line">它有一个static的private的该类变量，</span><br><span class="line">在类初始化时实例话，</span><br><span class="line">通过一个public的getInstance方法获取对它的引用,</span><br><span class="line">继而调用其中的方法。 </span><br><span class="line"></span><br><span class="line">public class Singleton &#123; </span><br><span class="line"> private Singleton()&#123;&#125; </span><br><span class="line">　　//在自己内部定义自己一个实例，是不是很奇怪？ 　　</span><br><span class="line">    //注意这是private 只供内部调用 　　</span><br><span class="line">    private static Singleton instance = new Singleton(); </span><br><span class="line">　　//这里提供了一个供外部访问本class的静态方法，可以直接访问　　 　</span><br><span class="line">  　public static Singleton getInstance() &#123; </span><br><span class="line">　　　　return instance; 　　 </span><br><span class="line">　　 &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">第二种形式: </span><br><span class="line">public class Singleton &#123; </span><br><span class="line">　　private static Singleton instance = null; </span><br><span class="line">　　public static synchronized Singleton getInstance() &#123; </span><br><span class="line">　　//这个方法比上面有所改进，不用每次都进行生成对象，只是第一次　</span><br><span class="line">　　//使用时生成实例，提高了效率！ 　　</span><br><span class="line">  　if (instance==null) </span><br><span class="line">　　　　instance＝new Singleton(); </span><br><span class="line">        return instance; 　　</span><br><span class="line">  　&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">其他形式: </span><br><span class="line">定义一个类，</span><br><span class="line">它的构造函数为private的，</span><br><span class="line">所有方法为static的。 </span><br><span class="line">一般认为第一种形式要更加安全些</span><br></pre></td></tr></table></figure><h5 id="28-error和exception有什么区别"><a href="#28-error和exception有什么区别" class="headerlink" title="28.error和exception有什么区别?"></a>28.error和exception有什么区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Error类和Exception类都继承自Throwable类。</span><br><span class="line">二者的不同之处：</span><br><span class="line">Exception：</span><br><span class="line">1．可以是可被控制(checked) </span><br><span class="line">或不可控制的(unchecked)。</span><br><span class="line">2．表示一个由程序员导致的错误。</span><br><span class="line">3．应该在应用程序级被处理。</span><br><span class="line"></span><br><span class="line">Error：</span><br><span class="line">1．总是不可控制的(unchecked)。</span><br><span class="line">2．经常用来用于表示系统错误或低层资源的错误。</span><br><span class="line">3．如何可能的话，应该在系统级被捕捉。</span><br><span class="line"></span><br><span class="line">error 表示恢复不是不可能</span><br><span class="line">但很困难的情况下的一种严重问题。</span><br><span class="line">比如说内存溢出。</span><br><span class="line">不可能指望程序能处理这样的情况。 </span><br><span class="line"></span><br><span class="line">exception 表示一种设计或实现问题。</span><br><span class="line">也就是说，</span><br><span class="line">它表示如果程序运行正常，</span><br><span class="line">从不会发生的情况。</span><br></pre></td></tr></table></figure><h5 id="29-HashMap和Hashtable的区别"><a href="#29-HashMap和Hashtable的区别" class="headerlink" title="29.HashMap和Hashtable的区别?"></a>29.HashMap和Hashtable的区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hashmap:</span><br><span class="line">1.线程不安全</span><br><span class="line">2.允许有null的键和值</span><br><span class="line">3.效率高一点、</span><br><span class="line">4.方法不是Synchronize的要提供外同步</span><br><span class="line">5.有containsvalue和containsKey方法</span><br><span class="line">6.HashMap 是Java1.2 </span><br><span class="line">引进的Map interface 的一个实现</span><br><span class="line">7.HashMap是Hashtable的轻量级实现hashtable:</span><br><span class="line">1.线程安全</span><br><span class="line">2.不允许有null的键和值</span><br><span class="line">3.效率稍低、</span><br><span class="line">4.方法是是Synchronize的</span><br><span class="line">5.有contains方法方法</span><br><span class="line">6.Hashtable 继承于Dictionary 类</span><br><span class="line">7.Hashtable 比HashMap 要旧</span><br></pre></td></tr></table></figure><h5 id="30-和equals-区别"><a href="#30-和equals-区别" class="headerlink" title="30.==和equals()区别?"></a>30.==和equals()区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">对于==，</span><br><span class="line">如果作用于基本数据类型的变量，</span><br><span class="line">则直接比较其存储的 </span><br><span class="line">“值”是否相等；</span><br><span class="line">如果作用于引用类型的变量，</span><br><span class="line">则比较的是所指向的对象的地址</span><br><span class="line"></span><br><span class="line">对于equals方法，</span><br><span class="line">注意：equals方法不能作用于</span><br><span class="line">基本数据类型的变量</span><br><span class="line">如果没有对equals方法进行重写，</span><br><span class="line">则比较的是引用类型的变量所指向的对象的地址；</span><br><span class="line">诸如String、Date等类</span><br><span class="line">对equals方法进行了重写的话，</span><br><span class="line">比较的是所指向的对象的内容。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java每天10道面试题第3天&quot;&gt;&lt;a href=&quot;#Java每天10道面试题第3天&quot; class=&quot;headerlink&quot; title=&quot;Java每天10道面试题第3天&quot;&gt;&lt;/a&gt;Java每天10道面试题第3天&lt;/h3&gt;&lt;h5 id=&quot;21-final-fina
      
    
    </summary>
    
      <category term="Java试题" scheme="http://yoursite.com/categories/Java%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java每天10道面试题第2天</title>
    <link href="http://yoursite.com/2018/12/02/Java%E6%AF%8F%E5%A4%A910%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC2%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/12/02/Java每天10道面试题第2天/</id>
    <published>2018-12-02T05:01:09.000Z</published>
    <updated>2018-12-02T05:02:22.167Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java每天10道面试题第2天"><a href="#Java每天10道面试题第2天" class="headerlink" title="Java每天10道面试题第2天"></a>Java每天10道面试题第2天</h3><h5 id="11-面向对象的特征有哪些方面"><a href="#11-面向对象的特征有哪些方面" class="headerlink" title="11.面向对象的特征有哪些方面"></a>11.面向对象的特征有哪些方面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">1.抽象：</span><br><span class="line">抽象就是忽略一个主题中与当前目标无关的那些方面，</span><br><span class="line">以便更充分地注意与当前目标有关的方面。</span><br><span class="line">抽象并不打算了解全部问题，而只是选择其中的一部分，</span><br><span class="line">暂时不用部分细节。</span><br><span class="line">抽象包括两个方面，</span><br><span class="line">一是过程抽象，</span><br><span class="line">二是数据抽象。</span><br><span class="line"></span><br><span class="line">2.继承：</span><br><span class="line">继承是一种联结类的层次模型，</span><br><span class="line">并且允许和鼓励类的重用，</span><br><span class="line">它提供了一种明确表述共性的方法。</span><br><span class="line">对象的一个新类可以从现有的类中派生，</span><br><span class="line">这个过程称为类继承。</span><br><span class="line">新类继承了原始类的特性，</span><br><span class="line">新类称为原始类的派生类（子类），</span><br><span class="line">而原始类称为新类的基类（父类）。</span><br><span class="line">派生类可以从它的基类那里继承方法和实例变量，</span><br><span class="line">并且类可以修改或增加新的方法使之更适合特殊的需要。</span><br><span class="line"></span><br><span class="line">3.封装：</span><br><span class="line">封装是把过程和数据包围起来，</span><br><span class="line">对数据的访问只能通过已定义的界面。</span><br><span class="line">面向对象计算始于这个基本概念，</span><br><span class="line">即现实世界可以被描绘成一系列完全自治、</span><br><span class="line">封装的对象，</span><br><span class="line">这些对象通过一个受保护的接口访问其他对象。</span><br><span class="line">4. 多态性：</span><br><span class="line">多态性是指允许不同类的对象对同一消息作出响应。</span><br><span class="line">多态性包括参数化多态性和包含多态性。</span><br><span class="line">多态性语言具有灵活、抽象、行为共享、代码共享的优势，</span><br><span class="line">很好的解决了应用程序函数同名问题。</span><br></pre></td></tr></table></figure><h5 id="12-java-创建对象的几种方式"><a href="#12-java-创建对象的几种方式" class="headerlink" title="12.java 创建对象的几种方式"></a>12.java 创建对象的几种方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">采用new通过反射</span><br><span class="line">采用clone通过序列化机制</span><br><span class="line">前2者都需要显式地调用构造方法。</span><br><span class="line">造成耦合性最高的恰好是第一种，</span><br><span class="line">因此你发现无论什么框架，</span><br><span class="line">只要涉及到解耦必先减少new的使用。</span><br></pre></td></tr></table></figure><h5 id="13-修饰符public-private-protected-以及不写时的区别"><a href="#13-修饰符public-private-protected-以及不写时的区别" class="headerlink" title="13.修饰符public,private,protected,以及不写时的区别"></a>13.修饰符public,private,protected,以及不写时的区别</h5><table><thead><tr><th>修饰符</th><th style="text-align:left">当前类</th><th style="text-align:left">同一package</th><th style="text-align:left">子孙类</th><th style="text-align:left">其他package</th></tr></thead><tbody><tr><td>public</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td></tr><tr><td>protected</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">×</td></tr><tr><td>default</td><td style="text-align:left">√</td><td style="text-align:left">√</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr><tr><td>private</td><td style="text-align:left">√</td><td style="text-align:left">×</td><td style="text-align:left">×</td><td style="text-align:left">×</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">不写时默认为friendly/default</span><br><span class="line">friendly权限是java的默认权限，</span><br><span class="line">也称作包（package）访问权限</span><br><span class="line">只要不加private、public、protect的</span><br><span class="line">就是friendly访问权限，</span><br><span class="line">所有的成员仅限同一个包内的成员访问</span><br></pre></td></tr></table></figure><h5 id="14-String-s-new-String-“xyz”-创建了几个String-Object"><a href="#14-String-s-new-String-“xyz”-创建了几个String-Object" class="headerlink" title="14.String s = new String(“xyz”);创建了几个String Object"></a>14.String s = new String(“xyz”);创建了几个String Object</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个，一个字符对象，一个字符对象引用对象</span><br></pre></td></tr></table></figure><h5 id="15-Math-round-11-5-等於多少-Math-round-11-5-等於多少"><a href="#15-Math-round-11-5-等於多少-Math-round-11-5-等於多少" class="headerlink" title="15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?"></a>15.Math.round(11.5)等於多少? Math.round(-11.5)等於多少?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.round(11.5)==12;Math.round(-11.5)==-11;</span><br><span class="line">round方法返回与参数最接近的长整数，</span><br><span class="line">参数加1/2后求其floor</span><br></pre></td></tr></table></figure><h5 id="16-Java有没有goto"><a href="#16-Java有没有goto" class="headerlink" title="16.Java有没有goto?"></a>16.Java有没有goto?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java中的保留字，现在没有在java中使用</span><br></pre></td></tr></table></figure><h5 id="17-Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型"><a href="#17-Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型" class="headerlink" title="17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型"></a>17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">方法的重写Overriding和重载Overloading是Java多态性的不同表现。</span><br><span class="line">重写Overriding是父类与子类之间多态性的一种表现，</span><br><span class="line">重载Overloading是一个类中多态性的一种表现。</span><br><span class="line">如果在子类中定义某方法与其父类有相同的名称和参数，</span><br><span class="line">我们说该方法被重写 (Overriding)。</span><br><span class="line">子类的对象使用这个方法时，</span><br><span class="line">将调用子类中的定义，</span><br><span class="line">对它而言，</span><br><span class="line">父类中的定义如同被&quot;屏蔽&quot;了。</span><br><span class="line">如果在一个类中定义了多个同名的方法，</span><br><span class="line">它们或有不同的参数个数或有不同的参数类型，</span><br><span class="line">则称为方法的重载(Overloading)。</span><br><span class="line">Overloaded的方法是可以改变返回值的类型</span><br></pre></td></tr></table></figure><h5 id="18-abstract-class和interface有什么区别"><a href="#18-abstract-class和interface有什么区别" class="headerlink" title="18.abstract class和interface有什么区别"></a>18.abstract class和interface有什么区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">声明方法的存在而不去实现它的类</span><br><span class="line">被叫做抽象类（abstract class），</span><br><span class="line">它用于要创建一个体现某些基本行为的类，</span><br><span class="line">并为该类声明方法，</span><br><span class="line">但不能在该类中实现该类的情况。</span><br><span class="line">不能创建abstract 类的实例。</span><br><span class="line"></span><br><span class="line">然而可以创建一个变量，</span><br><span class="line">其类型是一个抽象类，</span><br><span class="line">并让它指向具体子类的一个实例。</span><br><span class="line">不能有抽象构造函数或抽象静态方法。</span><br><span class="line">Abstract 类的子类为它们父类中的</span><br><span class="line">所有抽象方法提供实现，</span><br><span class="line">否则它们也是抽象类为。</span><br><span class="line"></span><br><span class="line">取而代之，在子类中实现该方法。</span><br><span class="line">知道其行为的其它类可以在类中实现这些方法</span><br><span class="line">接口（interface）是抽象类的变体。</span><br><span class="line"></span><br><span class="line">在接口中，所有方法都是抽象的。</span><br><span class="line">多继承性可通过实现这样的接口而获得。</span><br><span class="line">接口中的所有方法都是抽象的，</span><br><span class="line">没有一个有程序体。</span><br><span class="line"></span><br><span class="line">接口只可以定义static final成员变量。</span><br><span class="line">接口的实现与子类相似，</span><br><span class="line">除了该实现类不能从接口定义中继承行为。</span><br><span class="line"></span><br><span class="line">当类实现特殊接口时，</span><br><span class="line">它定义（即将程序体给予）所有这种接口的方法。</span><br><span class="line">然后，它可以在实现了该接口的类的</span><br><span class="line">任何对象上调用接口的方法。</span><br><span class="line"></span><br><span class="line">由于有抽象类，</span><br><span class="line">它允许使用接口名作为引用变量的类型。</span><br><span class="line">通常的动态联编将生效。</span><br><span class="line">引用可以转换到接口类型或</span><br><span class="line">从接口类型转换，instanceof 运算符可以用来</span><br><span class="line">决定某对象的类是否实现了接口</span><br></pre></td></tr></table></figure><h5 id="19-接口是否可继承接口"><a href="#19-接口是否可继承接口" class="headerlink" title="19.接口是否可继承接口?"></a>19.接口是否可继承接口?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">接口可以继承接口。</span><br><span class="line">抽象类可以实现(implements)接口，</span><br><span class="line">抽象类是否可继承实体类，但</span><br><span class="line">前提是实体类必须有明确的构造函数</span><br></pre></td></tr></table></figure><h5 id="20-swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"><a href="#20-swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上" class="headerlink" title="20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上"></a>20.swtich是否能作用在byte上，是否能作用在long上，是否能作用在String上</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">swtich（）里面必须是int和enum--即枚举类型。</span><br><span class="line">short、 char 或者 byte</span><br><span class="line">他会自动转换为int的。。</span><br><span class="line">long不能自动转换为int..</span><br><span class="line">因为long比int范围大..</span><br><span class="line">可能会丢失精度..</span><br><span class="line"></span><br><span class="line">在java的1.7之后的jdk版本，</span><br><span class="line">java中的switch里面表达式的类型</span><br><span class="line">可以是string类型,</span><br><span class="line">之前是不可以使用的</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java每天10道面试题第2天&quot;&gt;&lt;a href=&quot;#Java每天10道面试题第2天&quot; class=&quot;headerlink&quot; title=&quot;Java每天10道面试题第2天&quot;&gt;&lt;/a&gt;Java每天10道面试题第2天&lt;/h3&gt;&lt;h5 id=&quot;11-面向对象的特征有哪些
      
    
    </summary>
    
      <category term="Java试题" scheme="http://yoursite.com/categories/Java%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java每天10道面试题第1天</title>
    <link href="http://yoursite.com/2018/12/01/Java%E6%AF%8F%E5%A4%A910%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98%E7%AC%AC1%E5%A4%A9/"/>
    <id>http://yoursite.com/2018/12/01/Java每天10道面试题第1天/</id>
    <published>2018-12-01T06:26:34.000Z</published>
    <updated>2018-12-02T05:52:55.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java每天10道面试题第1天"><a href="#Java每天10道面试题第1天" class="headerlink" title="Java每天10道面试题第1天"></a>Java每天10道面试题第1天</h3><h5 id="1-简述JDK、JRE、JVM？"><a href="#1-简述JDK、JRE、JVM？" class="headerlink" title="1.简述JDK、JRE、JVM？"></a>1.简述JDK、JRE、JVM？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">一、JDK </span><br><span class="line">JDK(Java Development Kit) 是整个JAVA的核心，</span><br><span class="line">包括了Java运行环境（Java Runtime Envirnment），</span><br><span class="line">一堆Java工具（javac/java/jdb等）</span><br><span class="line">和Java基础的类库（即Java API 包括rt.jar）。 </span><br><span class="line">JDK是java开发工具包，</span><br><span class="line">基本上每个学java的人都会先在机器 上装一个JDK，</span><br><span class="line">那他都包含哪几部分呢？</span><br><span class="line">在目录下面有 六个文件夹、</span><br><span class="line">一个src类库源码压缩包、和其他几个声明文件。</span><br><span class="line">其中，真正在运行java时起作用的 </span><br><span class="line">是以下四个文件夹：bin、include、lib、 jre。</span><br><span class="line">有这样一个关系，JDK包含JRE，而JRE包 含JVM。 </span><br><span class="line">bin:最主要的是编译器(javac.exe) </span><br><span class="line">include:java和JVM交互用的头文件 </span><br><span class="line">lib：类库 </span><br><span class="line">jre:java运行环境 </span><br><span class="line"></span><br><span class="line">二、JRE </span><br><span class="line">JRE（Java Runtime Environment，Java运行环境）</span><br><span class="line">包含JVM标准实现及Java核心类库。</span><br><span class="line">JRE是Java运行环境，并不是一个开发环境，</span><br><span class="line">所以没有包含任何开发工具（如编译器和调试器） </span><br><span class="line">JRE是指java运行环境。</span><br><span class="line">光有JVM还不能成class的 执行，</span><br><span class="line">因为在解释class的时候JVM需要调用解释所需要的类库lib。 （</span><br><span class="line">jre里有运行.class的java.exe） </span><br><span class="line">JRE （ Java Runtime Environment ），</span><br><span class="line">是运行 Java 程序必不可少的</span><br><span class="line">（除非用其他一些编译环境编译成.exe可执行文件……），</span><br><span class="line">JRE的 地位就象一台PC机一样，</span><br><span class="line">我们写好的Win64应用程序需要操作系统帮 我们运行，</span><br><span class="line">同样的，我们编写的Java程序也必须要JRE才能运行。</span><br><span class="line"></span><br><span class="line">三、JVM </span><br><span class="line">JVM（Java Virtual Machine），</span><br><span class="line">即java虚拟机, java运行时的环境，</span><br><span class="line">JVM是一种用于计算设备的规范，</span><br><span class="line">它是一个虚构出来的计算机，</span><br><span class="line">是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</span><br><span class="line">针对java用户，</span><br><span class="line">也就是拥有可运行的.class文件包（jar或者war）的用户。</span><br><span class="line">里面主要包含了jvm和java运行时基本类库（rt.jar）。</span><br><span class="line">rt.jar可以简单粗暴地理解为：</span><br><span class="line">它就是java源码编译成的jar包。</span><br><span class="line">Java虚拟机在执行字节码时，</span><br><span class="line">把字节码解释成具体平台上的机器指令执行。</span><br><span class="line">这就是Java的能够“一次编译，</span><br><span class="line">到处运行”的原因。</span><br></pre></td></tr></table></figure><h5 id="2-JDK、JRE、JVM三者的有什么联系和区别？"><a href="#2-JDK、JRE、JVM三者的有什么联系和区别？" class="headerlink" title="2.JDK、JRE、JVM三者的有什么联系和区别？"></a>2.JDK、JRE、JVM三者的有什么联系和区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1.三者联系：</span><br><span class="line">JVM不能单独搞定class的执行，</span><br><span class="line">解释class的时候JVM需要调用解释所需要的类库lib。</span><br><span class="line">在JDK下面的的jre目录里面</span><br><span class="line">有两个文件夹bin和lib,</span><br><span class="line">在这里可以认为bin里的就是jvm，</span><br><span class="line">lib中则是jvm工作所需要的类库，</span><br><span class="line">而jvm和 lib和起来就称为jre。</span><br><span class="line">JVM+Lib=JRE。</span><br><span class="line">总体来说就是，</span><br><span class="line">我们利用JDK（调用JAVA API）开发了属于</span><br><span class="line">我们自己的JAVA程序后，</span><br><span class="line">通过JDK中的编译程序（javac）</span><br><span class="line">将我们的文本java文件编译成JAVA字节码，</span><br><span class="line">在JRE上运行这些JAVA字节码，</span><br><span class="line">JVM解析这些字节码，</span><br><span class="line">映射到CPU指令集或OS的系统调用。2.三者区别： </span><br><span class="line">JDK和JRE区别：</span><br><span class="line">在bin文件夹下会发现，</span><br><span class="line">JDK有javac.exe而JRE里面没有，</span><br><span class="line">javac指令是用来将java文件编译成class文件的，</span><br><span class="line">这是开发者需要的，</span><br><span class="line">而用户（只需要运行的人）是不需要的。</span><br><span class="line">JDK还有jar.exe, javadoc.exe等等</span><br><span class="line">用于开发的可执行指令文件。</span><br><span class="line">这也证实了一个是开发环境，</span><br><span class="line">一个是运行环境。 </span><br><span class="line">b.JRE和JVM区别：</span><br><span class="line">JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，</span><br><span class="line">尤其是rt.jar。</span><br></pre></td></tr></table></figure><h5 id="3-简述Java程序编译和运行的过程？"><a href="#3-简述Java程序编译和运行的过程？" class="headerlink" title="3.简述Java程序编译和运行的过程？"></a>3.简述Java程序编译和运行的过程？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Java程序从源文件创建到程序运行要经过两大步骤：</span><br><span class="line">1、源文件由编译器编译成字节码（ByteCode）； </span><br><span class="line">2、字节码由java虚拟机解释运行。</span><br><span class="line">因为java程序既要编译同时</span><br><span class="line">也要经过JVM的解释运行，</span><br><span class="line">所以说Java被称为半解释语言</span><br><span class="line">![](/Java每天10道面试题第1天/1129152332.jpg)</span><br><span class="line"></span><br><span class="line">第一步（编译）：</span><br><span class="line">创建完源文件之后，</span><br><span class="line">程序先要被JVM中的java编译器</span><br><span class="line">进行编译为.class文件。</span><br><span class="line">java编译一个类时，</span><br><span class="line">如果这个类所依赖的类还没有被编译，</span><br><span class="line"></span><br><span class="line">编译器会自动的先编译这个所依赖的类，</span><br><span class="line">然后引用。</span><br><span class="line">如果java编译器在指定的目录下</span><br><span class="line">找不到该类所依赖的类的 .class文件或者 .java源文件，</span><br><span class="line">就会报&quot;Cant found sysbol&quot;的异常错误。</span><br><span class="line"></span><br><span class="line">编译后的字节码文件格式</span><br><span class="line">主要分为两部分：</span><br><span class="line">常量池和方法字节码。</span><br><span class="line">常量池记录的是代码出现过的（常量、类名、成员变量等）</span><br><span class="line">以及符号引用（类引用、方法引用，成员变量引用等）；</span><br><span class="line">方法字节码中放的是各个方法的字节码。</span><br><span class="line"></span><br><span class="line">第二步（运行）：</span><br><span class="line">java类运行的过程大概分为两个步骤：</span><br><span class="line">（1）类的加载 </span><br><span class="line">（2）类的执行。</span><br><span class="line">需要说明的一点的是：</span><br><span class="line">JVM主要在程序第一次运行时主动使用类的时候，</span><br><span class="line">才会立即去加载。</span><br><span class="line">换言之，</span><br><span class="line">JVM并不是在运行时就会把所有使用到的类</span><br><span class="line">都加载到内存中，</span><br><span class="line">而是用到，不得不加载的时候，</span><br><span class="line">才加载进来，而且只加载一次！</span><br></pre></td></tr></table></figure><h5 id="4-请说出八种基础数据类型及字节大小？"><a href="#4-请说出八种基础数据类型及字节大小？" class="headerlink" title="4.请说出八种基础数据类型及字节大小？"></a>4.请说出八种基础数据类型及字节大小？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. byte                  8位</span><br><span class="line">2. short                16位</span><br><span class="line">3. int                  32位</span><br><span class="line">4. long                 64位</span><br><span class="line">5. float                32位</span><br><span class="line">6. double               64位</span><br><span class="line">7. boolean               1位</span><br><span class="line">8. char                 16位</span><br></pre></td></tr></table></figure><h5 id="5-说说-amp-和-amp-amp-的区别？"><a href="#5-说说-amp-和-amp-amp-的区别？" class="headerlink" title="5.说说&amp;和&amp;&amp;的区别？"></a>5.说说&amp;和&amp;&amp;的区别？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;和&amp;&amp;都是逻辑运算符，</span><br><span class="line">都是判断两边同时真则为真，否则为假；</span><br><span class="line">但是&amp;&amp;当第一个条件不成之后，</span><br><span class="line">后面的条件都不执行了，</span><br><span class="line">而&amp;则还是继续执行，</span><br><span class="line">直到整个条件语句执行完为止。</span><br></pre></td></tr></table></figure><h5 id="6-float型float-f-3-4是否正确"><a href="#6-float型float-f-3-4是否正确" class="headerlink" title="6.float型float f=3.4是否正确?"></a>6.float型float f=3.4是否正确?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">答:</span><br><span class="line">不正确；</span><br><span class="line">精度不准确,</span><br><span class="line">应该用强制类型转换，</span><br><span class="line">如下所示：float f=(float)3.4</span><br></pre></td></tr></table></figure><h5 id="7-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错"><a href="#7-short-s1-1-s1-s1-1-有什么错-short-s1-1-s1-1-有什么错" class="headerlink" title="7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?"></a>7.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">short s1 = 1; s1 = s1 + 1; </span><br><span class="line">s1+1运算结果是int型，</span><br><span class="line">需要强制转换类型； </span><br><span class="line"></span><br><span class="line">short s1 = 1; s1 += 1;</span><br><span class="line">可以正确编译,自动类型提升。</span><br></pre></td></tr></table></figure><h5 id="8-int-和-Integer-有什么区别"><a href="#8-int-和-Integer-有什么区别" class="headerlink" title="8.int 和 Integer 有什么区别?"></a>8.int 和 Integer 有什么区别?</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Java 提供两种不同的类型：</span><br><span class="line">引用类型和原始类型（或内置类型）；</span><br><span class="line">int是java的原始数据类型，</span><br><span class="line">Integer是java为int提供的封装类。 </span><br><span class="line"></span><br><span class="line">引用类型和原始类型的行为完全不同，</span><br><span class="line">并且它们具有不同的语义。</span><br><span class="line">引用类型和原始类型具有不同的特征和用法，</span><br><span class="line"></span><br><span class="line">它们包括：大小和速度问题，</span><br><span class="line">这种类型以哪种类型的数据结构存储，</span><br><span class="line"></span><br><span class="line">当引用类型和原始类型</span><br><span class="line">用作某个类的实例数据时所指定的缺省值。</span><br><span class="line"></span><br><span class="line">对象引用实例变量的缺省值为 null，</span><br><span class="line">而原始类型实例变量的缺省值</span><br><span class="line">与它们的类型有关。</span><br></pre></td></tr></table></figure><h5 id="9-在JAVA中，如何跳出当前的多重嵌套循环？"><a href="#9-在JAVA中，如何跳出当前的多重嵌套循环？" class="headerlink" title="9.在JAVA中，如何跳出当前的多重嵌套循环？"></a>9.在JAVA中，如何跳出当前的多重嵌套循环？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在最外层循环前加label标识,</span><br><span class="line">然后用break:label方法即可跳出多重循环。</span><br><span class="line">ok:while(true)&#123;    while(true)&#123;        break ok;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="10-使用嵌套的for循环打印九九乘法表。"><a href="#10-使用嵌套的for循环打印九九乘法表。" class="headerlink" title="10.使用嵌套的for循环打印九九乘法表。"></a>10.使用嵌套的for循环打印九九乘法表。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class test &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;       </span><br><span class="line">  for (int i = 1; i &lt;= 9; i++) &#123;            </span><br><span class="line">    for (int j = 1; j &lt;= i; j++) &#123;</span><br><span class="line">      System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + i * j + &quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java每天10道面试题第1天&quot;&gt;&lt;a href=&quot;#Java每天10道面试题第1天&quot; class=&quot;headerlink&quot; title=&quot;Java每天10道面试题第1天&quot;&gt;&lt;/a&gt;Java每天10道面试题第1天&lt;/h3&gt;&lt;h5 id=&quot;1-简述JDK、JRE、J
      
    
    </summary>
    
      <category term="Java试题" scheme="http://yoursite.com/categories/Java%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/11/09/hello-world/"/>
    <id>http://yoursite.com/2018/11/09/hello-world/</id>
    <published>2018-11-09T10:54:47.838Z</published>
    <updated>2018-11-09T10:54:47.841Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
